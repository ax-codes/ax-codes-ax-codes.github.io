{"meta":{"title":"阿兴的博客","subtitle":null,"description":null,"author":"AX Blog","url":"https://ax-codes.github.io"},"pages":[{"title":"","date":"2020-06-09T10:00:01.885Z","updated":"2020-06-09T10:00:01.885Z","comments":true,"path":"标准.html","permalink":"https://ax-codes.github.io/%E6%A0%87%E5%87%86.html","excerpt":"","text":"标题标准标题默认从##开始，"},{"title":"关于/留言","date":"2020-06-09T10:00:01.877Z","updated":"2020-06-09T10:00:01.877Z","comments":true,"path":"about/index.html","permalink":"https://ax-codes.github.io/about/index.html","excerpt":"","text":"12345678910111213141516&#123; name: '阿兴', address: '广东省广州市', QQ: 1069784176 github: 'https://github.com/GuoXingGitHub', blog: 'http://axss.gitee.io', email: '15692413487@163.com', description: 'hahaha...', skills: [ ['C', 'C++', 'C#', '.Net', 'Sql', 'Js'], ['Linux', 'Qt'], ['网站开发', '游戏服务器'], ['数据库'], ]&#125;"},{"title":"书单","date":"2020-06-09T10:00:01.878Z","updated":"2020-06-09T10:00:01.878Z","comments":false,"path":"books/index.html","permalink":"https://ax-codes.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-09T10:00:01.878Z","updated":"2020-06-09T10:00:01.878Z","comments":false,"path":"categories/index.html","permalink":"https://ax-codes.github.io/categories/index.html","excerpt":"","text":""},{"title":"音乐","date":"2020-06-09T10:00:01.880Z","updated":"2020-06-09T10:00:01.880Z","comments":false,"path":"musics/index.html","permalink":"https://ax-codes.github.io/musics/index.html","excerpt":"","text":"iframe{ height:350px }"},{"title":"友情链接","date":"2020-06-09T10:00:01.879Z","updated":"2020-06-09T10:00:01.879Z","comments":true,"path":"links/index.html","permalink":"https://ax-codes.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-09T10:00:01.881Z","updated":"2020-06-09T10:00:01.881Z","comments":false,"path":"tags/index.html","permalink":"https://ax-codes.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-06-09T10:00:01.881Z","updated":"2020-06-09T10:00:01.881Z","comments":false,"path":"repository/index.html","permalink":"https://ax-codes.github.io/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-06-09T10:00:01.492Z","updated":"2020-06-09T10:00:01.492Z","comments":false,"path":"/404.html","permalink":"https://ax-codes.github.io/404.html","excerpt":"","text":""}],"posts":[{"title":"springboot使用日志","slug":"技术/2020-12-16-springboot使用日志","date":"2020-12-16T12:00:00.000Z","updated":"2020-12-16T06:46:01.095Z","comments":true,"path":"2020/12/16/技术/2020-12-16-springboot使用日志/","link":"","permalink":"https://ax-codes.github.io/2020/12/16/%E6%8A%80%E6%9C%AF/2020-12-16-springboot%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97/","excerpt":"","text":"前言Spring Boot 使用 Apache Commons 日志记录所有内部日志记录,Spring Boot 的默认配置为使用 Java Util Logging,Log4j2 和 Logback 提供了支持.使用这些,我们可以配置控制台日志以及文件日志.如果您使用的是 Spring Boot Starters,则 Logback 将为日志记录提供良好的支持.此外,Logback 还提供了对 Common Logging,Util Logging,Log4J 和 SLF4J 的良好支持 配置在 classpath 下新增 logback.xml,并添加下面内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"true\"&gt; &lt;!--用springProperty来配置的话，可以直接读取properties文件--&gt; &lt;springProperty scope=\"context\" name=\"LOG-DIR\" source=\"log.dir\"/&gt; &lt;!--&lt;property name=\"LOG-DIR\" value=\"/home/admin/logs\"/&gt;--&gt; &lt;property name=\"APP-NAME\" value=\"coupon\"/&gt; &lt;property name=\"LOG-PATTERN\" value=\"%red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %green([%thread]) %highlight(%-5level) %boldMagenta(%logger) - %cyan(%msg%n)\"/&gt; &lt;!--控制台--&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;!--&lt;charset&gt;UTF-8&lt;/charset&gt;--&gt; &lt;pattern&gt;$&#123;LOG-PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--日志文件--&gt; &lt;appender name=\"FILE-ALL\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--文件路径,定义了日志的切分方式,把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt; &lt;FileNamePattern&gt;$&#123;LOG-DIR&#125;/$&#123;APP-NAME&#125;/$&#123;APP-NAME&#125;-%d&#123;yyyyMMdd&#125;.log&lt;/FileNamePattern&gt; &lt;!--只保留最近10天的日志--&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt; &lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt; &lt;/rollingPolicy&gt; &lt;!--日志输出编码格式化--&gt; &lt;encoder&gt; &lt;!--&lt;charset&gt;UTF-8&lt;/charset&gt;--&gt; &lt;pattern&gt;$&#123;LOG-PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- ERROR日志文件 --&gt; &lt;appender name=\"FILE-ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!--过滤 ERROR--&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt; &lt;FileNamePattern&gt;$&#123;LOG-DIR&#125;/$&#123;APP-NAME&#125;/$&#123;APP-NAME&#125;-error-%d&#123;yyyyMMdd&#125;.log&lt;/FileNamePattern&gt; &lt;!--只保留最近10天的日志--&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt; &lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt; &lt;/rollingPolicy&gt; &lt;!--日志输出编码格式化--&gt; &lt;encoder&gt; &lt;!--&lt;charset&gt;UTF-8&lt;/charset&gt;--&gt; &lt;pattern&gt;$&#123;LOG-PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;appender-ref ref=\"FILE-ALL\"/&gt; &lt;appender-ref ref=\"FILE-ERROR\"/&gt; &lt;/root&gt; &lt;!--&lt;logger name=\"com.jjld.coupon.repository\" level=\"DEBUG\"/&gt;--&gt; &lt;!--&lt;logger name=\"com.jjld.coupon.mapper\" level=\"DEBUG\"/&gt;--&gt;&lt;/configuration&gt; 使用12345678910111213141516171819202122package com.example.spring_crm;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringCrmApplication&#123; private static final Logger logger = LoggerFactory.getLogger(SpringCrmApplication.class); public static void main(String[] args) &#123; logger.info(\"this is a info message\"); logger.warn(\"this is a warn message\"); logger.error(\"this is a error message\"); SpringApplication.run(SpringCrmApplication.class, args); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ax-codes.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://ax-codes.github.io/tags/spring/"}]},{"title":"linux下查看CPU的总核数以及逻辑核数","slug":"技术/2020-07-29-linux下查看CPU的总核数以及逻辑核数","date":"2020-07-29T12:00:00.000Z","updated":"2020-07-29T05:50:07.117Z","comments":true,"path":"2020/07/29/技术/2020-07-29-linux下查看CPU的总核数以及逻辑核数/","link":"","permalink":"https://ax-codes.github.io/2020/07/29/%E6%8A%80%E6%9C%AF/2020-07-29-linux%E4%B8%8B%E6%9F%A5%E7%9C%8BCPU%E7%9A%84%E6%80%BB%E6%A0%B8%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%80%BB%E8%BE%91%E6%A0%B8%E6%95%B0/","excerpt":"","text":"前言总核数 = 物理 CPU 个数 X 每颗物理 CPU 的核数总逻辑 CPU 数 = 物理 CPU 个数 X 每颗物理 CPU 的核数 X 超线程数 1234567891011121314# 查看物理CPU个数cat /proc/cpuinfo| grep \"physical id\"| sort| uniq| wc -l# 查看每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep \"cpu cores\"| uniq# 查看逻辑CPU的个数cat /proc/cpuinfo| grep \"processor\"| wc -l #查看CPU信息（型号）cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c#查看内 存信息# cat /proc/meminfo","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"}]},{"title":"批量导出mysql多个数据库结构和数据脚本","slug":"技术/2020-07-29-批量导出mysql多个数据库结构和数据脚本","date":"2020-07-29T12:00:00.000Z","updated":"2020-08-06T10:01:28.852Z","comments":true,"path":"2020/07/29/技术/2020-07-29-批量导出mysql多个数据库结构和数据脚本/","link":"","permalink":"https://ax-codes.github.io/2020/07/29/%E6%8A%80%E6%9C%AF/2020-07-29-%E6%89%B9%E9%87%8F%E5%AF%BC%E5%87%BAmysql%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC/","excerpt":"","text":"前言批量导出 mysql 多个数据库结构和数据脚本 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/bin/bash#### change the values below where needed.....#### 多数据库DBNAMES=\"MyDb1 MyDb2 MyDb3\"DBNAMES=\"IptvOttSqmBJ \"HOST=\"--host=127.0.0.1\"USER=\"--user=root\"PASSWORD=\"--password=test\"BACKUP_DIR=\"/root/db\"#### you can change these values but they are optional....OPTIONS=\"--default-character-set=utf8 --complete-insert --no-create-info --compact -q\"RESTORESCRIPT=\"$BACKUP_DIR/__restoreData.sql\"DATE=`/bin/date '+%y%m%d_%H%M%S'`#### 分表的数据，暂时只导出最新那个月的数据NOW_MONTH=`/bin/date '+%Y%m'`#### make no changes after this....#### start script ####echo removing old temporary files if they exists...rm -f $&#123;BACKUP_DIR&#125;/*.sql &gt; /dev/null 2&gt;&amp;1rm -f $&#123;BACKUP_DIR&#125;/*.tar &gt; /dev/null 2&gt;&amp;1cd $&#123;BACKUP_DIR&#125;for DB in $DBNAMESdo echo \"==========================================\" echo $&#123;DB&#125; echo \"==========================================\" echo 'SET FOREIGN_KEY_CHECKS=0;' &gt;&gt; $RESTORESCRIPT #### 导出表结构 mysqldump --no-data $HOST $USER $PASSWORD $DB &gt;&gt; $&#123;BACKUP_DIR&#125;/__createTables.sql echo 'source __createTables.sql;' &gt;&gt; $RESTORESCRIPT #### 导出表数据 for TABLE in `mysql $HOST $USER $PASSWORD $DB -e 'show tables' | egrep -v 'Tables_in_' `; do TABLENAME=$(echo $TABLE|awk '&#123; printf \"%s\", $0 &#125;') FILENAME=\"$&#123;TABLENAME&#125;.sql\" #### 正则忽略 &amp;&amp; 当前月数据忽略 if [[ $TABLENAME = david_*_tmp ]] || [[ $TABLENAME =~ 'david_trade_detail_' &amp;&amp; $TABLENAME != \"david_trade_detail_$&#123;NOW_MONTH&#125;\" ]] then echo $&#123;TABLENAME&#125; '忽略'; continue else echo Dumping $&#123;TABLENAME&#125; echo 'source ' $BACKUP_DIR'/'$FILENAME';' &gt;&gt; $RESTORESCRIPT mysqldump $OPTIONS $HOST $USER $PASSWORD $DB $&#123;TABLENAME&#125; &gt; $&#123;BACKUP_DIR&#125;/$&#123;FILENAME&#125; fi done #### 压缩:&lt;&lt;aaa echo 'SET FOREIGN_KEY_CHECKS=1;' &gt;&gt; $RESTORESCRIPT echo making tar... tar -cf $&#123;DB&#125;_$&#123;DATE&#125;.tar *.sql &gt; /dev/null 2&gt;&amp;1 echo compressing... gzip -9 $&#123;DB&#125;_$&#123;DATE&#125;.tar &gt; /dev/null 2&gt;&amp;1 echo removing temporary files... rm -f $&#123;BACKUP_DIR&#125;/*.sql &gt; /dev/null 2&gt;&amp;1 rm -f $&#123;BACKUP_DIR&#125;/*.tar &gt; /dev/null 2&gt;&amp;1aaa echo \"done with \" $DBdoneecho \"==========================================\"echo \" done with all database! \"echo \"==========================================\"","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"编写一个vscode插件","slug":"技术/2020-06-07-编写一个vscode插件","date":"2020-06-07T12:00:00.000Z","updated":"2020-06-10T06:39:03.100Z","comments":true,"path":"2020/06/07/技术/2020-06-07-编写一个vscode插件/","link":"","permalink":"https://ax-codes.github.io/2020/06/07/%E6%8A%80%E6%9C%AF/2020-06-07-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAvscode%E6%8F%92%E4%BB%B6/","excerpt":"","text":"前言vscode 作为现在一个应用最广泛和最强大的 ide 之一,有时候我们需要自己定制一些插件来提高我们的工作效率;这里我已经开发了一个用于 hexo 的自动生成粘贴图片的插件,踩了一点坑,这里特意记录下来插件地址:https://github.com/ax-codes/hexo-paste 官方 api 文档:https://code.visualstudio.com/api更加详细的中文文档:https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html(作者还一篇谷歌插件开发文章:http://blog.haoji.me/chrome-plugin-develop.html#da-bao-yu-fa-bu)我的 demo 例子:https://github.com/ax-codes/hexo-paste 环境macvscodenodejs 开发语言typescript 安装 vscode 插件脚手架和打包工具12npm install -g yo generator-codenpm i vsce -g 使用脚手架生成框架执行下面命令 1yo code 可以看到生成下面框架 package.json 文件描述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; //插件的名字,应全部小写,不能有空格 \"name\": \"hexo-paste\", //插件别名,支持中文 \"displayName\": \"hexo-paste\", //描述 \"description\": \"\", //关键字,用作应用市场搜索 \"keywords\": [\"hexo\", \"plugin\", \"vscode\"], //版本 \"version\": \"0.0.1\", //表示该插件适配的最低vscode版本 \"engines\": &#123; \"vscode\": \"^1.45.0\" &#125;, //插件应用市场分类,可选值： [Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs] \"categories\": [\"Other\"], //发布者,如果要发布到应用市场的话,这个名字必须与发布者一致 \"publisher\": \"ax-codes\", //图标 需要带上下面的reponsitory,不然会报这个错‘An icon requires a repository with HTTPS protocol to be specified in this package.json.’ \"icon\": \"res/logo.png\", \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/ax-codes/hexo-paste\" &#125;, //激活事件 \"activationEvents\": [ \"onCommand:extension.pasteImage\", //直接执行命令 \"onLanguage:markdown\" //定义需要执行插件逻辑的语言 可以js py... ], //插件的主入口 \"main\": \"./out/extension.js\", //插件配置项 \"contributes\": &#123; //直接执行命令 \"commands\": [ &#123; \"command\": \"extension.pasteImage\", \"title\": \"Paste Image\" &#125; ], //快捷键命令 \"keybindings\": [ &#123; \"command\": \"extension.pasteImage\", \"key\": \"ctrl+alt+v\", \"mac\": \"cmd+alt+v\", \"when\": \"editorTextFocus &amp;&amp; editorLangId == markdown\" //表示文件编辑并且必须要是markdown才回处理 &#125; ] &#125;, \"scripts\": &#123; \"vscode:prepublish\": \"yarn run compile\", \"compile\": \"tsc -p ./\", \"lint\": \"eslint src --ext ts\", \"watch\": \"tsc -watch -p ./\", \"pretest\": \"yarn run compile &amp;&amp; yarn run lint\", \"test\": \"node ./out/test/runTest.js\" &#125;, \"devDependencies\": &#123; \"@types/glob\": \"^7.1.1\", \"@types/mocha\": \"^7.0.2\", \"@types/node\": \"^13.11.0\", \"@types/vscode\": \"^1.45.0\", \"@typescript-eslint/eslint-plugin\": \"^2.30.0\", \"@typescript-eslint/parser\": \"^2.30.0\", \"eslint\": \"^6.8.0\", \"glob\": \"^7.1.6\", \"mocha\": \"^7.1.2\", \"typescript\": \"^3.8.3\", \"vscode-test\": \"^1.3.0\" &#125;, \"dependencies\": &#123; \"@types/fs-extra\": \"^9.0.1\", \"@types/uuid\": \"^8.0.0\", \"fs-extra\": \"^9.0.1\", \"moment\": \"^2.26.0\", \"upath\": \"^1.2.0\", \"uuid\": \"^8.1.0\" &#125;&#125; extension.ts 文件描述123456789101112131415161718192021// this method is called when your extension is activated// your extension is activated the very first time the command is executedexport function activate(context: vscode.ExtensionContext) &#123; Logger.channel = vscode.window.createOutputChannel(\"PasteImage\"); context.subscriptions.push(Logger.channel); Logger.log( 'Congratulations, your extension \"vscode-paste-image\" is now active!' ); // The command has been defined in the package.json file // Now provide the implementation of the command with registerCommand // The commandId parameter must match the command field in package.json let disposable = vscode.commands.registerCommand( \"extension.pasteImage\", () =&gt; &#123; //命令执行处理逻辑 &#125; ); context.subscriptions.push(disposable);&#125; 打包1vsce package 提示没有修改 README.md 文件报错 解决修改对应的 markdown 描述 icon 报错 解决 在 icon\b 下加上对应的仓库 打包成功和安装 备注默认生成的 package.json 里没有 publisher,需要加上,如果要发布到应用市场的话,这个名字必须与发布者一致","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"antd webpack 运行时切换主题","slug":"技术/2020-06-05-antd webpack 运行时切换主题","date":"2020-06-05T12:00:00.000Z","updated":"2020-06-09T10:00:01.845Z","comments":true,"path":"2020/06/05/技术/2020-06-05-antd webpack 运行时切换主题/","link":"","permalink":"https://ax-codes.github.io/2020/06/05/%E6%8A%80%E6%9C%AF/2020-06-05-antd%20webpack%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/","excerpt":"","text":"前言antd 版本:^4.1.4(和高版本没关系,我升级到最新版本样式适配到还是不怎么好)antd-theme-webpack-plugin:版本^1.3.4 antd 4.0 以后引入了黑夜主题,因为觉得加上主题切换会让系统显得高级一点,所以在此记录一下 安装插件1tyarn add antd-theme-webpack-plugin antd-theme-generator -D 备注:安装到开发环境就行 webpack 配置引入文件这几个文件可以这里下载:https://github.com/mzohaibqc/antd-theme-webpack-plugin/tree/master/examples/customize-cra/src 定义配置123456789101112131415161718192021222324252627282930313233343536// eslint-disable-next-line @typescript-eslint/no-var-requiresconst AntDesignThemePlugin = require(\"antd-theme-webpack-plugin\");// eslint-disable-next-line @typescript-eslint/no-var-requiresconst &#123; getLessVars &#125; = require(\"antd-theme-generator\");const themeVariables = getLessVars( resolve(PROJECT_ROOT, \"./src/assets/styles/vars.less\"));const defaultVars = getLessVars( \"./node_modules/antd/lib/style/themes/default.less\");const darkVars = &#123; ...getLessVars(\"./node_modules/antd/lib/style/themes/dark.less\"), \"@primary-color\": defaultVars[\"@primary-color\"],&#125;;const lightVars = &#123; ...getLessVars(\"./node_modules/antd/lib/style/themes/compact.less\"), \"@primary-color\": defaultVars[\"@primary-color\"],&#125;;fs.writeFileSync(\"./src/assets/dark.json\", JSON.stringify(darkVars));fs.writeFileSync(\"./src/assets/light.json\", JSON.stringify(lightVars));fs.writeFileSync(\"./src/assets/theme.json\", JSON.stringify(themeVariables));const options = &#123; stylesDir: resolve(PROJECT_ROOT, \"./src/assets/\"), antDir: resolve(PROJECT_ROOT, \"./node_modules/antd\"), varFile: resolve(PROJECT_ROOT, \"./src/assets/styles/vars.less\"), themeVariables: [ ...new Set([ ...Object.keys(darkVars), ...Object.keys(lightVars), ...Object.keys(themeVariables), ]), ], generateOnce: false, // generate color.less on each compilation&#125;; webpack 安装插件1new AntDesignThemePlugin(options); //引用上面定义到options less-loader 加载器关闭 javascript123&#123; javascriptEnabled: true;&#125; eg: 12345678910111213&#123; test: /\\.less$/, exclude: /node_modules/, use: [ ...getCssLoaders(2, true), &#123; loader: 'less-loader', options: &#123; javascriptEnabled: true, &#125;, &#125;, ],&#125;, index.html 添加脚本在你的 html 主体文件 body 里开头添加下列代码(一般 webpack 主体文件都是 public 里的 index.html) 1234567891011&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"/color.less\" /&gt;&lt;script&gt; window.less = &#123; async: false, env: \"production\", &#125;;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/less.js/2.7.2/less.min.js\"&gt;&lt;/script&gt; 添加动态切换逻辑代码引入前面加入的对应 json 文件,比如黑色主题就是 dark.json1import darkVars from \"@/assets/dark.json\"; 添加切换主题逻辑,使用上面引入的 json 文件进行主题切换12345678window.less .modifyVars(darkVars) .then(() =&gt; &#123; message.success(\"切换主题成功\"); &#125;) .catch(() =&gt; &#123; message.error(`切换主题失败`); &#125;); 最终效果 备注以后加样式的适合要注意各种主题都要测试,有些没有的样式可能需要自定义适配","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"ubuntu安装airflow","slug":"技术/2020-05-25-ubuntu安装airflow","date":"2020-05-25T12:00:00.000Z","updated":"2020-06-09T10:00:01.845Z","comments":true,"path":"2020/05/25/技术/2020-05-25-ubuntu安装airflow/","link":"","permalink":"https://ax-codes.github.io/2020/05/25/%E6%8A%80%E6%9C%AF/2020-05-25-ubuntu%E5%AE%89%E8%A3%85airflow/","excerpt":"","text":"前言airflow 是一个工作流功能的任务框架airflow 官网:http://airflow.apache.org/docs/stable/start.html 环境环境:windows 子 liunx 系统系统版本:ubuntu 02python 版本:3.8.2 安装1234567891011121314151617# but you can lay foundation somewhere else if you prefer# (optional)export AIRFLOW_HOME&#x3D;~&#x2F;airflow# install from pypi using pippip install apache-airflow# initialize the databaseairflow initdb# start the web server, default port is 8080airflow webserver -p 8080# start the schedulerairflow scheduler# visit localhost:8080 in the browser and enable the example dag in the home page 报错airflow 安装 psutil 的时候报错12Failed building wheel for psutilerror: command &#39;x86_64-linux-gnu-gcc&#39; failed with exit status 1 解决123pip install Scrapypip install virtualenvapt-get install python2.7 python2.7-dev or apt-get install python3 python3-dev(根据你对应的python版本) airflow 安装 mysql 插件时候报错1&#x2F;bin&#x2F;sh: 1: mysql_config: not found 解决1sudo apt-get install libmysqlclient-dev python airflow 启动报错1ModuleNotFoundError: No module named &#39;typing_extensions&#39; 解决1pip install typing_extensions airflow webserver -p 8080 运行报错1FileNotFoundError: [Errno 2] No such file or directory: &#39;gunicorn&#39; 解决12sudo apt-get install gunicornpip install gunicorn 备注将 python3 修改成默认 python 执行 1sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python3 150","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"express session存内存demo","slug":"技术/2020-05-24-express session存内存demo","date":"2020-05-24T12:00:00.000Z","updated":"2020-06-09T10:00:01.844Z","comments":true,"path":"2020/05/24/技术/2020-05-24-express session存内存demo/","link":"","permalink":"https://ax-codes.github.io/2020/05/24/%E6%8A%80%E6%9C%AF/2020-05-24-express%20session%E5%AD%98%E5%86%85%E5%AD%98demo/","excerpt":"","text":"前言express session 存内存 demo 代码12345678910111213141516171819202122232425262728293031var express = require(\"express\");var app = express();var cookieParser = require(\"cookie-parser\");var session = require(\"express-session\");app.use(cookieParser());app.use( session(&#123; secret: \"12345\", name: \"name\", cookie: &#123; maxAge: 60000 &#125;, resave: false, saveUninitialized: true, &#125;));app.get(\"/set_session\", async function (req, res) &#123; req.session.name = \"ax\"; return res.json(&#123; data: \"设置session成功\" &#125;);&#125;);app.get(\"/get_session\", async function (req, res) &#123; const name = req.session.name; return res.json(&#123; data: `session value = $&#123;name&#125;` &#125;);&#125;);var server = app.listen(9001, function () &#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nginx部署vue或react应用,并设置代理","slug":"技术/2020-05-01-nginx部署vue或react应用,并设置代理","date":"2020-05-01T12:00:00.000Z","updated":"2020-06-09T10:00:01.843Z","comments":true,"path":"2020/05/01/技术/2020-05-01-nginx部署vue或react应用,并设置代理/","link":"","permalink":"https://ax-codes.github.io/2020/05/01/%E6%8A%80%E6%9C%AF/2020-05-01-nginx%E9%83%A8%E7%BD%B2vue%E6%88%96react%E5%BA%94%E7%94%A8,%E5%B9%B6%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"前言nginx 部署 vue 或 react 应用,并设置代理 配置1234567891011121314server &#123; listen 9000; server_name localhost; location /&#123; root F:/learning/webpack/react-typescript-boilerplate/dist;//react编译的dist包路径 index index.html index.htm; try_files $uri $uri/ /index.html =404; &#125; location /api/ &#123; proxy_pass http://127.0.0.1:3000/api/;#转发请求的地址 proxy_connect_timeout 6000;#链接超时设置 proxy_read_timeout 6000;#访问接口超时设置 &#125; &#125; 重启 nginx","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"yarn脚手架或者包找不到问题","slug":"技术/2020-03-18-yarn脚手架或者包找不到问题","date":"2020-03-20T12:00:00.000Z","updated":"2020-06-09T10:00:01.840Z","comments":true,"path":"2020/03/20/技术/2020-03-18-yarn脚手架或者包找不到问题/","link":"","permalink":"https://ax-codes.github.io/2020/03/20/%E6%8A%80%E6%9C%AF/2020-03-18-yarn%E8%84%9A%E6%89%8B%E6%9E%B6%E6%88%96%E8%80%85%E5%8C%85%E6%89%BE%E4%B8%8D%E5%88%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言yarn yarn 脚手架或者包找不到问题,原因是我们的 yarn 的 bin 路径没有加到环境变量,所以系统找不到,而我们的 npm 默认安装就已经加了的,所以 npm 可以 解决把 yarn global bin 的路径加到系统环境变量中 12F:\\blog&gt;tyarn global binC:\\Users\\10697\\AppData\\Local\\Yarn\\bin","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"dva history报错问题","slug":"技术/2020-03-19-dva history报错问题","date":"2020-03-19T12:00:00.000Z","updated":"2020-06-09T10:00:01.841Z","comments":true,"path":"2020/03/19/技术/2020-03-19-dva history报错问题/","link":"","permalink":"https://ax-codes.github.io/2020/03/19/%E6%8A%80%E6%9C%AF/2020-03-19-dva%20history%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言dva 版本:2.4.1 在项目配置好 dva 后,启动看到浏览器控制台报下面错误 waring log1index.js:1 Warning: Please use &#96;require(&quot;history&quot;).createHashHistory&#96; instead of &#96;require(&quot;history&#x2F;createHashHistory&quot;)&#96;. Support for the latter will be removed in the next major release. 解决修改 dva 包的 lib 里的 index.js 里的 require(“history/createHashHistory”) 修改成 require(“history”).createHashHistory;如下图 暂时只能这样解决 重启","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"react a标签eslint问题","slug":"技术/2020-03-18-react a标签eslint问题","date":"2020-03-18T12:00:00.000Z","updated":"2020-06-09T10:00:01.840Z","comments":true,"path":"2020/03/18/技术/2020-03-18-react a标签eslint问题/","link":"","permalink":"https://ax-codes.github.io/2020/03/18/%E6%8A%80%E6%9C%AF/2020-03-18-react%20a%E6%A0%87%E7%AD%BEeslint%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言react a 标签 eslint 问题 waring log12 Line 10:33: The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble alink, use a button and change it with appropriate styles. Learn more: https:&#x2F;&#x2F;github.com&#x2F;evcohen&#x2F;eslint-plugin-jsx-a11y&#x2F;blob&#x2F;master&#x2F;docs&#x2F;rules&#x2F;anchor-is-valid.md jsx-a11y&#x2F;anchor-is-valid 解决在 eslint 的配置加上的 rules 加上1&quot;jsx-a11y&#x2F;anchor-is-valid&quot;: &quot;off&quot; 例如我的 create-react-app 项目的.eslintrc.json 的配置是: 123456&#123; \"extends\": \"react-app\", \"rules\": &#123; \"jsx-a11y/anchor-is-valid\": \"off\" &#125;&#125; a 标签改成1&lt;a href=\"# \"&gt;&#123;text&#125;&lt;/a&gt; 注意:#后面有一个空格 重启","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"d2 admin vue.config.js配置本地开发代理","slug":"技术/2019-12-28-d2 admin vue.config.js配置本地开发代理","date":"2019-12-28T02:00:00.000Z","updated":"2020-06-09T10:00:01.837Z","comments":true,"path":"2019/12/28/技术/2019-12-28-d2 admin vue.config.js配置本地开发代理/","link":"","permalink":"https://ax-codes.github.io/2019/12/28/%E6%8A%80%E6%9C%AF/2019-12-28-d2%20admin%20vue.config.js%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E4%BB%A3%E7%90%86/","excerpt":"","text":"前言d2 admin vue.config.js 配置本地开发代理 在 vue.config.js 配置12345678910111213devServer: &#123; publicPath, // 和 publicPath 保持一致 proxy: &#123; '/api': &#123; target: 'http://localhost:3000', ws: true, changeOrigin: true, pathRewrite: &#123; '^/api': '/api' &#125; &#125; &#125; &#125;,","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nginx https 配置","slug":"技术/2019-12-28-nginx https 配置","date":"2019-12-28T02:00:00.000Z","updated":"2020-06-09T10:00:01.838Z","comments":true,"path":"2019/12/28/技术/2019-12-28-nginx https 配置/","link":"","permalink":"https://ax-codes.github.io/2019/12/28/%E6%8A%80%E6%9C%AF/2019-12-28-nginx%20https%20%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前言nginx https 配置证书:我的证书是阿里云提供的免费一年的,具体下载方式可以百度 配置在 nginx 新增一个 server 节点配置 12345678910111213141516171819202122232425server # SSL配置 &#123; listen 443; server_name www.zgaiyu.com zgaiyu.com; # 改成你的域名 ssl on; root /usr/local/wx_app_api/; ssl_certificate 1_www.zgaiyu.com_bundle.crt; # 改成你的证书名称 ssl_certificate_key 2_www.zgaiyu.com.key; # 改成你的证书名称 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location ^~/wx_app_api/ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #配置反向代理 注意:最后一定要加上/不然跳转链接是http://127.0.0.1:8080/wx_app_api/ proxy_pass http://127.0.0.1:8080/; #这个8080是我web api的端口 &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"vscode注释插件","slug":"技术/2019-12-28-vscode注释插件","date":"2019-12-28T02:00:00.000Z","updated":"2020-06-09T10:00:01.839Z","comments":true,"path":"2019/12/28/技术/2019-12-28-vscode注释插件/","link":"","permalink":"https://ax-codes.github.io/2019/12/28/%E6%8A%80%E6%9C%AF/2019-12-28-vscode%E6%B3%A8%E9%87%8A%E6%8F%92%E4%BB%B6/","excerpt":"","text":"前言vscode 搜索插件并安装:korofileheadergithub:https://github.com/OBKoro1/koro1FileHeader 配置(具体配置可以参照 github wiki 修改)12345678910111213141516\"fileheader.customMade\": &#123; \"Description\": \"\", \"Author\": \"ax\", \"Github\": \"https://github.com/GuoXingGitHub\", \"Date\": \"Do not edit\", \"LastEditors\": \"ax\", \"LastEditTime\": \"Do not edit\", &#125;, \"fileheader.cursorMode\": &#123; \"description\": \"\", \"param\": \"\", \"return\": \"\" &#125;, \"fileheader.configObj\": &#123; \"createFileTime\": false &#125; 使用文件头部注释：在当前编辑文件中使用快捷键:window：ctrl+alt+i/mac：ctrl+cmd+i,即可生成文件头部注释。 函数注释：将光标放在函数行或者将光标放在函数上方的空白行使用快捷键 window：ctrl+alt+t,mac：ctrl+cmd+t，即可生成函数注释。事实上，函数注释在文件的任意位置都可生成，这里需要自己控制。","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"nestjs 使用class-validator自定义字段检测","slug":"技术/2019-12-28-nestjs 使用class-validator自定义字段检测","date":"2019-12-28T02:00:00.000Z","updated":"2020-06-09T10:00:01.838Z","comments":true,"path":"2019/12/28/技术/2019-12-28-nestjs 使用class-validator自定义字段检测/","link":"","permalink":"https://ax-codes.github.io/2019/12/28/%E6%8A%80%E6%9C%AF/2019-12-28-nestjs%20%E4%BD%BF%E7%94%A8class-validator%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E6%A3%80%E6%B5%8B/","excerpt":"","text":"前言nestjs 使用 class-validator 自定义字段检测 ### 1234567891011121314151617181920@ValidatorConstraint(&#123; async: true &#125;)export class IsUserAlreadyExistConstraint implements ValidatorConstraintInterface &#123; async validate(username: any, args: ValidationArguments) &#123; const usersRepository = await getRepository(UserEntity); return !((await usersRepository.count(&#123; username: username &#125;)) &gt; 0); &#125;&#125;export function IsUserAlreadyExist(validationOptions?: ValidationOptions) &#123; return function(object: Object, propertyName: string) &#123; registerDecorator(&#123; target: object.constructor, propertyName: propertyName, options: validationOptions, constraints: [], validator: IsUserAlreadyExistConstraint &#125;); &#125;;&#125; 使用12@IsUserAlreadyExist(&#123; message: '用户名已经存在' &#125;)username: string;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"vscode 配置vue开发环境","slug":"技术/2019-11-01-vscode 配置vue开发环境","date":"2019-11-01T09:00:00.000Z","updated":"2020-06-09T10:00:01.836Z","comments":true,"path":"2019/11/01/技术/2019-11-01-vscode 配置vue开发环境/","link":"","permalink":"https://ax-codes.github.io/2019/11/01/%E6%8A%80%E6%9C%AF/2019-11-01-vscode%20%E9%85%8D%E7%BD%AEvue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言vscode 配置 vue 开发环境 安装 vscode下载地址:https://code.visualstudio.com/ 安装 color 主题在 vscode 扩展程序里搜索 One Dark Pro 然后进行安装 安装 icon 主题在 vscode 扩展程序里搜索 Material Icon Theme 然后进行安装 安装 vue(高亮 vue 代码)在 vscode 扩展程序里搜索 vue 然后进行安装 安装 Prettier1ext install esbenp.prettier-vscode 安装 Eslint在 vscode 扩展程序里搜索 Eslint 然后进行安装 修改 setting.json12345678910111213141516171819202122232425262728293031323334&#123; &quot;editor.tabSize&quot;: 2, &quot;editor.detectIndentation&quot;: false, &quot;editor.formatOnType&quot;: false, &quot;editor.formatOnPaste&quot;: true, &quot;editor.formatOnSave&quot;: true, &quot;prettier.tabWidth&quot;: 2, &quot;prettier.semi&quot;: true, &quot;prettier.singleQuote&quot;: true, &quot;[javascript]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[html]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[markdown]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;vetur.format.options.tabSize&quot;: 2, &quot;vetur.format.defaultFormatter.html&quot;: &quot;prettyhtml&quot;, &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, &quot;eslint.autoFixOnSave&quot;: true, &quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;html&quot;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125; ], &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;, &quot;workbench.colorTheme&quot;: &quot;One Dark Pro&quot;&#125; 配置.prettierrc.js在项目根目录新增.prettierrc.js 文件新增内容 1234567module.exports &#x3D; &#123; printWidth: 200, &#x2F;&#x2F; 最大打印宽度,超出将换行 singleQuote: false, &#x2F;&#x2F; 默认单引号 ,false 默认使用双引号 bracketSpacing: true, jsxBracketSameLine: true, htmlWhitespaceSensitivity: &quot;ignore&quot; &#x2F;&#x2F; 问题1中的设置&#125;; 配置.eslintrc.js在项目根目录新增.eslintrc.js 文件新增内容 原因:修改了 Prettier 格式化后 ESlint 检查警报,并更改了我的代码格式.首先检查 ESlint 配置是否使用了 prettier 规则,如果确定使用了,则是一些自定义规则在 ESlint 和 Prettier 插件中的配置不一致导致的。检查 eslintrc.js 1234567891011121314module.exports &#x3D; &#123; root: true, env: &#123; node: true &#125;, extends: [&#39;plugin:vue&#x2F;essential&#39;, &#39;@vue&#x2F;standard&#39;], rules: &#123; &#39;no-console&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;, &#39;no-debugger&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39; &#125;, parserOptions: &#123; parser: &#39;babel-eslint&#39; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Prettier配置","slug":"技术/2019-11-01-Prettier配置","date":"2019-11-01T09:00:00.000Z","updated":"2020-06-09T10:00:01.836Z","comments":true,"path":"2019/11/01/技术/2019-11-01-Prettier配置/","link":"","permalink":"https://ax-codes.github.io/2019/11/01/%E6%8A%80%E6%9C%AF/2019-11-01-Prettier%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前言Prettier 安装命令 1ext install esbenp.prettier-vscode vue在项目根目录新增.prettierrc.js 文件新增内容 1234567module.exports &#x3D; &#123; printWidth: 200, &#x2F;&#x2F; 最大打印宽度,超出将换行 singleQuote: false, &#x2F;&#x2F; 默认单引号 ,false 默认使用双引号 bracketSpacing: true, jsxBracketSameLine: true, htmlWhitespaceSensitivity: &quot;ignore&quot; &#x2F;&#x2F; 问题1中的设置&#125;; 修改了 Prettier 格式化后 ESlint 检查警报,并更改了我的代码格式.首先检查 ESlint 配置是否使用了 prettier 规则,如果确定使用了,则是一些自定义规则在 ESlint 和 Prettier 插件中的配置不一致导致的。检查 eslintrc.js 12345678910111213141516171819202122module.exports &#x3D; &#123; root: true, env: &#123; node: true &#125;, extends: [&quot;plugin:vue&#x2F;essential&quot;, &quot;@vue&#x2F;prettier&quot;, &quot;@vue&#x2F;typescript&quot;], rules: &#123; &quot;no-console&quot;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? &quot;error&quot; : &quot;off&quot;, &quot;no-debugger&quot;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? &quot;error&quot; : &quot;off&quot;, &quot;prettier&#x2F;prettier&quot;: [ &quot;error&quot;, &#x2F;&#x2F; 如果插件配置中修改了相关选项, &#x2F;&#x2F; 则必须在此添加相对应的自定义规则否则就会出现编辑器格式化后ESlint检查无法通过的情况。 &#123; printWidth: 200, singleQuote: false, bracketSpacing: true, jsxBracketSameLine: true, htmlWhitespaceSensitivity: &quot;ignore&quot; &#125; ] &#125;, parserOptions: &#123; parser: &quot;@typescript-eslint&#x2F;parser&quot; &#125;&#125;; ts在项目根目录新增.prettierrc.js 文件新增内容 1234567891011module.exports &#x3D; &#123; printWidth: 120, tabWidth: 4, singleQuote: true, semi: true, trailingComma: &#39;es5&#39;, bracketSpacing: true, jsxBracketSameLine: true, arrowParens: &#39;always&#39;, parser: &#39;typescript&#39;,&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"osharp框架学习","slug":"技术/2019-10-24-osharp框架学习 copy","date":"2019-10-24T09:00:00.000Z","updated":"2020-06-09T10:00:01.832Z","comments":true,"path":"2019/10/24/技术/2019-10-24-osharp框架学习 copy/","link":"","permalink":"https://ax-codes.github.io/2019/10/24/%E6%8A%80%E6%9C%AF/2019-10-24-osharp%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%20copy/","excerpt":"","text":"###osharp框架学习 包管理AspOsharpPackManager: AspNetCore 模块管理器 AspOsharpPackManager : OsharpPackManager, IAspUsePack","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"nodejs 使用 log4.js","slug":"技术/2019-09-24-nodejs 使用 log4.js","date":"2019-09-24T09:00:00.000Z","updated":"2020-06-09T10:00:01.830Z","comments":true,"path":"2019/09/24/技术/2019-09-24-nodejs 使用 log4.js/","link":"","permalink":"https://ax-codes.github.io/2019/09/24/%E6%8A%80%E6%9C%AF/2019-09-24-nodejs%20%E4%BD%BF%E7%94%A8%20log4.js/","excerpt":"","text":"前言nodejs 使用 log4.js log4.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const log4js = require('log4js'), path = require('path') log4js.configure(&#123; replaceConsole: true, appenders: &#123; stdout: &#123;//控制台输出 type: 'console' &#125;, trace: &#123; type: 'dateFile', filename: 'logs/tracelog/', pattern: 'trace-yyyy-MM-dd.log', alwaysIncludePattern: true &#125;, debug: &#123; type: 'dateFile', filename: 'logs/debuglog/', pattern: 'debug-yyyy-MM-dd.log', alwaysIncludePattern: true &#125;, info: &#123; type: 'dateFile', filename: 'logs/infolog/', pattern: 'info-yyyy-MM-dd.log', alwaysIncludePattern: true &#125;, warn: &#123; type: 'dateFile', filename: 'logs/warnlog/', pattern: 'warn-yyyy-MM-dd.log', alwaysIncludePattern: true &#125;, error: &#123; type: 'dateFile', filename: 'logs/errorlog/', pattern: 'error-yyyy-MM-dd.log', alwaysIncludePattern: true &#125;, fatal: &#123; type: 'dateFile', filename: 'logs/fatallog/', pattern: 'fatal-yyyy-MM-dd.log', alwaysIncludePattern: true &#125;, &#125;, categories: &#123; trace: &#123; appenders: ['stdout', 'trace'], level: 'trace' &#125;,//appenders:采用的appender,取appenders项,level:设置级别 debug: &#123; appenders: ['stdout', 'debug'], level: 'debug' &#125;, default: &#123; appenders: ['stdout', 'info'], level: 'info' &#125;, warn: &#123; appenders: ['stdout', 'warn'], level: 'warn' &#125;, error: &#123; appenders: ['stdout', 'error'], level: 'error' &#125;, fatal: &#123; appenders: ['stdout', 'fatal'], level: 'fatal' &#125;, &#125;&#125;) exports.getLogger = function (name) &#123;//name取categories项 return log4js.getLogger(name || 'info')&#125; exports.useLogger = function (app, logger) &#123;//用来与express结合 app.use(log4js.connectLogger(logger || log4js.getLogger('info'), &#123; format: '[:remote-addr :method :url :status :response-timems][:referrer HTTP/:http-version :user-agent]'//自定义输出格式 &#125;))&#125; 使用12345678910const log4js = require(\"./log4js\"),logger = log4js.getLogger(\"info\")logger.info(\"现在时间：\",new Date().toLocaleString())logger.trace(\"现在时间：\",new Date().toLocaleString())logger.debug(\"现在时间：\",new Date().toLocaleString())logger.info(\"现在时间：\",new Date().toLocaleString())logger.warn(\"现在时间：\",new Date().toLocaleString())logger.error(\"现在时间：\",new Date().toLocaleString())logger.fatal(\"现在时间：\",new Date().toLocaleString())","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nodejs 发送邮件","slug":"技术/2019-09-24-nodejs 发送邮件","date":"2019-09-24T09:00:00.000Z","updated":"2020-06-09T10:00:01.831Z","comments":true,"path":"2019/09/24/技术/2019-09-24-nodejs 发送邮件/","link":"","permalink":"https://ax-codes.github.io/2019/09/24/%E6%8A%80%E6%9C%AF/2019-09-24-nodejs%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/","excerpt":"","text":"前言nodejs 发送邮件 安装nodemailer1npm install nodemailer sendEmail.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var nodemailer = require(\"nodemailer\");var smtp = \"smtp.qq.com\";//使用服务var mailFrom = \"*@qq.com\";//发送者邮箱var mailPwd = \"*\";//smtp 秘钥,在qq邮箱账户里申请exports.emailTo = function(email,subject,text,html,callback) &#123; var transporter = nodemailer.createTransport(&#123; host: smtp, auth: &#123; user: mailFrom, pass: mailPwd //授权码,通过QQ获取 &#125; &#125;); var mailOptions = &#123; from: mailFrom, // 发送者 to: email, // 接受者,可以同时发送多个,以逗号隔开 subject: subject, // 标题 &#125;; if(text != undefined) &#123; mailOptions.text =text;// 文本 &#125; if(html != undefined) &#123; mailOptions.html =html;// html &#125; var result = &#123; httpCode: 200, message: '发送成功!', &#125; try &#123; transporter.sendMail(mailOptions, function (err, info) &#123; if (err) &#123; result.httpCode = 500; result.message = err; callback(result); return; &#125; callback(result); &#125;); &#125; catch (err) &#123; result.httpCode = 500; result.message = err; callback(result); &#125; &#125; 使用12345678var mailer = require('./sendEmail.js');var email = \"15692413487@163.com\";var subject = \"标题\"; //标题var text = `文本`;var html = \"\";mailer.emailTo(email, subject, text, html, function (data) &#123; return false;&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"node socket client 模板","slug":"技术/2019-09-23-node socket client 模板","date":"2019-09-23T09:00:00.000Z","updated":"2020-06-09T10:00:01.829Z","comments":true,"path":"2019/09/23/技术/2019-09-23-node socket client 模板/","link":"","permalink":"https://ax-codes.github.io/2019/09/23/%E6%8A%80%E6%9C%AF/2019-09-23-node%20socket%20client%20%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"前言node socket client 模板 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Requiresconst net = require('net');// Create socketconst port = 9011;const host = '127.0.0.1';const timeout = 1000;let retrying = false;// Functions to handle socket eventsfunction makeConnection () &#123; socket.connect(port, host);&#125;function connectEventHandler() &#123; console.log('connected'); retrying = false;&#125;function dataEventHandler() &#123; console.log('data');&#125;function endEventHandler() &#123; console.log('end');&#125;function timeoutEventHandler() &#123; console.log('timeout');&#125;function drainEventHandler() &#123; console.log('drain');&#125;function errorEventHandler() &#123; console.log('error');&#125;function closeEventHandler () &#123; console.log('close'); if (!retrying) &#123; retrying = true; console.log('Reconnecting...'); &#125; setTimeout(makeConnection, timeout);&#125;// Create socket and bind callbackslet socket = new net.Socket();socket.on('connect', connectEventHandler);socket.on('data', dataEventHandler);socket.on('end', endEventHandler);socket.on('timeout', timeoutEventHandler);socket.on('drain', drainEventHandler);socket.on('error', errorEventHandler);socket.on('close', closeEventHandler);// Connectconsole.log('Connecting to ' + host + ':' + port + '...');makeConnection();","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nodejs socket server 模板","slug":"技术/2019-09-23-nodejs socket server 模板","date":"2019-09-23T09:00:00.000Z","updated":"2020-06-09T10:00:01.830Z","comments":true,"path":"2019/09/23/技术/2019-09-23-nodejs socket server 模板/","link":"","permalink":"https://ax-codes.github.io/2019/09/23/%E6%8A%80%E6%9C%AF/2019-09-23-nodejs%20socket%20server%20%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"前言nodejs socket server 模板心跳监测 数据监测和推送 登录 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185let net = require('net');const log4js = require(\"./util/log4js\");const logger = log4js.getLogger(\"info\");var common = require('./common.js');const querystring = require('querystring');let moment = require('moment');moment.locale('zh-cn');let clients = [];//登录let reqLoginAlarmFail = 'ackLoginAlarm;result=fail;resDesc=&#123;_resDesc&#125;';let reqLoginAlarmSucc = 'ackLoginAlarm;result=succ;resDesc=null';let loginStatus = false//心跳let headbeatPack = `ackHeartBeat;reqId=&#123;_reqId&#125;;time(&#123;_time&#125;)`let headbeatPackInterval = 50000 //(/ms)let headbeatTimeout = 180 //(/s)let headbeatIntervalObj = null//告警监测let alertListenIntervalObj = nulllet alertListenInterval = 30000 //(/ms)//清除调度function clearAllInterval() &#123; logger.info(\"监测:心跳监测关闭\"); clearInterval(headbeatIntervalObj); logger.info(\"监测:监听告警数据关闭\"); clearInterval(alertListenIntervalObj);&#125;//登录处理function loginProcessFun(client, loginCount, data) &#123; if (data.user == 'yiy' &amp;&amp; data.key == 'qw#$@') &#123; logger.info(`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;登录成功`); common.writeData(client, reqLoginAlarmSucc); client.loginStatus = true; clients[`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;`] = client; return 0; &#125; logger.info(`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;登录失败`); common.writeData(client, reqLoginAlarmFail.replace('&#123;_resDesc&#125;','username-error or password-error')); loginCount += 1; if (loginCount &gt;= 3) &#123; client.destroy(); &#125; return loginCount;&#125;//处理心跳function processHeadbeatFun(client, data) &#123; client.headbeatReqId = data.reqId; client.headbeaPackTime = moment(); clients[`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;`] = client;&#125;//心跳调度处理function heartBeatInterval() &#123; //心跳处理 logger.info(\"监测:心跳监测启动\"); headbeatIntervalObj = setInterval(function () &#123; for (const key in clients) &#123; let client = clients[key]; if (!client.loginStatus || client.headbeatReqId == 0) &#123; continue; &#125; let end_time = moment().subtract(headbeatTimeout, \"seconds\"); let pack = `$&#123;headbeatPack.replace(\"&#123;_reqId&#125;\",client.headbeatReqId).replace(\"&#123;_time&#125;\",end_time.format('YYYY-MM-DD HH:mm:ss'))&#125;`; logger.info(`发送心跳包:$&#123;pack&#125;`); common.writeData(client, pack); if (client.headbeaPackTime &lt; end_time) &#123; clearAllInterval(); client.destroy(); &#125; &#125; &#125;, headbeatPackInterval);&#125;//告警调度处理function listenAlertData() &#123; //心跳处理 logger.info(\"监测:监听告警数据开启\"); alertListenIntervalObj = setInterval(async function () &#123; &#125;, alertListenInterval);&#125;//创建serverlet server = net.createServer(function (client) &#123; logger.info(' Client connection:'); logger.info(' local= %s:%s', client.localAddress, client.localPort); logger.info(' remote= %s:%s', client.remoteAddress, client.remotePort); client.setTimeout(5000); client.setEncoding('utf8'); client.loginStatus = false; client.headbeatReqId = 0; client.headbeaPackTime = moment(); clients[`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;`] = client; //登录次数 let loginCount = 0; client.on('data', function (data) &#123; if (data === null || data.length &lt;= 0) &#123; return; &#125; logger.info('接收到数据:', data); //接收到消息 更新心跳时间 data = `reqType=$&#123;data&#125;` data = querystring.parse(data, \";\"); if (data === null) &#123; return; &#125; switch (data.reqType) &#123; case \"reqLoginAlarm\": loginCount = loginProcessFun(client, loginCount, data); break; case \"reqHeartBeat\": processHeadbeatFun(client, data); break; case \"closeConnAlarm\": client.destroy(); break; default: break; &#125; &#125;); client.on('end', function () &#123; logger.info('Client disconnected'); server.getConnections(function (err, count) &#123; logger.info('Remaining Connection:' + count); &#125;); &#125;); client.on('close', function () &#123; delete clients[`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;`]; logger.info(`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;断开连接`); &#125;); client.on('error', function (err) &#123; delete clients[`$&#123;client.remoteAddress&#125;:$&#123;client.remotePort&#125;`]; logger.info('Socket Error:', JSON.stringify(err)); &#125;); client.on('timeout', function () &#123; // logger.info('Socket Timed Out'); &#125;);&#125;);//开始监听server.listen(8011, function () &#123; logger.info('Server listening: ' + JSON.stringify(server.address())); //监测任务 heartBeatInterval(); listenAlertData(); server.on('close', function () &#123; logger.info('Server Terminated'); &#125;); server.on('error', function (err) &#123; logger.info('Server Error:', JSON.stringify(err)); &#125;);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"windows 运行程序 报确少wpcap.dll packet.dll等动态库的问题","slug":"技术/2019-08-19-windows 运行程序 报确少wpcap.dll packet.dll等动态库的问题","date":"2019-08-19T09:00:00.000Z","updated":"2020-06-09T10:00:01.829Z","comments":true,"path":"2019/08/19/技术/2019-08-19-windows 运行程序 报确少wpcap.dll packet.dll等动态库的问题/","link":"","permalink":"https://ax-codes.github.io/2019/08/19/%E6%8A%80%E6%9C%AF/2019-08-19-windows%20%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%20%E6%8A%A5%E7%A1%AE%E5%B0%91wpcap.dll%20packet.dll%E7%AD%89%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言windows 运行程序 报确少wpcap.dll packet.dll等动态库的问题 解决方法下载winpcap,然后安装即可解决问题","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"ABP项目使用mysql数据库","slug":"技术/2019-08-01-ABP项目使用mysql数据库","date":"2019-08-01T09:00:00.000Z","updated":"2020-06-09T10:00:01.820Z","comments":true,"path":"2019/08/01/技术/2019-08-01-ABP项目使用mysql数据库/","link":"","permalink":"https://ax-codes.github.io/2019/08/01/%E6%8A%80%E6%9C%AF/2019-08-01-ABP%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"前言默认从ABP官网生成的模板都是使用的sql server数据库,我们可以迁移到mysql项目是用的APB core 的 webapi项目 删除EntityFrameworkCore里的sqlserver的ef模块替换成mysql的模块 修改DbContextConfigurer文件(上下文对象) 修改默认链接字符串 删除模板默认的迁移文件(Migrations里的文件)因为默认模板Migrations里的文件都是针对sql server的 创建空的数据库,并设置数据库字符集,不然迁移完插入中文会报错 初始化ABP mysql迁移文件选择EntityFramework作为启动项目,然后打开VS的包管理控制台,并在包管理控制台中选择 .EntityFramework 项目作为默认项目执行命令1Add-Migration \"init\" 开始迁移执行命令1Update-Database -Verbose 注意:执行这步操作的时候可能会报mysql字符长度不够的问题,原因可能是我们的mysql版本问题,我们需要使用5.7及以上的版本再执行”Update-Database -Verbose”就不会有问题 启动server 注意1: ABP 使用 mysql需要使用5.7或者5.7以上的版本,不然迁移会有问题(亲测5.7有效,所以推荐5.7)2: 记得先创建空的数据库,并且设置字符集为utf-8,再迁移,不然插入中文会报错,先迁移再设置数据库字符集会不生效哦","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"nodejs 的orm框架sequelize","slug":"技术/2019-05-20-nodejs 的orm框架sequelize copy","date":"2019-05-20T09:00:00.000Z","updated":"2020-06-09T10:00:01.819Z","comments":true,"path":"2019/05/20/技术/2019-05-20-nodejs 的orm框架sequelize copy/","link":"","permalink":"https://ax-codes.github.io/2019/05/20/%E6%8A%80%E6%9C%AF/2019-05-20-nodejs%20%E7%9A%84orm%E6%A1%86%E6%9E%B6sequelize%20copy/","excerpt":"","text":"前言github:https://github.com/sequelize中文api:https://github.com/demopark/sequelize-docs-Zh-CNexpress-example:https://github.com/sequelize/express-examplesequelize-cli:https://github.com/sequelize/clisequelize-auto github:https://github.com/sequelize/sequelize-auto 安装安装sequelize库12345678$ npm install --save sequelize # This will install v5# And one of the following:$ npm install --save pg pg-hstore # Postgres$ npm install --save mysql2$ npm install --save mariadb$ npm install --save sqlite3$ npm install --save tedious # Microsoft SQL Server 安装sequelize脚手架Globally 安装123456Install CLI globally with$ npm install -g sequelize-cliNow you can run CLI using following command anywhere$ sequelize Locally123456Install CLI locally to your node_modules folder with$ npm install --save sequelize-cliYou should be able to run CLI with$ node_modules&#x2F;.bin&#x2F;sequelize 123456789101112131415161718192021222324命令： db：migrate运行挂起的迁移 db：migrate：schema：timestamps：添加更新迁移表以具有时间戳 db：migrate：status列出所有迁移的状态 db：migrate：undo恢复迁移 db：migrate：undo：all恢复所有迁移 db：seed运行指定的播种器 db：seed：undo删除数据库中的数据 db：seed：all运行每个播种机 db：seed：undo：all从数据库中删除数据 db：create创建由配置指定的数据库 db：drop由配置指定的Drop数据库 init初始化项目 init：config初始化配置 init：迁移初始化迁移 init：models初始化模型 init：播种机初始化播种机 migration：generate生成新的迁移文件[aliases：migration：create] model：generate生成模型及其迁移[aliases：model：create] seed：generate生成一个新的种子文件[别名：seed：create]选项： --version显示版本号[boolean] --help显示帮助[boolean] 安装sequelize-auto1npm install -g sequelize-auto 在使用sequelize-auto之前,您需要全局安装正确数据库组件123456789101112131415Example for MySQL&#x2F;MariaDBnpm install -g mysqlExample for Postgresnpm install -g pg pg-hstoreExample for Sqlite3npm install -g sqliteExample for MSSQLnpm install -g mssql 123456789101112131415161718[node] sequelize-auto -h &lt;host&gt; -d &lt;database&gt; -u &lt;user&gt; -x [password] -p [port] --dialect [dialect] -c [&#x2F; path &#x2F; to &#x2F; config] -o [ &#x2F; path &#x2F; to &#x2F; models] -t [tableName] -C选项： -h， - 数据库的主机IP &#x2F;主机名。 [需要] -d， - 数据库数据库名称。 [需要] -u， - user数据库的用户名。 -x， - pass数据库的密码。 -p， - port数据库的端口号。 -c， - config Sequelize的构造函数“options”标志对象的JSON文件，如下所示：https：&#x2F;&#x2F;sequelize.readthedocs.org&#x2F;en&#x2F;latest&#x2F;api&#x2F;sequelize&#x2F; -o， - output用于放置模型的目录。 -e， - dialect你正在使用的方言&#x2F;引擎：postgres，mysql，sqlite -a， - 附加到包含模型定义（适用于所有表）的json文件的路径，这些模型定义将在模型的配置参数中定义。有关更多信息：https：&#x2F;&#x2F;sequelize.readthedocs.org&#x2F;en&#x2F;latest&#x2F;docs&#x2F;models-definition&#x2F;#configuration -t， - tables要导入的表的逗号分隔名称 -T， - skip-tables要跳过的以逗号分隔的表名 -C，--camel使用驼峰案例命名模型和字段 -n， - no-write防止将模型写入磁盘。 -s，--schema用于检索表的数据库模式 -z， - anpescript输出模型作为带有定义文件的打字稿。 mysql 根据db 生成models例子1sequelize-auto -h localhost -d node_test -u root -x 123456 -p 3306 -o /Users/guoxing/test/express-example-sequelize/express-example/db/models 程序api1234567891011121314151617181920212223var SequelizeAuto = require('sequelize-auto')var auto = new SequelizeAuto('database', 'user', 'pass', &#123; host: 'localhost', dialect: 'mysql'|'mariadb'|'sqlite'|'postgres'|'mssql',//默认选择一个就行 directory: false, // prevents the program from writing to disk//是否生成文件 port: 'port', output:'./models',//生成的model 路径 additional: &#123; timestamps: false //... &#125;, tables: ['table1', 'table2', 'table3'] //注释表示生成全部表 //...&#125;)auto.run(function (err) &#123; if (err) throw err; console.log(auto.tables); // table list console.log(auto.foreignKeys); // foreign key list&#125;); 在项目里加入sequelize在项目根目录里1touch .sequelizerc 修改.sequelizerc12345678const path &#x3D; require(&#39;path&#39;);module.exports &#x3D; &#123; &#39;config&#39;: path.resolve(&#39;config&#39;, &#39;db.js&#39;), &#39;models-path&#39;: path.resolve(&#39;db&#39;, &#39;models&#39;), &#39;seeders-path&#39;: path.resolve(&#39;db&#39;, &#39;seeders&#39;), &#39;migrations-path&#39;: path.resolve(&#39;db&#39;, &#39;migrations&#39;)&#125; 初始化sequelize项目,会根据.sequelizerc的路径生成项目结构1sequelize init 修改db/db.js123456789101112131415161718192021module.exports = &#123; development: &#123; username: 'root', password: 'root', database: 'test_gx', host: '127.0.0.1', dialect: 'mysql' &#125;, test: &#123; dialect: \"sqlite\", storage: \":memory:\" &#125;, production: &#123; username: 'root', password: '123456', database: 'node_test', host: '127.0.0.1', dialect: 'mysql' // use_env_variable: 'DATABASE_URL' &#125;&#125;; 创建自己的一些工具1234cd dbmkdir toolstouch dbToModels.jstouch modelsToDb.js dbToModels.js内容123456789101112131415161718192021var config &#x3D; require(&#39;..&#x2F;..&#x2F;config&#x2F;db&#39;);var SequelizeAuto &#x3D; require(&#39;sequelize-auto&#39;)var auto &#x3D; new SequelizeAuto(config.development.database,config.development.username,config.development.password, &#123; host: config.development.host, c: &#39;mysql&#39;, port: &#39;3306&#39;, directory: &#39;..&#x2F;models&#39;, additional: &#123; timestamps: false &#x2F;&#x2F;... &#125; &#x2F;&#x2F;...&#125;)auto.run(function (err) &#123; if (err) throw err; console.log(auto.tables); &#x2F;&#x2F; table list console.log(auto.foreignKeys); &#x2F;&#x2F; foreign key list &#125;); modelsToDb.js内容1234var db &#x3D; require(&#39;..&#x2F;models&#x2F;index&#39;);&#x2F;&#x2F;model 导入到 dbdb.sequelize.sync(&#123;force:true&#125;); 执行dbToModels.js生成models1node dbToModels.j 下面就可以在你需要操作数据库的地方使用了123var models = require('./db/models');var list = models.user.findAll(); 总结sequelize是一种基于node的orm框架,可以映射对象和数据表的关系简化操作数据的方法,因为sequelize帮我们封装好了操作数据库的接口,所以当我们需要切换不同类型的数据库的时候我们业务层的逻辑也是不用修改的,只需要在配置上下文的时候配置其他的数据库就行,并且sequelize还提供了其他的功能,比如迁移和种子,和校验等功能,这里没有过多介绍,详情可以看sequelize 的github","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nodeJS项目gitignore文件参考","slug":"技术/2019-05-14-nodejs 项目gitignore文件参考","date":"2019-05-14T09:00:00.000Z","updated":"2020-06-09T10:00:01.818Z","comments":true,"path":"2019/05/14/技术/2019-05-14-nodejs 项目gitignore文件参考/","link":"","permalink":"https://ax-codes.github.io/2019/05/14/%E6%8A%80%E6%9C%AF/2019-05-14-nodejs%20%E9%A1%B9%E7%9B%AEgitignore%E6%96%87%E4%BB%B6%E5%8F%82%E8%80%83/","excerpt":"","text":"前言nodeJS项目gitignore文件参考 .gitignore12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# Logslogs*.lognpm-debug.log*yarn-debug.log*yarn-error.log* # Runtime datapids*.pid*.seed*.pid.lock # Directory for instrumented libs generated by jscoverage/JSCoverlib-cov # Coverage directory used by tools like istanbulcoverage # nyc test coverage.nyc_output # Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt # Bower dependency directory (https://bower.io/)bower_components # node-waf configuration.lock-wscript # Compiled binary addons (https://nodejs.org/api/addons.html)build/Release # Dependency directoriesnode_modules/jspm_packages/ # Typescript v1 declaration filestypings/ # Optional npm cache directory.npm # Optional eslint cache.eslintcache # Optional REPL history.node_repl_history # Output of 'npm pack'*.tgz # Yarn Integrity file.yarn-integrity # dotenv environment variables file.env","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nodejs 使用session demo","slug":"技术/2019-04-10-nodejs 使用session demo","date":"2019-04-10T03:00:00.000Z","updated":"2020-06-09T10:00:01.817Z","comments":true,"path":"2019/04/10/技术/2019-04-10-nodejs 使用session demo/","link":"","permalink":"https://ax-codes.github.io/2019/04/10/%E6%8A%80%E6%9C%AF/2019-04-10-nodejs%20%E4%BD%BF%E7%94%A8session%20demo/","excerpt":"","text":"前言session是临时存储在服务器内存里的数据,常用于记录用户登陆标识,但是server重启的话,session数据回丢失,所以使用redis比较好一点 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var app=require('express')();var request=require('request');var querystring=require('querystring');var crypto=require('crypto');var bodyParser=require('body-parser');var cookieParser=require('cookie-parser');var session = require('express-session');var FileStore = require('session-file-store')(session);var identityKey = 'skey'; app.use(session(&#123; name: identityKey, secret: 'chyingp', // 用来对session id相关的cookie进行签名 store: new FileStore(), // 本地存储session（文本文件，也可以选择其他store，比如redis的） saveUninitialized: false, // 是否自动保存未初始化的会话，建议false resave: false, // 是否每次都重新保存会话，建议false cookie: &#123; maxAge: 10 * 1000 // 有效期，单位是毫秒 &#125;&#125;));//使用JSON解析工具app.use(bodyParser.urlencoded(&#123;extended: false&#125;));app.use(bodyParser.json());//使用cookieapp.use(cookieParser());//开启监听var server=app.listen(8889, function()&#123; var host=server.address().address; var port=server.address().port; console.log('address is http://%s:%s', host, port);&#125;);app.get('/create_session', function(req, res, next)&#123; req.session.loginUser = req.query.name; res.json(&#123;ret_code: 0, ret_msg: req.query.name+'创建成功'&#125;); &#125;);app.get('/get_session', function(req, res, next)&#123; res.json(&#123;ret_code: 0, ret_msg: req.session.loginUser&#125;); &#125;);app.get('/clear_session', function(req, res, next)&#123; req.session.loginUser = null; res.json(&#123;ret_code: 0, ret_msg: '清除成功'&#125;); &#125;); 测试123http:&#x2F;&#x2F;localhost:8889&#x2F;create_session?name&#x3D;axinghttp:&#x2F;&#x2F;localhost:8889&#x2F;get_sessionhttp:&#x2F;&#x2F;localhost:8889&#x2F;clear_session","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"linux安装nodejs最简单的方法","slug":"技术/2019-04-09-linux安装nodejs最简单的方法","date":"2019-04-09T03:00:00.000Z","updated":"2020-06-09T10:00:01.811Z","comments":true,"path":"2019/04/09/技术/2019-04-09-linux安装nodejs最简单的方法/","link":"","permalink":"https://ax-codes.github.io/2019/04/09/%E6%8A%80%E6%9C%AF/2019-04-09-linux%E5%AE%89%E8%A3%85nodejs%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言nodejs下载地址:英文网址:https://nodejs.org/en/download/中文网址:http://nodejs.cn/download/ 安装下载http://nodejs.cn/download/ 解压tar -xvf node-v6.10.0-linux-x64.tar.xzmv node-v6.10.0-linux-x64 nodejs 创建全局软连接ln -s /app/software/nodejs/bin/npm /usr/local/bin/npmln -s /app/software/nodejs/bin/node /usr/local/bin/nodeln -s /root/nodejs/bin/pm2 /usr/local/bin/pm2 测试1node -v 如果显示对应的版本,则说明成功","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nodejs 操作mysql demo","slug":"技术/2019-04-08-nodejs 操作mysql demo","date":"2019-04-08T03:00:00.000Z","updated":"2020-06-09T10:00:01.811Z","comments":true,"path":"2019/04/08/技术/2019-04-08-nodejs 操作mysql demo/","link":"","permalink":"https://ax-codes.github.io/2019/04/08/%E6%8A%80%E6%9C%AF/2019-04-08-nodejs%20%E6%93%8D%E4%BD%9Cmysql%20demo/","excerpt":"","text":"前言需要先安装mysql模块:npm install mysql -g 代码没有链接池12345678910111213141516171819var mysql = require('mysql');var connection = mysql.createConnection(&#123;host: '192.168.199.222',user: 'root',password: 'root',database: 'db'&#125;);connection.connect();connection.query('select * from test where propertyName=\\'viewingAnalysisMonitor\\'', function (error, results, fields) &#123;if (error) throw error;//results:数据集//results[0]:第一行数据console.log(results[0].propertyValue);&#125;);connection.end(); 连接池1234567891011121314151617181920212223242526272829303132var mysql = require('mysql');const pool = mysql.createPool(&#123; host: '127.0.0.1', user: 'root', password: 'root', database: 'test'&#125;);module.exports.query = function (sql, values) &#123; // 返回一个 Promise return new Promise((resolve, reject) =&gt; &#123; pool.getConnection(function (err, connection) &#123; if (err) &#123; reject(err) &#125; else &#123; connection.query(sql, values, (err, rows) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(rows) &#125; // 结束会话 connection.release() &#125;) &#125; &#125;) &#125;)&#125;let result = await Ut.query('select * from test where propertyName=\\'viewingAnalysisMonitor\\'');","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nodejs 操作mongodb demo","slug":"技术/2019-04-08-nodejs 操作mongodb demo","date":"2019-04-08T03:00:00.000Z","updated":"2020-06-09T10:00:01.810Z","comments":true,"path":"2019/04/08/技术/2019-04-08-nodejs 操作mongodb demo/","link":"","permalink":"https://ax-codes.github.io/2019/04/08/%E6%8A%80%E6%9C%AF/2019-04-08-nodejs%20%E6%93%8D%E4%BD%9Cmongodb%20demo/","excerpt":"","text":"前言需要先安装mysql模块:12npm install mongodb -gnpm install q -g 代码dbHelper.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158var Q=require('q');var MongoClient = require('mongodb').MongoClient;/** * 创建数据库服务器并开发名为databaseName的数据库 * @param host ip * @param port 端口 * @param databaseName * @return 打开失败返回-1 ，成功返回database */function openDatabase()&#123; //创建数据库所在的服务器 var deferred = Q.defer(); var url = \"mongodb://root:123456@192.168.99.100:27017/admin\"; MongoClient.connect(url, &#123; useNewUrlParser: true &#125;, function(err, db) &#123; if (err) &#123; console.log('连接数据库失败'); deferred.reject(err); &#125; else &#123; console.log('连接数据库成功'); var db = db.db(\"test\"); deferred.resolve([db,'stbinfo_test']); &#125; &#125;); return deferred.promise;&#125;/** * 连接数据集合 * @param db 数据库 * @param collectionName 数据集合名称 * @return 成功返回collection，失败返回-1 */function openCollection(db,collectionName)&#123; var deferred = Q.defer(); db.collection(collectionName,&#123;safe:true&#125;,function(errcollection,collection)&#123; if(!errcollection)&#123; console.log('连接数据集合成功'); deferred.resolve(collection); &#125;else&#123; console.log('连接数集合失败'); deferred.reject(errcollection); &#125; &#125;); return deferred.promise;&#125;/** * 插入数据 * @param collection * @param tmp 要插入的数据 * @return 成功返回collection，失败返回-1 */function insertCollection(collection,tmp)&#123; //var tmp = &#123;username:'hello',password:1&#125;; collection.insert(tmp,&#123;safe:true&#125;,function(err, result)&#123; if(err)&#123; console.log('传入数据集合失败'+tmp); return -1; &#125;else &#123; console.log('插入数据集合成功'+result); &#125; &#125;); return collection;&#125;/** * 查询数据集合 没有条件 * @param collection * @return 成功返回查询到的数据集合内容，失败返回-1 */function findCollectionNoCondition(collection)&#123; var deferred = Q.defer(); collection.find().toArray(function(errfind,cols)&#123; if(!errfind)&#123; console.log('查询数据集合成功:'+cols); deferred.resolve(&#123;\"collection\":collection,\"result\":cols&#125;); &#125;else &#123; console.log('查询数据集合失败'); deferred.reject(errfind); &#125; &#125;); return deferred.promise;&#125;/** * 查询数据集合 有条件 * @param collection * @return 成功返回查询到的数据集合内容，失败返回-1 */function findCollectionHasCondition(collection,tmp)&#123; var deferred = Q.defer(); collection.find(tmp).toArray(function(errfind,cols)&#123; if(!errfind)&#123; // console.log('查询数据集合成功'+JSON.stringify(cols)); var result = cols; console.log(result); deferred.resolve(&#123;\"collection\":collection,\"result\":cols&#125;); &#125;else &#123; console.log('查询数据集合失败'); deferred.reject(errfind); &#125; &#125;); return deferred.promise;&#125;/** * 删除数据集合 * @param collection * @param tmp * @return 成功返回数据集合，失败返回-1 */function removeCollection(collection,tmp)&#123; //var tmp = &#123;username:'hello',password:1&#125;; collection.remove(tmp,&#123;safe:true&#125;,function(err, count)&#123; if(err)&#123; console.log('删除数据集合失败'+tmp); return -1; &#125;else &#123; console.log('删除数据集合成功'+count); return collection; &#125; &#125;);&#125;/** * 修改数据集合 * @param collection * @param whereStr * @param updateStr * @return 成功返回数据集合，失败返回-1 */function updateManyCollection(collection,whereStr,updateStr)&#123; collection.updateMany(whereStr, updateStr, function(err, res) &#123; if(err)&#123; console.log((new Date().getTime())+'更新数据集合失败'+err); return -1; &#125;else &#123; console.log((new Date().getTime())+'更新数据集合成功-'+':'+whereStr+res); return collection; &#125; &#125;);&#125;module.exports = &#123; openDatabase, openCollection, insertCollection, findCollectionNoCondition, findCollectionHasCondition, removeCollection, updateManyCollection&#125; main.js1234567891011121314151617var dbHelper = require('./dbHelper');dbHelper.openDatabase() .then(function (data) &#123; return dbHelper.openCollection(data[0], data[1]) &#125;) .then(function (collection) &#123; return dbHelper.findCollectionHasCondition(collection,&#123;'id':'-1'&#125;); &#125;).then(function (data) &#123; var result = data.result; return data.collection; &#125;) .done(function (data) &#123; console.log('promise执行成功'); &#125;, function (err) &#123; console.log(\"promise执行失败:\" + err); &#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"开源压力测试命令行工具SuperBenchmarker","slug":"技术/2019-02-16-开源压力测试命令行工具SuperBenchmarker","date":"2019-02-16T03:00:00.000Z","updated":"2020-06-09T10:00:01.774Z","comments":true,"path":"2019/02/16/技术/2019-02-16-开源压力测试命令行工具SuperBenchmarker/","link":"","permalink":"https://ax-codes.github.io/2019/02/16/%E6%8A%80%E6%9C%AF/2019-02-16-%E5%BC%80%E6%BA%90%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7SuperBenchmarker/","excerpt":"","text":"前言SuperBenchmarker 是ㄧ个开源的类似于Apache ab的压力测试命令行工具.可以在 .NET 4.52+ 或者 .NET Core 2.0+ 平台上运行.可支持Get、Post、Put、Delete这些调用方式,调用时能指定Concurrent user、Request数、Header template…等.可以从Github、Chocolatey这两种方式获得.Github用户可在download目录内取得编译好的程序主文件 相关链接免费网站与REST服务压力测试工具:http://blog.kkbruce.net/2013/09/free-website-rest-service-stress-test-tool.html?m=1github:https://github.com/aliostad/SuperBenchmarker 安装Installation - WindowsEasiest way to install sb is to use chocolatey. Once you have installed chocolatey, simply run: cinst SuperBenchmarkerand to update your version of sb: cup SuperBenchmarkerYou can also download the lastest version from the Download folder of this github repository. This is a single exe with all dependencies IL-merged. Installation - MacCurrently, until brew is sorted out, you need to build from the source: git clone https://github.com/aliostad/SuperBenchmarkercd SuperBenchmarker./build.sh 参数 一些比较重要的参数-u 可用来指定要压测的网站或是API -n 可用来指定要压的Request数量 -c 可用来指定Concurrent Request数量 -m 可用来指定要使用的HTTP Method -h 可用来指定要显示HTTP Header -q 可用来指定要显示Cookie 所以我们要发送1000个Request去测试腾讯网的话 可以输入命令 sb -u https://www.qq.com -n 1000 要发送1000个Request, 且同时间可能有10个Concurrent Request去测试腾讯网的话 可以输入命令 sb -u https://www.qq.com -n 1000 -c 10 要在发送命令后显示Header的话, 可带入参数-h sb -u https://www.qq.com -n 1000 -c 10 -h 要在发送命令后显示Cookie, 可带入参数-q sb -u https://www.qq.com -n 1000 -c 10 -h -q 运行如果没有sb命令则在dotnet的环境下运行SuperBenchmarker.dll,并在末尾加上对应的参数:例如:1dotnet ./src/SuperBenchmarker/bin/Debug/netcoreapp2.0/SuperBenchmarker.dll -u https://google.com -N 10 效果 这边有简易的测试统计,可以看出每秒可处理多少的Request、最大的处理时间、最小的处理时间、平均的处理时间、以及压了这么多次的API,依比例分大概在哪个范围 这是网页来展现测试统计结果,每次跑完这个网页会自动在浏览器里弹出 这些数值有助我们评估网站或是API的性能与负载量. 除了看这些数据外,这边建议也可以在压的时候看一下Server上的CPU Loading,磁盘IO,以及内存的使用状况,甚至可以用性能监视器拉些数值来看.","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"Element tree组件右键菜单demo","slug":"技术/2019-01-28-Element tree组件右键菜单demo","date":"2019-01-28T03:00:00.000Z","updated":"2020-06-09T10:00:01.772Z","comments":true,"path":"2019/01/28/技术/2019-01-28-Element tree组件右键菜单demo/","link":"","permalink":"https://ax-codes.github.io/2019/01/28/%E6%8A%80%E6%9C%AF/2019-01-28-Element%20tree%E7%BB%84%E4%BB%B6%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95demo/","excerpt":"","text":"前言Element tree组件右键增删查改 引用样式1234&lt;!-- import CSS --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt;&lt;!-- 引入 VContextmenu 组件样式 --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/v-contextmenu/dist/index.css\"&gt; 引用js123456&lt;!-- import Vue before Element --&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- import JavaScript --&gt;&lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt;&lt;!-- 引入 VContextmenu 组件 --&gt;&lt;script src=\"https://unpkg.com/v-contextmenu/dist/index.js\"&gt;&lt;/script&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html class=\"box\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- import CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- 引入 VContextmenu 组件样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/v-contextmenu/dist/index.css\"&gt;&lt;/head&gt;&lt;body class=\"box\"&gt; &lt;div id=\"app\"&gt; &lt;el-container style=\"width:500px\"&gt; &lt;el-header&gt; &lt;el-input placeholder=\"输入关键字进行过滤\" v-model=\"filterText\"&gt; &lt;/el-input&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;el-tree class=\"filter-tree\" :data=\"data2\" :props=\"defaultProps\" @node-click=\"treeNodeClick\" default-expand-all :filter-node-method=\"filterNode\" ref=\"tree2\"&gt; &lt;span class=\"custom-tree-node\" slot-scope=\"&#123; node, data &#125;\"&gt; &lt;span class=\"el-tree-node__label\" v-contextmenu:contextmenu&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;/el-tree&gt; &lt;template&gt; &lt;v-contextmenu ref=\"contextmenu\"&gt; &lt;v-contextmenu-item @click=\"handleClick\"&gt;新增节点&lt;/v-contextmenu-item&gt; &lt;v-contextmenu-item @click=\"handleClick\"&gt;修改节点&lt;/v-contextmenu-item&gt; &lt;v-contextmenu-item @click=\"handleClick\"&gt;删除节点&lt;/v-contextmenu-item&gt; &lt;/v-contextmenu&gt; &lt;/template&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- import Vue before Element --&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- import JavaScript --&gt;&lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt;&lt;!-- 引入 VContextmenu 组件 --&gt;&lt;script src=\"https://unpkg.com/v-contextmenu/dist/index.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: '#app', data() &#123; return &#123; filterText: '', data2: [&#123; id: 1, label: '一级 1', children: [&#123; id: 4, label: '二级 1-1', children: [&#123; id: 9, label: '三级 1-1-1' &#125;, &#123; id: 10, label: '三级 1-1-2' &#125;] &#125;] &#125;, &#123; id: 2, label: '一级 2', children: [&#123; id: 5, label: '二级 2-1' &#125;, &#123; id: 6, label: '二级 2-2' &#125;] &#125;, &#123; id: 3, label: '一级 3', children: [&#123; id: 7, label: '二级 3-1' &#125;, &#123; id: 8, label: '二级 3-2' &#125;] &#125;], defaultProps: &#123; children: 'children', label: 'label' &#125; &#125;; &#125;, watch: &#123; filterText(val) &#123; this.$refs.tree2.filter(val); &#125; &#125;, props: &#123; theme: String, &#125;, methods: &#123; treeNodeClick() &#123; this.$refs.contextmenu.hide(); &#125;, handleClick(vm, event) &#123; alert(`「$&#123;vm.$slots.default[0].text&#125;」被点击啦！`) &#125;, filterNode(value, data) &#123; if (!value) return true; return data.label.indexOf(value) !== -1; &#125; &#125; &#125;)&lt;/script&gt;&lt;style scoped&gt; .box &#123; height: 100%; &#125;&lt;/style&gt;&lt;/html&gt; 效果","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"右键菜单组件v-contextmenu","slug":"技术/2019-01-26-右键菜单组件v-contextmenu","date":"2019-01-26T03:00:00.000Z","updated":"2020-06-09T10:00:01.765Z","comments":true,"path":"2019/01/26/技术/2019-01-26-右键菜单组件v-contextmenu/","link":"","permalink":"https://ax-codes.github.io/2019/01/26/%E6%8A%80%E6%9C%AF/2019-01-26-%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6v-contextmenu/","excerpt":"","text":"前言右键菜单组件:v-contextmenugithub地址:https://github.com/snokier/v-contextmenu文档说明:https://github.com/snokier/v-contextmenu/blob/master/docs/usage.md#vcontextmenu在线例子:https://snokier.github.io/v-contextmenu/例子代码:https://github.com/snokier/v-contextmenu/tree/master/examples在线事例:https://github.com/snokier/v-contextmenu/blob/master/docs/images/example.gif cdn引入12345678&lt;!-- 引入 Vue --&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 引入 VContextmenu 组件 --&gt;&lt;script src=\"https://unpkg.com/v-contextmenu/dist/index.js\"&gt;&lt;/script&gt;&lt;!-- 引入 VContextmenu 组件样式 --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/v-contextmenu/dist/index.css\"&gt; npm安装1$ npm i -S v-contextmenu # yarn add v-contextmenu 概览 测试模版123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- import CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;!-- 引入 VContextmenu 组件样式 --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/v-contextmenu/dist/index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;template&gt; &lt;v-contextmenu ref=\"contextmenu\"&gt; &lt;v-contextmenu-item @click=\"handleClick\"&gt;菜单1&lt;/v-contextmenu-item&gt; &lt;v-contextmenu-item @click=\"handleClick\"&gt;菜单2&lt;/v-contextmenu-item&gt; &lt;v-contextmenu-item @click=\"handleClick\"&gt;菜单3&lt;/v-contextmenu-item&gt; &lt;/v-contextmenu&gt; &lt;div v-contextmenu:contextmenu&gt;右键点击此区域&lt;/div&gt; &lt;/template&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- import Vue before Element --&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- import JavaScript --&gt;&lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt;&lt;!-- 引入 VContextmenu 组件 --&gt;&lt;script src=\"https://unpkg.com/v-contextmenu/dist/index.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: '#app', methods: &#123; handleClick(vm, event) &#123; alert(`「$&#123;vm.$slots.default[0].text&#125;」被点击啦！`) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(九)-插件","slug":"技术/2019-01-23-Vue学习篇(九)-插件","date":"2019-01-23T03:00:00.000Z","updated":"2020-06-09T10:00:01.764Z","comments":true,"path":"2019/01/23/技术/2019-01-23-Vue学习篇(九)-插件/","link":"","permalink":"https://ax-codes.github.io/2019/01/23/%E6%8A%80%E6%9C%AF/2019-01-23-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B9%9D)-%E6%8F%92%E4%BB%B6/","excerpt":"","text":"前言一个Vue插件可以是一堆Vue组件的集合(插件干的事就是把内部的组件帮你倒入到vue全局下,Vue 的组件是模板和 UI 逻辑的结合),也可以是用来扩展Vue功能的,比如 Vuex, Vue-Router.你也可以写一个插件,在Vue原型上扩展方法,要实现这个需求绝对没法写成组件Vue定义组件的关键字是:use 定义插件1234567891011121314/*注册插件需要使用的组件*/import testComponent1 from '@/components/Test1.vue'import testComponent2 from '@/components/Test2.vue'import testComponent3 from '@/components/Test3.vue'//导出插件export default &#123; //每个插件都必须要有install这个方法,在use(安装插件的时候调用) //我们可以在这里注册多个全局组件,并可以根据option设置插件里所以组件的值,或许在这注册全局函数,prototype,监听路由(用在处理权限,登陆超时) //官方说明：\"用于安装 Vue.js 插件.如果插件是一个对象,必须提供 install 方法.如果插件是一个函数,它会被作为 install 方法.install 方法调用时,会将 Vue 作为参数传入.当 install 方法被同一个插件多次调用,插件将只会被安装一次.“ install (_Vue, options) &#123; &#125;&#125; 注册插件1Vue.use('插件名称',options); 当调用use的时候会默认调用插件的install方法,axios不需要调用是因为axios不是插件 Vue插件的编写方法的四类123456789101112131415161718192021222324252627export default &#123; //Vue对象 use的时候传入的option数据 install(Vue, options) &#123; Vue.myGlobalMethod = function () &#123; // 1. 添加全局方法或属性,如: vue-custom-element // 逻辑... &#125; Vue.directive('my-directive', &#123; // 2. 添加全局资源：指令/过滤器/过渡等,如 vue-touch bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) Vue.mixin(&#123; created: function () &#123; // 3. 通过全局 mixin方法添加一些组件选项,如: vuex // 逻辑... &#125; ... &#125;) Vue.prototype.$myMethod = function (options) &#123; // 4. 添加实例方法,通过把它们添加到 Vue.prototype 上实现 // 逻辑... &#125; //使用this.$myMethod(); &#125;&#125; 总结1.插件最大的作用就是让组件变的更灵活,可以将相同功能更加轻松的应用到其他项目上,毕竟不用一个一个组件的迁移2.可以让所以的Vue组件使用相同的功能,例如:Vue.prototype.$http = axios;3.可以让其他的插件使用变的更灵活,例如:vue-router4.用来扩展Vue功能的,比如Vuex,Vue-Router,在Vue原型上扩展方法,要实现这个需求绝对没法写成组件","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(八)-组件","slug":"技术/2019-01-22-Vue学习篇(八)-组件","date":"2019-01-22T03:00:00.000Z","updated":"2020-06-09T10:00:01.764Z","comments":true,"path":"2019/01/22/技术/2019-01-22-Vue学习篇(八)-组件/","link":"","permalink":"https://ax-codes.github.io/2019/01/22/%E6%8A%80%E6%9C%AF/2019-01-22-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E5%85%AB)-%E7%BB%84%E4%BB%B6/","excerpt":"","text":"前言Vue的组件是模板和 UI 逻辑的结合Vue注册组件的关键字是:Component组件的最大好处就是可以扩展html元素,使更多的界面代码重用,复杂的界面有一个个组件组成,使界面更加模块化 组件的创建和使用1.注册一个全局组件1Vue.component(componentName, options) componentName 为组件名,options 为配置选项2.使用组件1&lt;componentName&gt;&lt;/componentName&gt; 全局组件所有实例都能用全局组件注册一个简单的全局组件 runoob,并使用它:1234567891011121314&lt;div id=\"app\"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('runoob', &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 局部组件123456789101112131415161718&lt;div id=\"app\"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;var Child = &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125; // 创建根实例new Vue(&#123; el: '#app', components: &#123; // &lt;runoob&gt; 将只在父模板可用 'runoob': Child &#125;&#125;)&lt;/script&gt; 局部组件只能在父模板里使用 Propprop 是父组件用来传递数据的一个自定义属性.父组件的数据需要通过 props 把数据传给子组件,子组件需要显式地用 props 选项声明 “prop”: 1.静态Prop1234567891011121314151617&lt;div id=\"app\"&gt; &lt;child message=\"hello!\"&gt;&lt;/child&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 \"this.message\" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 创建一个child组件然后把”hello!”赋值给message,然后组件的模板通过props获取message的值,后显示模板数据 2.动态Prop123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:message=\"parentMsg\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 \"this.message\" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app', data: &#123; parentMsg: '父组件内容' &#125;&#125;)&lt;/script&gt; 创建一个child组件然后把parentMsg属性值赋值给message,然后组件的模板通过props获取message的值,后显示模板数据,但是parentMsg的值由input控制 3.绑定多个字组件数据12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;todo-item v-for=\"item in sites\" v-bind:todo=\"item\"&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; &lt;script&gt;Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)new Vue(&#123; el: '#app', data: &#123; sites: [ &#123; text: 'Runoob' &#125;, &#123; text: 'Google' &#125;, &#123; text: 'Taobao' &#125; ] &#125;&#125;)&lt;/script&gt; prop 是单向绑定的:当父组件的属性变化时,将传导给子组件,但是不会反过来. 4.Prop 验证12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字,有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器:String,Number,Boolean,Function,Object,Array 自定义事件父组件是使用 props 传递数据给子组件,但如果子组件要把数据传递回去,就需要使用自定义事件！ 我们可以使用 v-on 绑定自定义事件, 每个 Vue 实例都实现了事件接口(Events interface),即: 使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件另外,父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件. 以下实例中子组件已经和它外部完全解耦了.它所做的只是触发一个父组件关心的内部事件.1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; &lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"incrementHandler\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementHandler: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;)&lt;/script&gt; 点击子组件触发incrementHandler事件,然后子组件的counter加加并触发模板的”increment”事件,并且increment事件对应着父组件的incrementTotal的事件,所以最终修改了父组件的total属性,达到了子组件修改父组件属性的效果 如果你想在某个组件的根元素上监听一个原生事件.可以使用 .native 修饰 v-on .例如:1&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt; data 必须是一个函数好处就是每个实例可以维护一份被返回对象的独立的拷贝,如果 data 是一个对象则会影响到其他实例,如下所示:12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/vue/2.2.2/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"components-demo3\" class=\"demo\"&gt; &lt;button-counter2&gt;&lt;/button-counter2&gt; &lt;button-counter2&gt;&lt;/button-counter2&gt; &lt;button-counter2&gt;&lt;/button-counter2&gt;&lt;/div&gt;&lt;script&gt;var buttonCounter2Data = &#123; count: 0&#125;Vue.component('button-counter2', &#123; /* data: function () &#123; // data 选项是一个函数,组件不相互影响 return &#123; count: 0 &#125; &#125;, */ data: function () &#123; // data 选项是一个对象,会影响到其他实例 return buttonCounter2Data &#125;, template: '&lt;button v-on:click=\"count++\"&gt;点击了 &#123;&#123; count &#125;&#125; 次.&lt;/button&gt;'&#125;)new Vue(&#123; el: '#components-demo3' &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子是多个多个组件使用一个对象,所以当对象的值改变的时候,其他使用了这个对象的组件显示的值也会发生改变,为了预防这个问题,我们可以一个单独的对象","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(七)-Vue的事件处理器","slug":"技术/2019-01-22-Vue学习篇(七)-Vue的事件处理器","date":"2019-01-22T02:00:00.000Z","updated":"2020-06-09T10:00:01.763Z","comments":true,"path":"2019/01/22/技术/2019-01-22-Vue学习篇(七)-Vue的事件处理器/","link":"","permalink":"https://ax-codes.github.io/2019/01/22/%E6%8A%80%E6%9C%AF/2019-01-22-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%83)-Vue%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8/","excerpt":"","text":"前言Vue的事件是v-on v-on例子1.直接调用vue函数1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt; &lt;script&gt;var app = new Vue(&#123; el: '#app', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用 JavaScript 直接调用方法app.greet() // -&gt; 'Hello Vue.js!'&lt;/script&gt; 2.使用js调用函数方法123456789101112131415&lt;div id=\"app\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;)&lt;/script&gt; 事件修饰符使用’.’来调用指令后的事件修饰符事件修饰符有:12345.stop.prevent.capture.self.once 123456789101112131415&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 按键修饰符按键修饰符有:12345678910111213.enter.tab.delete (捕获 &quot;删除&quot; 和 &quot;退格&quot; 键).esc.space.up.down.left.right.ctrl.alt.shift.meta 1&lt;input v-on:keyup.enter=\"submit\"&gt; 按回车键也响应submit方法,这里的”enter”可以替换成阿拉伯数字对应指定的键值 总结Vue里给dom绑定事件我们一般使用”v-on”,有些事件可以缩写把”v-on”替换成”@”,当要特殊处理事件逻辑时,我们可以加上事件修饰符,事件修饰符接在指令后面,并且用”.”隔开","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(五)-Vue的监听属性","slug":"技术/2019-01-21-Vue学习篇(五)-Vue的监听属性","date":"2019-01-21T02:00:00.000Z","updated":"2020-06-09T10:00:01.762Z","comments":true,"path":"2019/01/21/技术/2019-01-21-Vue学习篇(五)-Vue的监听属性/","link":"","permalink":"https://ax-codes.github.io/2019/01/21/%E6%8A%80%E6%9C%AF/2019-01-21-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%BA%94)-Vue%E7%9A%84%E7%9B%91%E5%90%AC%E5%B1%9E%E6%80%A7/","excerpt":"","text":"前言Vue的计算属性关键字是watch我们一般使用watch来监听一些字段属性的变化 例子123456789101112131415&lt;div id = \"app\"&gt; &lt;p style = \"font-size:25px;\"&gt;计数器: &#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;button @click = \"counter++\" style = \"font-size:25px;\"&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;script type = \"text/javascript\"&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 1 &#125;&#125;);vm.$watch('counter', function(nval, oval) &#123; alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');&#125;);&lt;/script&gt; 解释:当我们点击button的时候会触发click事件(简写),然后会改变counter的值,因为我们watch了counter,所以当counter的值改变的时候会触发alert 总结watch一般用来监听一些字段的变化,不管是template使监听的属性变化还是js使用vue对象调用监听的属性改变值,都会调用watch的回调","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(六)-Vue设置dom样式","slug":"技术/2019-01-21-Vue学习篇(六)-Vue设置dom样式","date":"2019-01-21T02:00:00.000Z","updated":"2020-06-09T10:00:01.762Z","comments":true,"path":"2019/01/21/技术/2019-01-21-Vue学习篇(六)-Vue设置dom样式/","link":"","permalink":"https://ax-codes.github.io/2019/01/21/%E6%8A%80%E6%9C%AF/2019-01-21-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E5%85%AD)-Vue%E8%AE%BE%E7%BD%AEdom%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"前言Vue里设置dom的样式,我们需要使用到v-bind:class这个指令来设置样式,v-bind:class我们不仅可以使用对象还能使用数组,或者直接v-bind:style设置样式 v-bind:class 对象设置样式1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/vue/2.2.2/vue.min.js\"&gt;&lt;/script&gt;&lt;style&gt;.active &#123; width: 100px; height: 100px; background: green;&#125;.text-danger &#123; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; isActive: true, hasError: true &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解释：当isActive为true时使用.active,当hasError为true时使用.text-danger,反之则不使用,所以该dom的class=’static active text-danger’,会包含默认的,且后面的样式会覆盖前面的样式 v-bind:class 数组设置样式123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/vue/2.2.2/vue.min.js\"&gt;&lt;/script&gt;&lt;style&gt;.active &#123; width: 100px; height: 100px; background: green;&#125;.text-danger &#123; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; activeClass: 'active', errorClass: 'text-danger' &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解释：该dom最后的class为’active text-danger’ v-bind:class 三元运算符设置样式1&lt;div v-bind:class=\"[errorClass ,isActive ? activeClass : '']\"&gt;&lt;/div&gt; v-bind:style 直接设置样式1.直接使用字段属性设置样式1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/vue/2.2.2/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;测试&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; activeColor: 'green', fontSize: 30 &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解释:使用v-bind:style可以直接设置css属性 2.绑定样式对象设置样式12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/vue/2.2.2/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"styleObject\"&gt;测试&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; styleObject: &#123; color: 'green', fontSize: '30px' &#125; &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.使用数组设置绑定对象样式1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/vue/2.2.2/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; baseStyles: &#123; : 'green', fontSize: '30px' &#125;, overridingStyles: &#123; 'font-weight': 'bold' &#125; &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(四)-Vue的计算属性","slug":"技术/2019-01-20-Vue学习篇(四)-Vue的计算属性","date":"2019-01-20T03:00:00.000Z","updated":"2020-06-09T10:00:01.761Z","comments":true,"path":"2019/01/20/技术/2019-01-20-Vue学习篇(四)-Vue的计算属性/","link":"","permalink":"https://ax-codes.github.io/2019/01/20/%E6%8A%80%E6%9C%AF/2019-01-20-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E5%9B%9B)-Vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/","excerpt":"","text":"前言Vue的计算属性关键字是computedcomputed相当于c#的属性,可以设置get和set方法 computed get1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 get方法,默认是get,当dom调用这个函数或者vm.reversedMessage()的时候调用 reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; computed set1234567891011121314151617181920212223242526var vm = new Vue(&#123; el: '#app', data: &#123; name: 'Google', url: 'http://www.google.com' &#125;, computed: &#123; site: &#123; // getter ,当dom调用这个函数或者vm.reversedMessage()的时候调用 get: function () &#123; return this.name + ' ' + this.url &#125;, // setter ,当vm.site=''的时候调用 set: function (newValue) &#123; var names = newValue.split(' ') this.name = names[0] this.url = names[names.length - 1] &#125; &#125; &#125;&#125;)// 调用 setter, vm.name 和 vm.url 也会被对应更新vm.site = 'http://www.runoob.com';document.write('name: ' + vm.name);document.write('&lt;br&gt;');document.write('url: ' + vm.url); 使用computed的优点按照上面的例子我们可以看出其实我们可以自定义methods来实现get和set方法,但是 computed 是基于它的依赖缓存,只有相关依赖发生改变时才会重新取值,而使用 methods ,在重新渲染的时候,函数总会重新调用执行,所有尽量使用computed会性能更高","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(三)-Vue的模板语法和常用指令","slug":"技术/2019-01-20-Vue学习篇(三)-Vue的模板语法和常用指令","date":"2019-01-20T02:00:00.000Z","updated":"2020-06-09T10:00:01.761Z","comments":true,"path":"2019/01/20/技术/2019-01-20-Vue学习篇(三)-Vue的模板语法和常用指令/","link":"","permalink":"https://ax-codes.github.io/2019/01/20/%E6%8A%80%E6%9C%AF/2019-01-20-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%89)-Vue%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E5%92%8C%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"前言Vue.js 使用了基于 HTML 的模版语法,允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据.Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统.结合响应系统,在应用状态改变时, Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上.指令:有v-前缀的特殊属性 注意:因为博客收入不能输入”大括号”,所以这里一律用”中扩后”代替 [[…]]作用:Vue最常见的文本插值,可以在html使用[[…]],输出Vue data的指定字段的数据123&lt;div id=\"app\"&gt; &lt;p&gt;[[ message ]]&lt;/p&gt;&lt;/div&gt; v-html作用:输出html代码123456789101112&lt;div id=\"app\"&gt; &lt;div v-html=\"message\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue([ el: '#app', data: [ message: '&lt;h1&gt;测试&lt;/h1&gt;' ]])&lt;/script&gt; v-bind作用:用来处理dom元素的属性下面的例子表示如果”use”为true的话使用.class1样式,而”use”属性的默认值是false,所以默认是不显示的,而use的值又是被checkbox控制,v-model我们后面会介绍12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style&gt;.class1[ display: none]&lt;/style&gt;&lt;body&gt;&lt;script src=\"https://cdn.staticfile.org/vue/2.2.2/vue.min.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;label for=\"r1\"&gt;显示div&lt;/label&gt;&lt;input type=\"checkbox\" v-model=\"use\" id=\"r1\"&gt; &lt;br&gt;&lt;br&gt; &lt;div v-bind:class=\"['class1': use]\"&gt; v-bind:class 指令 &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue([ el: '#app', data:[ use: false ]]);&lt;/script&gt;&lt;/body&gt; 表达式Vue.js 都提供了完全的 JavaScript 表达式支持,所以我们可以在模版里计算,使用三元运算符,格式化字符串1234567891011121314151617&lt;div id=\"app\"&gt; [[5+5]]&lt;br&gt; [[ ok ? 'YES' : 'NO' ]]&lt;br&gt; [[ message.split('').reverse().join('') ]] &lt;div v-bind:id=\"'list-' + id\"&gt;菜鸟教程&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue([ el: '#app', data: [ ok: true, message: 'RUNOOB', id : 1 ]])&lt;/script&gt; v-if作用:在dom里做逻辑判断,例如:v-if=”一个变量”,在data中用tru和false来判断是否显示1234567891011&lt;div id=\"app3\"&gt; &lt;span v-if=\"seen\"&gt;看见我&lt;/span&gt;&lt;/div&gt;&lt;script&gt;var app3 = new Vue([ el:\"#app3\", data:[ seen:true //用true和false来判断能否看见内容 ]])&lt;/script&gt; v-else作用:v-else和v-if指令对应1234567891011121314&lt;div id=\"app\"&gt; &lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Sorry &lt;/div&gt; &lt;div v-else&gt; Not sorry &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; v-else-if作用:和else if 一个意思,和v-if指令对应1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;div v-if=\"type === 'A'\"&gt; A &lt;/div&gt; &lt;div v-else-if=\"type === 'B'\"&gt; B &lt;/div&gt; &lt;div v-else-if=\"type === 'C'\"&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; type: 'C' &#125;&#125;)&lt;/script&gt; v-show作用:类似css的hide和show,用于控制dom是否显示1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt;只要不为false都是显示,false就隐藏 v-for作用:类似for循环结构,可以用在dom元素,也可用在templatev-for 迭代对象:12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"value in object\"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; object: &#123; name: 'name', url: 'url' &#125; &#125;&#125;)&lt;/script&gt; object 为数组别名,value为数组里的每个对象 v-for 迭代字典:1234567&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; object 为字典数组别名,value为index索引下的值,value为index索引下的键,index为当前遍历的索引值 v-for 迭代整数:1234567&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"n in 10\"&gt; &#123;&#123; n &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 指令的参数参数在指令后以冒号指明.例如, v-bind 指令被用来响应地更新 HTML 属性:123456789101112&lt;div id=\"app\"&gt; &lt;pre&gt;&lt;a v-bind:href=\"url\"&gt;链接&lt;/a&gt;&lt;/pre&gt;&lt;/div&gt; &lt;script&gt;new Vue([ el: '#app', data: [ url: 'http://www.runoob.com' ]])&lt;/script&gt; v-on作用:它用于监听 DOM 事件例如:给dom绑定点击事件:1&lt;a v-on:click=\"clickfunc\"&gt;这里的”clickfunc”是监听的事件 修饰符指明的特殊后缀,用于指出一个指令应该以特殊方式绑定.例如,.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault ():1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;preventDefault:阻止元素发生默认行为(例如:点击提交时阻止对表单的提交) v-model作用:v-model 指令一般用来在 input、select、text、checkbox、radio 等表单控件元素上创建双向数据绑定,根据表单上的值,自动更新绑定的元素的值12345678910111213&lt;div id=\"app\"&gt; &lt;p&gt;[[ message ]]&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; &lt;script&gt;new Vue([ el: '#app', data: [ message: 'Runoob!' ]])&lt;/script&gt; 过滤器作用:类似管道的作用12345678&lt;!-- 在两个大括号中 --&gt;[[message | capitalize]]&lt;!-- 在 v-bind 指令中 可以对这个div的id进行格式化--&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt;&lt;!-- 这里,message 是第一个参数,字符串 'arg1' 将传给过滤器作为第二个参数, arg2 表达式的值将被求值然后传给过滤器作为第三个参数.--&gt;[[ message | filterA('arg1', arg2)]] 缩写v-bind 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 总结使用vue的模版语法,我们将简少操作dom的次数[[…]]:用来输出基本的文本v-html:用来输出html代码v-bind:一般用来控制dom的属性表达式:vue支持在模版里使用表达式v-if:vue的逻辑判断指令,可以用在普通dom标签,也可用在template标签v-else:类似else,和v-if指令对应v-else-if:类似else-if,和v-if指令对应v-show:一般用在dom标签上,用来控制显示或者隐藏,只要不为false就是显示v-for:类似for,可以用在dom也可用在template,可遍历数组,集合也可遍历字典v-on:一般用来绑定dom的事件,v-on的属性名是事件名称指令:模版里v-开头的属性,注意:有些指令可以简写参数:在指令后面用”:”隔开的属性修饰符:在指令后面用”.”隔开的属性v-model:一般用来控制数据双向绑定,属性值变化,可以使v-model了这个属性的值也发生变化过滤器:类似管道,将数据层层往后输出,如果后面的属性是函数,那么前面的属性会作为函数的参数输入缩写:Vue 为v-bind和v-on这两个最为常用的指令提供了特别的缩写","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(二)-第一个Vue项目","slug":"技术/2019-01-19-Vue学习篇(二)-第一个Vue项目","date":"2019-01-19T13:00:00.000Z","updated":"2020-06-09T10:00:01.756Z","comments":true,"path":"2019/01/19/技术/2019-01-19-Vue学习篇(二)-第一个Vue项目/","link":"","permalink":"https://ax-codes.github.io/2019/01/19/%E6%8A%80%E6%9C%AF/2019-01-19-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%BA%8C)-%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"前言在上篇中我们已经安装好了vue,那么这篇我们主要使用vue-cli这个脚手架创建第一个基于Vue的项目;Vue.js下载地址:https://vuejs.org/js/vue.min.js Vue创建第一个Vue项目因为Vue是基于nodejs的,所以我们需要先nodejs,以下的操作都是基于安装nodejs的前提: 123456789101112131415161718192021222324252627# 全局安装 vue-cli(脚手架,用来生成web框架代码的工具)$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置,默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated \"my-project\". To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 创建项目选项中文解释123456789101112project name: 这个是你的项目名project description: 你的项目描述author: 作者Vue build: 编译选第一个就好了,直接回车install vue-router: 是否装路由use eslint to lint your code: 是否装eslint检查你的代码规范（看个人,有些人被这个搞得要死要死的,不过我建议开启.规范自己写代码的习惯,痛苦指示暂时的）Pick an ESLint preset (Use arrow keys)（选择题）: 选择一个ESLint预设标准Standard: 预设一（https://github.com/standard/standard）AirBNB : 预设二（https://github.com/standard/standard）none: 自定义Setup unit tests(Y/n): 是否安装单元测试Setup e2e tests with Nightwatch(Y/n): 是否安装e2e测试 生成的目录结构解释:12345678build: webpack的配置文件(一般不用去动他)config: 这里也是webpack的配置文件,不过是给我们配置的src: 我们的项目源代码static: 静态资源目录（存放一些第三方js库什么的）.eslintrc.js: eslint的规则test: 如果装了测试模块的会有这个（初学者不建议先玩这个,先把基本功能搞定先）index.html: 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。package.json: 项目配置文件。 更详细的解释看这里:https://blog.csdn.net/hongchh/article/details/55113751 启动第一个Vue项目123456$ cd my-project$ cnpm install$ cnpm run dev DONE Compiled successfully in 4388ms&gt; Listening at http://localhost:8080 执行完后就能看到允许的效果了,如下图: APP.vue文件解释123456789101112131415161718192021222324252627282930&lt;!-- 展示模板 --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;// 导入组件 注意在html使用组件的时候,最好跟import的组见里的别名对应到import Hello from './components/Hello' export default &#123; name: 'app', components: &#123; Hello &#125;&#125;&lt;/script&gt;&lt;!-- 样式代码 --&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 使用Vue创建简单的测试例子直接在页面的head标签里加入Vue.js的引用后,我们就能使用了 总结创建Vue项目有两种方法,一种是使用vue-cli脚手架搭建比较大型的项目,一种是直接在html里饮用Vue.js直接使用","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Vue学习篇(一)-Vue的介绍和安装","slug":"技术/2019-01-19-Vue学习篇(一)-Vue的介绍和安装","date":"2019-01-19T12:00:00.000Z","updated":"2020-06-09T10:00:01.756Z","comments":true,"path":"2019/01/19/技术/2019-01-19-Vue学习篇(一)-Vue的介绍和安装/","link":"","permalink":"https://ax-codes.github.io/2019/01/19/%E6%8A%80%E6%9C%AF/2019-01-19-Vue%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80)-Vue%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/","excerpt":"","text":"前言Vue的介绍和安装 Vue介绍Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架Vue 只关注视图层, 采用自底向上增量开发的设计.Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件. Vue 本教程基于 Vue 2.9.6 版本测试. 升级或者安装cnpm由于 npm 安装速度慢,所以我们需要使用了淘宝的镜像及其命令cnpm,npm 版本需要大于 3.0,如果低于此版本需要升级它:123456789# 查看版本$ npm -v2.9.6#升级 npmcnpm install npm -g# 升级或安装 cnpm并使用淘宝 NPM 镜像npm install -g cnpm --registry=https://registry.npm.taobao.org&gt;然后我们就可以使用cnpm来安装了&gt;eg:cnpm install [name] Vue安装12# 最新稳定版$ cnpm install vue","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"docker安装mysql","slug":"技术/2019-01-17-docker安装mysql","date":"2019-01-17T10:00:00.000Z","updated":"2020-06-09T10:00:01.754Z","comments":true,"path":"2019/01/17/技术/2019-01-17-docker安装mysql/","link":"","permalink":"https://ax-codes.github.io/2019/01/17/%E6%8A%80%E6%9C%AF/2019-01-17-docker%E5%AE%89%E8%A3%85mysql/","excerpt":"","text":"前言docker安装mysql 安装1234#这里选择5.6版本,你可以安装其他到版本docker pull mysql:5.6 #启动mysql 并且映射本机端口和设置mysql密码docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 做完上面两步发现就可以连接到mysql了 命令说明123456789-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。-v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 备注启动docker 启动mysql报错12docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6docker: Error response from daemon: Conflict. The container name \"/mymysql\" is already in use by container \"7b2b60e00fc531a0eeb2dabb6d1a8105128c33effe07242f4be755e9411bb495\". You have to remove (or rename) that container to be able to reuse that name. 解决12docker ps -a7b2b60e00fc5 mysql:5.6 \"docker-entrypoint.s…\" 3 months ago Exited (255) 2 months ago 0.0.0.0:3306-&gt;3306/tcp mymysql 看到之前运行docker容器还没有退出，导致出现容器重名情况使用下面命令，删除容器1docker rm 7b2b60e00fc5再次启动mysql发现解决 总结用docker安装mysql容易方便很多,并且更容易管理,要删除mysql可直接用docker删除容器到方法,不用像本机安装一样,卸载到时候还要删除各种注册表和删除服务器才能卸载干净","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"docker安装mongo","slug":"技术/2019-01-17-docker安装mongo","date":"2019-01-17T09:00:00.000Z","updated":"2020-06-09T10:00:01.751Z","comments":true,"path":"2019/01/17/技术/2019-01-17-docker安装mongo/","link":"","permalink":"https://ax-codes.github.io/2019/01/17/%E6%8A%80%E6%9C%AF/2019-01-17-docker%E5%AE%89%E8%A3%85mongo/","excerpt":"","text":"前言docker安装mongo 安装123docker pull mongo#启动mongodocker run -p 27017:27017 -v $PWD/db:/data/db -d mongo 做完上面两步发现就可以连接到mongo了 新增root用户启动mongo后执行下面的命令123docker ps #查看mongo的容器iddocker exec -it a7e5d4e4ca69 mongo admin #用admin 用户身份进入mongodb.createUser(&#123; user: 'root', pwd: '123456', roles: [ &#123; role: \"userAdminAnyDatabase\", db: \"admin\" &#125; ] &#125;); #创建root用户 命令说明123-p 27017:27017 :将容器的27017 端口映射到主机的27017 端口-v $PWD/db:/data/db :将主机中当前目录下的db挂载到容器的/data/db，作为mongo数据存储目录 总结查看用户:db.system.users.find().pretty()用docker安装mongo容易方便很多,并且更容易管理,要删除mongo可直接用docker删除容器的方法,不用像本机安装一样,卸载到时候还要删除各种注册表和删除服务器才能卸载干净","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"docker安装redis","slug":"技术/2019-01-17-docker安装redis","date":"2019-01-17T03:00:00.000Z","updated":"2020-06-09T10:00:01.755Z","comments":true,"path":"2019/01/17/技术/2019-01-17-docker安装redis/","link":"","permalink":"https://ax-codes.github.io/2019/01/17/%E6%8A%80%E6%9C%AF/2019-01-17-docker%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"前言docker安装redis 安装1234#这里选择3.2版本,你可以安装其他到版本docker pull redis:3.2#启动redis 并且映射本机端口和设置mysql密码docker run -p 6379:6379 -v $PWD/data:/data -d redis:3.2 redis-server --appendonly yes 做完上面两步发现就可以连接到redis了 命令说明123-p 6379:6379:将容器的6379端口映射到主机的6379端口-v $PWD/data:/data:将主机中当前目录下的data挂载到容器的/dataredis-server --appendonly yes:在容器执行redis-server启动命令，并打开redis持久化配置 连接、查看容器1234567891011runoob@runoob:~/redis$ docker exec -it 43f7a65ec7f8 redis-cli172.17.0.1:6379&gt; info# Serverredis_version:3.2.0redis_git_sha1:00000000redis_git_dirty:0redis_build_id:f449541256e7d446redis_mode:standaloneos:Linux 4.2.0-16-generic x86_64arch_bits:64multiplexing_api:epoll 总结用docker安装redis容易方便很多,并且更容易管理","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"windows pip install Scrapy 报错问题","slug":"技术/2019-01-16-windows pip install Scrapy 报错问题","date":"2019-01-16T12:00:00.000Z","updated":"2020-06-09T10:00:01.747Z","comments":true,"path":"2019/01/16/技术/2019-01-16-windows pip install Scrapy 报错问题/","link":"","permalink":"https://ax-codes.github.io/2019/01/16/%E6%8A%80%E6%9C%AF/2019-01-16-windows%20pip%20install%20Scrapy%20%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言环境:windows(64位) python2.7(64位)安装Scrapy:pip install Scrapy 报错日志12345678910111213141516171819 copying src\\twisted\\python\\test\\_deprecatetests.py.3only -&gt; build\\lib.win-amd64-2.7\\twisted\\python\\test copying src\\twisted\\words\\im\\instancemessenger.glade -&gt; build\\lib.win-amd64-2.7\\twisted\\words\\im copying src\\twisted\\words\\xish\\xpathparser.g -&gt; build\\lib.win-amd64-2.7\\twisted\\words\\xish running build_ext building 'twisted.test.raiser' extension error: Microsoft Visual C++ 9.0 is required. Get it from http://aka.ms/vcpython27 ----------------------------------------Command \"c:\\python27\\python.exe -u -c \"import setuptools, tokenize;__file__='c:\\\\users\\\\ax\\\\appdata\\\\local\\\\temp\\\\pip-install-nml_jq\\\\Twisted\\\\setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\\r\\n', '\\n');f.close();exec(compile(code, __file__, 'exec'))\" install --record c:\\users\\ax\\appdata\\local\\temp\\pip-record-xvawb1\\install-record.txt --single-version-externally-managed --compile\" failed with error code 1 in c:\\users\\ax\\appdata\\local\\temp\\pip-install-nml_jq\\Twisted\\ 解决方法查看安装twisted哪个版本报错在pip install Scrapy的log里能看到是安装twisted哪个版本报错,如下图 下载twistedhttps://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted直接在页面ctrl+f查询你要安装的版本,如下图 安装twistedpip install C:\\Users\\ax\\Downloads\\Twisted-18.9.0-cp27-cp27m-win_amd64.whl C:\\Users\\ax\\Downloads\\ 为我的下载路径 重装scrapypip install Scrapy","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"Vue表格的增删查改demo","slug":"技术/2019-01-16-Vue表格的增删查改demo","date":"2019-01-16T03:00:00.000Z","updated":"2020-06-09T10:00:01.746Z","comments":true,"path":"2019/01/16/技术/2019-01-16-Vue表格的增删查改demo/","link":"","permalink":"https://ax-codes.github.io/2019/01/16/%E6%8A%80%E6%9C%AF/2019-01-16-Vue%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9demo/","excerpt":"","text":"前言效果 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- import CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"table\"&gt; &lt;div class=\"container\" style=\"padding: 10px 20px 50px 20px;\"&gt; &lt;div class=\"handle-box\" style=\" width: 100%;\"&gt; &lt;span style=\"float:left;margin-bottom: 5px;\"&gt;字段列表&lt;/span&gt; &lt;span class=\"el-tag el-tag--mini\" style=\"cursor: pointer;float:right;margin-bottom: 5px; margin-right: 5px;\" v-if=\"btnDisabled\" @click=\"addField()\"&gt; 新增 &lt;/span&gt; &lt;/div&gt; &lt;el-table size=\"mini\" :data=\"fields_list.data\" border style=\"width: 100%\" highlight-current-row v-loading=\"fieldListGridLoading\"&gt; &lt;el-table-column type=\"index\"&gt;&lt;/el-table-column&gt; &lt;el-table-column v-for=\"(v, i) in fields_list.columns\" :key=\"i\" :prop=\"v.field\" :label=\"v.title\" :width=\"v.width\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span v-if=\"scope.row.isSet\"&gt; &lt;el-input size=\"mini\" placeholder=\"请输入内容\" v-model=\"fields_list.sel[v.field]\"&gt; &lt;/el-input&gt; &lt;/span&gt; &lt;span v-else&gt;&#123;&#123;scope.row[v.field]&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"操作\" width=\"100\"&gt; &lt;template slot-scope=\"scope\" v-if=\"btnDisabled\"&gt; &lt;span class=\"el-tag el-tag--info el-tag--mini\" style=\"cursor: pointer;\" @click=\"pwdChange(scope.row,scope.$index,true)\"&gt; &#123;&#123;scope.row.isSet?'保存':\"修改\"&#125;&#125; &lt;/span&gt; &lt;span v-if=\"!scope.row.isSet\" class=\"el-tag el-tag--danger el-tag--mini\" style=\"cursor: pointer;\" @click=\"delField(scope.row,scope.$index,true)\"&gt; 删除 &lt;/span&gt; &lt;span v-else class=\"el-tag el-tag--mini\" style=\"cursor: pointer;\" @click=\"pwdChange(scope.row,scope.$index,false)\"&gt; 取消 &lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- import Vue before Element --&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- import JavaScript --&gt;&lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt;&lt;script&gt; // id生成工具 这个比用看 示例而已 模拟后台返回的id var generateId = &#123; _count: 1, get() &#123; return ((+new Date()) + '_' + (this._count++)) &#125; &#125; new Vue(&#123; el: '#app', data() &#123; return &#123; fieldListGridLoading: false, fields_list: &#123; sel: null, // 选中行 columns: [&#123; field: 'name', title: '字段名称' &#125;, &#123; field: 'displayName', title: '别名' &#125;, &#123; field: 'type', title: '字段类型' &#125;, &#123; field: 'unit', title: '单位' &#125; ], data: [] &#125;, btnDisabled: true &#125; &#125;, methods: &#123; // 读取表格数据 readField() &#123; // 根据实际情况，自己改下啊 this.fields_list.data.map(i =&gt; &#123; i.id = generateId.get() // 模拟后台插入成功后有了id return i &#125;) &#125;, // 添加账号 addField() &#123; for (let i of this.fields_list.data) &#123; if (i.isSet) return this.$message.warning('请先保存当前编辑项') &#125; let j = &#123; id: 0, 'name': '', 'displayName': '', 'type': '', 'unit': '', 'isSet': true &#125; this.fields_list.data.push(j) this.fields_list.sel = j &#125;, // 修改 pwdChange(row, index, cg) &#123; debugger; // 点击修改 判断是否已经保存所有操作 for (let i of this.fields_list.data) &#123; if (i.isSet &amp;&amp; i.id != row.id) &#123; this.$message.warning('请先保存当前编辑项') return false &#125; &#125; // 是否是取消操作 if (!cg) &#123; if (!this.fields_list.sel.id) this.fields_list.data.splice(index, 1) return row.isSet = !row.isSet &#125; // 提交数据 if (row.isSet) &#123; // 项目是模拟请求操作 自己修改下 let data = JSON.parse(JSON.stringify(this.fields_list.sel)) for (let k in data) row[k] = data[k] // 然后这边重新读取表格数据 this.readField() row.isSet = false &#125; else &#123; this.fields_list.sel = JSON.parse(JSON.stringify(row)) row.isSet = true &#125; &#125;, delField(row, index, cg) &#123; this.fields_list.data.splice(index, 1) &#125;, getFieldsList() &#123; return this.fields_list.data &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Express模块化路由","slug":"技术/2019-01-16-Express模块化路由","date":"2019-01-16T02:00:00.000Z","updated":"2020-06-09T10:00:01.745Z","comments":true,"path":"2019/01/16/技术/2019-01-16-Express模块化路由/","link":"","permalink":"https://ax-codes.github.io/2019/01/16/%E6%8A%80%E6%9C%AF/2019-01-16-Express%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B7%AF%E7%94%B1/","excerpt":"","text":"前言使用 express.Router 类创建模块化,可挂载的路由处理程序.一个 Router 实例是一个完整的中间件和路由系统; 出于这个原因,它通常被称为”迷你应用程序”. 以下示例将路由器创建为模块,在其中加载中间件功能,定义一些路由并将路由器模块安装在主应用程序的路径中. 子模块路由代码在 app 目录中创建一个 birds.js,在 app 目录中命名路由器文件,其中包含以下内容： 123456789101112131415161718var express = require(\"express\");var router = express.Router();// middleware that is specific to this routerrouter.use(function timeLog(req, res, next) &#123; console.log(\"Time: \", Date.now()); next();&#125;);// define the home page routerouter.get(\"/\", function (req, res) &#123; res.send(\"Birds home page\");&#125;);// define the about routerouter.get(\"/about\", function (req, res) &#123; res.send(\"About birds\");&#125;);module.exports = router; 应用程序中加载子路由器模块12345var birds = require(\"./birds\");// ...app.use(\"/birds\", birds); 该应用程序现在能够处理对/birds 和/birds/about 的请求,并且可以调用 timeLog 特定于该路线的中间件功能 总结封装好一个一个子路由模块,可以使逻辑更加模块化","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"nodejs await 按行读取数据","slug":"技术/2020-01-10-nodejs await 按行读取数据","date":"2019-01-10T12:00:00.000Z","updated":"2020-06-09T10:00:01.839Z","comments":true,"path":"2019/01/10/技术/2020-01-10-nodejs await 按行读取数据/","link":"","permalink":"https://ax-codes.github.io/2019/01/10/%E6%8A%80%E6%9C%AF/2020-01-10-nodejs%20await%20%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE/","excerpt":"","text":"前言nodejs await 按行读取数据 代码12345678910111213141516171819202122const fs = require('fs');const readline = require('readline');var lineNumber = 1;async function processLineByLine() &#123; const fileStream = fs.createReadStream('./file.txt'); const rl = readline.createInterface(&#123; input: fileStream, crlfDelay: Infinity &#125;); // 注意：我们使用crlfDelay选项来识别CR LF的所有实例 // （'\\ r \\ n'）作为单个换行符在input.txt中。 for await (const line of rl) &#123; //input.txt中的每一行都将在此处作为“ line”连续可用。 console.log(`$&#123;lineNumber++&#125;: $&#123;line&#125;`); &#125;&#125;processLineByLine(); 使用文件头部注释：在当前编辑文件中使用快捷键:window：ctrl+alt+i/mac：ctrl+cmd+i,即可生成文件头部注释。 函数注释：将光标放在函数行或者将光标放在函数上方的空白行使用快捷键 window：ctrl+alt+t,mac：ctrl+cmd+t，即可生成函数注释。事实上，函数注释在文件的任意位置都可生成，这里需要自己控制。","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"开源图形化爬虫Hawk5发布","slug":"技术/2019-01-10-开源图形化爬虫Hawk5发布","date":"2019-01-10T02:00:00.000Z","updated":"2020-06-09T10:00:01.733Z","comments":true,"path":"2019/01/10/技术/2019-01-10-开源图形化爬虫Hawk5发布/","link":"","permalink":"https://ax-codes.github.io/2019/01/10/%E6%8A%80%E6%9C%AF/2019-01-10-%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%88%AC%E8%99%ABHawk5%E5%8F%91%E5%B8%83/","excerpt":"","text":"前言项目主页:https://github.com/ferventdesert/Hawk项目文档: https://ferventdesert.github.io/Hawk/示例工程文件: https://github.com/ferventdesert/Hawk-Projects/Hawk3下载地址: https://github.com/ferventdesert/Hawk/releases国内下载地址: https://gitee.com/deserthawk/Hawk/attach_files 介绍Hawk的含义为“鹰”,能够高效,准确地捕杀猎物.它的思想来源于Lisp语言,功能模仿了Linux工具awk. （Hawk尚未正式发布,本文只做功能性预览和内测使用） Hawk是一款开源图形化的爬虫和数据清洗工具,GitHub Star超过2k+,如果没有听过Hawk,可以查看以下文章介绍: Hawk3: 终于等到你: 图形化开源爬虫Hawk 3发布! Hawk2: 120项优化: 超级爬虫Hawk 2.0重磅发布! Hawk1: 如何从互联网采集海量数据？租房,二手房,薪酬… Hawk从2015年开发至今,已经经历三个版本,但是Hawk5则带来了其历史上最大的一次更新,解决了之前困扰的问题,并提供了社区化的任务市场,多国语言和更强大的调试系统. 因此作者决定直接跳过Hawk4,发布Hawk5. Hawk5欢迎界面 那么Hawk5带来哪些让人兴奋的更新呢？ 大招在最后! Hawk特点C#编写智能分析网页内容,无需编程所见即所得,可视化拖拽,快地实现转换和过滤等数据清洗操作能从各类数据库和文件实现导入导出任务可以被保存和复用其最适合的领域是爬虫和数据清洗,但其威力远超于此 断点续跑和自动保存早期Hawk会有诸多的不稳定,导致用户正在编辑任务或处理数据时,Hawk扑街了! Hawk5除了自动保存任务的功能,还能保存当前的数据表,甚至执行的位置!一旦关闭软件或遇到崩溃, 不仅历史抓取的数据还在,甚至重启后,任务还能继续从上次断掉的位置继续跑!颤抖吧筒子们! 自动回补数据这是另一革命性功能,在访问网站或其他操作时经常会遇到超时,不可访问等异常,想一次性不重不漏地获取全部数据是非常困难的. Hawk5支持了批量补数据功能,当发生异常时,Hawk会记录异常所处的任务位置和上下文,并写入一张数据表.之后Hawk即可智能地重新执行出现错误的位置,将数据不重不漏地回补回来,如下图所示: 超级文档,自动更新和多国语言Hawk5中,帮助文档获得了极大的增强（这个“极大”用的一点都不夸张）,除了丰富和细致到令人发指的在线文档: https://ferventdesert.github.io/Hawk/ 还提供了内置的文档,各个模块下方都有图文并茂的说明,当你不知道该按钮的作用时,鼠标放在该按钮上保持3秒,就有详细的说明. 更令人开心的是,当你设计完一个任务后,一键即可生成该任务的手把手帮助文档,新手用户按部就班即可重现你的奇思妙想! Hawk5进一步地提供了多国语言功能,能方便地在中文,English或其他任何语言切换,只要在执行目录增加对应的语言文件即可! 同时,Hawk的自动更新机制,能够让迭代更加敏捷,有新版本的Hawk即可一键更新,妈妈再也不用担心Hawk出现bug了! 全局参数早期的Hawk,涉及到多个任务间协同时会非常复杂,即使有子任务系统的加持也不能好转. Hawk5中设计了全局参数系统,你能在任何任务的任何模块中,使用大括号引用你已经配置的参数,并能在多个参数组间切换. 这有什么用呢？举个栗子,当二手房抓取时,每个城市们页面格式和地址都不相同, 那么就需要改很多参数,使用全局参数后,切换当前配置组并刷新,即可在多个城市间任意切换! 调试系统和UI交互改进早期的Hawk遇到配置错误时,一条数据都出不来,卡住的不仅是Hawk,还有用户的心. Hawk5为此增加更加高效和方便的调试系统,每个模块是否正常工作,会以绿色方格提醒,一目了然.当任务中间有某个模块有异常时,还能触发提示. 超级拷贝功能,使得可以通过shift键,选择多个算子模块,并在多个任务间来回拷贝.你甚至还能将Hawk自动嗅探出的XPath信息一键拷贝为python代码,极大地简化爬虫工程师的工作! 是否已经被网站封锁？总共进行了多少次请求？全局统计系统能够方便的显示当前总的web请求数,异常数,超时数,当错误数达到阈值时,更能自动暂停所有的任务! Hawk内置了埋点系统,当系统出现问题时,会自动上传错误堆栈到远程日志服务中,方便开发者定位问题. 除此之外,新版的Hawk更是改进了UI设计,例如XPath转换器,能够通过关键字快速定位,几次点选即可获取真实XPath. 社会化协作:任务市场以前所有的Hawk用户只能各自为政,无法共享,学习和沟通. 在新的Hawk中,你可以浏览和搜索线上任务市场,在软件中直接加载远程任务,直接浏览数据,并在高层方便地组合和调用其他人写的任务.像BT站一样,作者发布爬虫和数据清洗任务后,所有的Hawk用户就会立即受益!以前想抓取全国二手房数据异常复杂,且网站改版后就不能使用.而Hawk市场只要轻轻点击加载市场任务,即可在全国所有二手房数据中切换,并随时增加自己的修改,所见即所得,一键拉回本地. 这是Hawk本次更新最重要的功能,它极大地改善了Hawk社会化协作属性,它依赖于GitHub,并可配置任务源.由于账号系统的限制,目前还不能在软件中直接上传任务,如果你希望向主仓库贡献任务,可提交git的pull request.本功能将会在未来的版本中提供. 在AI时代,通过大量用户使用Hawk的行为和任务市场的积累,我们能够通过强化学习等技术,自动让AI学出自动的数据清洗和转换服务,让Hawk变得更加智能. 无限想象:自动抢票,翻译,图片识别…如果你只以为Hawk就是个爬虫,那就错了,Hawk是个通用的流式计算客户端.未来Hawk市场,不仅会有共享的任务,更会引入第三方插件机制,极大地扩展Hawk流式计算的版图. 目前正在开发中的浏览器驱动插件,能够让Hawk自动控制浏览器,模拟点击,翻页等一系列操作,你要做的只是做一遍后导入到Hawk.通过配置数据清洗流,能够实现自动抢票,键盘输入等一系列功能. 未来的插件能够更方便地调用百度识图,翻译转换以及各类服务存储API,让更多用户能够通过Hawk拖拽就能实现丰富的数据处理,并导出成任何格式. 我们对Hawk的理念,是开源,去中心化和社会化协作.它没有公司去运营,没有中心服务器,只依赖了免费的GitHub仓库,使用文档和教程都是机器自动生成的.但它也在各种艰难中一路走来,但我们对Hawk的愿景是让数据流变得更加智能,让数据工作者变得更加地敏捷方便. 感谢阅读,如果Hawk给你提供了帮助,欢迎转发本文给更多的朋友,并欢迎给本项目的GitHub点个star!","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"在github pages里配置自己的域名","slug":"技术/2019-01-02-在github pages里配置自己的域名","date":"2019-01-02T12:00:00.000Z","updated":"2020-06-11T03:22:46.206Z","comments":true,"path":"2019/01/02/技术/2019-01-02-在github pages里配置自己的域名/","link":"","permalink":"https://ax-codes.github.io/2019/01/02/%E6%8A%80%E6%9C%AF/2019-01-02-%E5%9C%A8github%20pages%E9%87%8C%E9%85%8D%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/","excerpt":"","text":"前言在 github pages 里配置自己的域名,我这里用的是腾讯注册的域名,所以也在腾讯云上做解析 步骤打开域名解析 新增域名解析 在 github 自定义域名 结尾注意这里修改好后,可能要等十分钟左右,等 dns 服务器更新解析域名","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"webpack提示Cannot read property ‘properties’ of undefined错误","slug":"技术/2019-01-02-webpack提示Cannot read property ‘properties’ of undefined错误","date":"2019-01-02T03:00:00.000Z","updated":"2020-06-09T10:00:01.731Z","comments":true,"path":"2019/01/02/技术/2019-01-02-webpack提示Cannot read property ‘properties’ of undefined错误/","link":"","permalink":"https://ax-codes.github.io/2019/01/02/%E6%8A%80%E6%9C%AF/2019-01-02-webpack%E6%8F%90%E7%A4%BACannot%20read%20property%20%E2%80%98properties%E2%80%99%20of%20undefined%E9%94%99%E8%AF%AF/","excerpt":"","text":"前言nom install的时候报错提示Cannot read property ‘properties’ of undefined错误 报错log12345678910111213141516171819202122232425262728&gt; v-contextmenu@2.8.0 dev /Users/guoxing/test/v-contextmenu&gt; cross-env NODE_ENV=development webpack-dev-server --progress --config examples/webpack.config.js/Users/guoxing/test/v-contextmenu/node_modules/webpack-cli/bin/config-yargs.js:89 describe: optionsSchema.definitions.output.properties.path.description, ^TypeError: Cannot read property 'properties' of undefined at module.exports (/Users/guoxing/test/v-contextmenu/node_modules/webpack-cli/bin/config-yargs.js:89:48) at Object.&lt;anonymous&gt; (/Users/guoxing/test/v-contextmenu/node_modules/webpack-dev-server/bin/webpack-dev-server.js:84:40) at Module._compile (internal/modules/cjs/loader.js:689:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10) at Module.load (internal/modules/cjs/loader.js:599:32) at tryModuleLoad (internal/modules/cjs/loader.js:538:12) at Function.Module._load (internal/modules/cjs/loader.js:530:3) at Function.Module.runMain (internal/modules/cjs/loader.js:742:12) at startup (internal/bootstrap/node.js:283:19) at bootstrapNodeJSCore (internal/bootstrap/node.js:743:3)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! v-contextmenu@2.8.0 dev: `cross-env NODE_ENV=development webpack-dev-server --progress --config examples/webpack.config.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the v-contextmenu@2.8.0 dev script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! /Users/guoxing/.npm/_logs/2019-01-26T06_44_11_498Z-debug.log 解决出现这个错误是因为webpack-cli版本的问题，升级到3.1.1版本或更新即可1npm i webpack-cli@3.1.1 -D","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"推荐21个顶级的Vue UI库","slug":"技术/2019-01-02-推荐21个顶级的Vue UI库","date":"2019-01-02T03:00:00.000Z","updated":"2020-06-09T10:00:01.732Z","comments":true,"path":"2019/01/02/技术/2019-01-02-推荐21个顶级的Vue UI库/","link":"","permalink":"https://ax-codes.github.io/2019/01/02/%E6%8A%80%E6%9C%AF/2019-01-02-%E6%8E%A8%E8%8D%9021%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%9A%84Vue%20UI%E5%BA%93/","excerpt":"","text":"前言2018 年的一些最佳 UI 组件 1.VuetifyStar 数为 11K，提供了 80 多个 Vue.js 组件，这些组件是根据谷歌 Material Design 指南实现的。Vuetify 支持所有平台上的浏览器，包括 IE11 和 Safari 9+（使用 polyfill），并提供了 8 个 vue-cli 模板。 地址：https://github.com/vuetifyjs/vuetify 2.QuasarStar 数超过 6K，是构建 Vue.js 响应式网站、PWA、混合移动应用和 Electron 应用的流行框架。Quasar 还支持诸如 HTML/CSS/JS 压缩、缓存清除、摇树优化（tree shaking）、源映射、代码分割和延迟加载、ES6 转码等功能。 地址：https://github.com/quasarframework/quasar 3.ElementStar 数将近 28K，是一款面向 Web 的 Vue.js 2.0 UI 工具包。它拥有一个强大的社区和 350 个贡献者，提供了丰富的可定制组件，以及完整的样式指南和更多的资源。 地址：https://github.com/ElemeFE/element 4. Vue MaterialStar 数差不多 6K，是一个实了谷歌 Material Design 的简单库。该库还提供了一个 webpack 样板、用于 Nuxt.js 的 SSR 模板和一个单独的 HTML 文件（通过这个文件开始使用框架）。这里有一些入门的例子 https://codesandbox.io/s/github/vuematerial/examples/tree/master/examples/quick-start。 地址：https://github.com/vuematerial/vue-material 5.Keen-UIStar 数将近 3.5 K，一组 Vue 组件的集合，在设计上受到了谷歌 Material Design 的启发。Keen-UI 并不是一个 CSS 框架，它不包含网格系统、排版样式等。相反，它关注的是基于 Javascript 的交互式组件。 地址：https://github.com/JosephusPaye/Keen-UI 6. BuefyStar 数 3K 左右，基于 Bulma（https://bulma.io）提供了一组轻量级的 UI 组件。Vue.js 和 Bulma 是这个库唯一的两个内部依赖。它的大小约为 60KB（压缩后的大小，并且包含了 Bulma）。你可以查看实时文档网站（https://buefy.github.io/#/documentation/start）并在 Codepen 上运行代码。 地址：https://github.com/buefy/buefy 7. Bootstrap VueStar 数超过 5K，为 Vue.js 提供了 Bootstrap 4 组件和网格系统的实现，并提供了自动 WAI-ARIA 可访问性标记。 地址：https://github.com/bootstrap-vue/bootstrap-vue 8. Muse-UIStar 数超过 6K，是另一个 Vue 2.0 MD 库，提供了 40 多个 UI 组件和可定制主题。文档主要使用中文撰写，不过大多数组件是自解释的，文档只起到辅助作用。该项目在积极的开发和维护当中。 地址：https://github.com/museui/muse-ui 9. AT-UIStar 数接近 1.5 K，一个模块化的前端 UI 框架，用于开发基于 Vue.js 的 Web 界面，适用于桌面应用程序。它提供了 NPM+Webpack+Babel 的前端开发工作流和独立的 CSS 样式，值得一试。 地址：https://github.com/at-ui/at-ui 10. VuxStar 数超过 13K，是一个流行的社区库，基于 WeUI 和 Vue 2.0。该库还支持 webpack+vue-loader+vux 的工作流。它的文档也是中文的。 地址：https://github.com/airyland/vux 11. iViewStar 数将近 16K，提供了数十种用 Vue.js 构建的 UI 组件和小部件，并采用了干净而优雅的设计。iView 被广泛采用，社区也在积极维护，并提供了 CLI 工具用于以可视化的方式创建项目。这个也值得一试。 地址：https://github.com/iview/iview 12. UivStar 数“仅”550 左右，用于 Vue 2 的 Bootstrap 3 组件库。所有组件加起来差不多 20KB，唯一的外部依赖是 Vue 和 bootstrap css，支持基于 Webpack 的工作流。 地址：https://github.com/wxsms/uiv 13. VuikitStar 数 1K 左右，一个用于网站界面的响应式的 Vue UI 库，设计风格干净而统一。该库作为由 Yarn 工作区管理的“monorepo”而构建，但图标和主题可作为单独的包发布。 地址：https://github.com/vuikit/vuikit 14.Onsen UI+Vue基于流行的 Onsen-UI 框架，封装了核心 Web 组件并暴露了 Vue 风格的 API。Onsen UI 组件也被设计为能够主动对 prop 做出反应。 地址：https://onsen.io/v2/guide/vue/ 15.Semantic UI+Vue这个项目基本上是 Semantic-UI 框架与 Vue.js 的集成。该库仍在开发当中，提供了一个类似于 Semantic-UI 的 API 以及一组可定制的主题。 地址：https://semantic-ui-vue.github.io/ 16. Fish-UIStar 数“仅”为 500 左右，贡献者也只有 3 个，但 fish-ui 提供了一个基于 Vue 的 Web 工具包，其中包含整洁干净的组件。该库支持 ES2015+Webpack 工作流。它的文档不是很全，但它的设计不容忽视。 地址：https://github.com/myliang/fish-ui 17.Mint UIStar 数超过 11K，为 Vue.js 提供 UI 元素，提供了用于构建移动应用程序的 CSS 和 JS 组件。当全部导入时，压缩后的代码只有月 30KB（JS+CSS），当然它也支持单个组件的导入。 地址：https://github.com/ElemeFE/mint-ui/ 18.Framework7 Vue这个集成提供了几乎所有的 Framework7 元素和组件，并集成了 Framework7 Router，按照 Vue 的方式来渲染页面。该库正处于积极的开发和维护当中。 地址：https://framework7.io/vue/ 19.Cube UIStar 数超过 3K，是用于 Vue.js 移动应用程序的 UI 组件库。所有组件都经过了单元测试，并且该库还支持按需进行后期编译和组件导入。这个库仍在积极开发中。 地址：https://github.com/didi/cube-ui 20. VuebluStar 数约 1.5K，是基于 Vue 2.0 和 Bulma 的 UI 组件库，用于构建中台和后台办公产品。它支持 ES2015 和 NPM+Webpack+Babel 工作流，并提供可自定义主题。 地址：https://github.com/chenz24/vue-blu 21.Ant Design VueStar 数约 1.5K，用于开发具有数十个 Ant Design 实现组件的企业级后端产品，并支持基于 Webpack 调试的构建解决方案（支持 ES6）。请注意，它的开发已经停止了一段时间。 地址：https://github.com/okoala/vue-antd 特别推荐n3-components ： https://github.com/N3-components/N3-components vuikit： https://vuikit.js.org/ Kendu UI Vue https://www.telerik.com/kendo-vue-ui Office Fabric-Vue https://github.com/aidewoode/office-ui-fabric-vue vuestrap http://kzima.github.io/vuestrap-base-components/#/ vueboot http://morgul.github.io/vueboot/ framevuerk http://framevuerk.com/ Vue WeUI http://aidenzou.github.io/vue-weui/#!/ Vue-MDC https://github.com/posva/vue-mdc 原文转自:https://hackernoon.com/21-top-vue-js-ui-libraries-for-your-app-4556e5a9060e","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"windows 宿主机器ssh连接到docker镜像","slug":"技术/2018-12-26-windows 宿主机器ssh连接到docker镜像","date":"2018-12-26T12:00:00.000Z","updated":"2020-06-09T10:00:01.730Z","comments":true,"path":"2018/12/26/技术/2018-12-26-windows 宿主机器ssh连接到docker镜像/","link":"","permalink":"https://ax-codes.github.io/2018/12/26/%E6%8A%80%E6%9C%AF/2018-12-26-windows%20%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%99%A8ssh%E8%BF%9E%E6%8E%A5%E5%88%B0docker%E9%95%9C%E5%83%8F/","excerpt":"","text":"前言系统环境:windows7docker版本:Docker version 18.03.0-ce, build 0520e24302情景:使用docker的一个镜像专门作为编译和linux开发环境 步骤1:启动docker ssh 连接到docker虚拟机1docker-machine ssh default2:启动镜像 因为我们是在docker虚拟机启动的容器,所以此时容器对应的主机就是docker虚拟机,所以60522 表示虚拟机端口,22 表示容器端口1docker run -ti -p 127.0.0.1：60522:22 centos:6 /bin/bash此时我们在宿主机器查看60522这个端口是没有运行的,因为上面已经说了启动60522端口的机器是虚拟机3:查看虚拟机ip1docker-machine ip default一般情况下这个地址是192.168.99.100宿主机器ping 192.168.99.100 发现可以ping通4:在宿主机器ssh连接虚拟机的60522端口,对应的连到的就是启动的镜像的ssh端口1ssh gx@192.168.99.100 -p 60522 总结流程:宿主机器-&gt;虚拟机-&gt;容器docker虚拟机是可以跟所有的宿主机器ping通的mac因为是直接在宿主机器启动的镜像,所以对应的映射端口的机器就是宿主机器","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"docker删除指定镜像以及依赖它的所有子镜像的脚本","slug":"技术/2018-12-26-docker删除指定镜像以及依赖它的所有子镜像的脚本","date":"2018-12-26T12:00:00.000Z","updated":"2020-06-09T10:00:01.730Z","comments":true,"path":"2018/12/26/技术/2018-12-26-docker删除指定镜像以及依赖它的所有子镜像的脚本/","link":"","permalink":"https://ax-codes.github.io/2018/12/26/%E6%8A%80%E6%9C%AF/2018-12-26-docker%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E9%95%9C%E5%83%8F%E4%BB%A5%E5%8F%8A%E4%BE%9D%E8%B5%96%E5%AE%83%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E9%95%9C%E5%83%8F%E7%9A%84%E8%84%9A%E6%9C%AC/","excerpt":"","text":"前言这是我在国外论坛看到处理docker镜像的脚本，以此保存下来，源自“Limited Atonement” 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/bin/bashif [[ $# -lt 1 ]]; then echo must supply image to remove; exit 1;fi;get_image_children ()&#123; ret=() for i in $(docker image ls -a --no-trunc -q); do #&gt;&amp;2 echo processing image \"$i\"; #&gt;&amp;2 echo parent is $(docker image inspect --format '&#123;&#123;.Parent&#125;&#125;' \"$i\") if [[ \"$(docker image inspect --format '&#123;&#123;.Parent&#125;&#125;' \"$i\")\" == \"$1\" ]]; then ret+=(\"$i\"); fi; done; echo \"$&#123;ret[@]&#125;\";&#125;realid=$(docker image inspect --format '&#123;&#123;.Id&#125;&#125;' \"$1\")if [[ -z \"$realid\" ]]; then echo \"$1 is not a valid image.\"; exit 2;fi;images_to_remove=(\"$realid\");images_to_process=(\"$realid\");while [[ \"$&#123;#images_to_process[@]&#125;\" -gt 0 ]]; do children_to_process=(); for i in \"$&#123;!images_to_process[@]&#125;\"; do children=$(get_image_children \"$&#123;images_to_process[$i]&#125;\"); if [[ ! -z \"$children\" ]]; then # allow word splitting on the children. children_to_process+=($children); fi; done; if [[ \"$&#123;#children_to_process[@]&#125;\" -gt 0 ]]; then images_to_process=(\"$&#123;children_to_process[@]&#125;\"); images_to_remove+=(\"$&#123;children_to_process[@]&#125;\"); else #no images have any children. We're done creating the graph. break; fi;done;echo images_to_remove = \"$(printf %s\\n \"$&#123;images_to_remove[@]&#125;\")\";indices=($&#123;!images_to_remove[@]&#125;);for ((i=\"$&#123;#indices[@]&#125;\" - 1; i &gt;= 0; --i)) ; do image_to_remove=\"$&#123;images_to_remove[indices[i]]&#125;\" if [[ \"$&#123;image_to_remove:0:7&#125;\" == \"sha256:\" ]]; then image_to_remove=\"$&#123;image_to_remove:7&#125;\"; fi echo removing image \"$image_to_remove\"; docker rmi \"$image_to_remove\";done","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"Clion 远程构建和部署排除了路径重置。无法读取CMakeCache.txt问题","slug":"技术/2018-12-24-Clion 远程构建和部署排除了路径重置。无法读取CMakeCache.txt问题","date":"2018-12-24T12:00:00.000Z","updated":"2020-06-09T10:00:01.728Z","comments":true,"path":"2018/12/24/技术/2018-12-24-Clion 远程构建和部署排除了路径重置。无法读取CMakeCache.txt问题/","link":"","permalink":"https://ax-codes.github.io/2018/12/24/%E6%8A%80%E6%9C%AF/2018-12-24-Clion%20%E8%BF%9C%E7%A8%8B%E6%9E%84%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2%E6%8E%92%E9%99%A4%E4%BA%86%E8%B7%AF%E5%BE%84%E9%87%8D%E7%BD%AE%E3%80%82%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96CMakeCache.txt%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言Clion 远程构建和部署排除了路径重置。无法读取CMakeCache.txt问题 报错日志123[2018-12-23 21:24] Excluded path '/Users/ax/myproject/cmake-build-remote-debug/CMakeCache.txt'[2018-12-23 21:24] 1 item excluded[2018-12-23 21:24] No files or folders found to process 原因可能是因为同时使用了两个相同的账号在同时使用，比如clion配置的ssh的账号使用的是root然而root现在正在使用情景：宿主机器在docker远程编译，docker容器正在登陆root账号，然后clion 也在使用远程的root账号 解决在远程机器新建一个专门远程编译的账号，然后clion使用该账号进行远程编译,或者在linux切换一个账号(su gx),clion就可以使用root了,本人更偏向于新建一个专门编译的账号使用root新建账号12useradd gx #新增gx账号echo \"123456\" |passwd --stdin gx #设置gx账号密码","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"mysql ERROR 1018 (HY000) Can't read dir of .xxxx(errno 13)解决方法","slug":"技术/2018-12-24-mysql ERROR 1018 (HY000) Can't read dir of .xxxx(errno 13)解决方法","date":"2018-12-24T12:00:00.000Z","updated":"2020-06-09T10:00:01.729Z","comments":true,"path":"2018/12/24/技术/2018-12-24-mysql ERROR 1018 (HY000) Can't read dir of .xxxx(errno 13)解决方法/","link":"","permalink":"https://ax-codes.github.io/2018/12/24/%E6%8A%80%E6%9C%AF/2018-12-24-mysql%20ERROR%201018%20(HY000)%20Can't%20read%20dir%20of%20.xxxx(errno%2013)%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言mysql ERROR 1018 (HY000) Can’t read dir of .’xxxx’(errno 13)解决方法 报错日志show tables的时候报这种格式的错误1ERROR 1018 (HY000): Can't read dir of './dbname/' (errno: 13) 解决方法1chown -R mysql:mysql /var/lib/mysql/dbname /var/lib/mysql:是mysql 数据路径(可以搜索数据库名称得到 find / -name dbname;whereis mysql可能没有)dbname:show tables失败的数据库名称","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"linux 设置 root 密码命令","slug":"技术/2018-12-24-linux 设置 root 密码命令","date":"2018-12-24T12:00:00.000Z","updated":"2020-06-09T10:00:01.728Z","comments":true,"path":"2018/12/24/技术/2018-12-24-linux 设置 root 密码命令/","link":"","permalink":"https://ax-codes.github.io/2018/12/24/%E6%8A%80%E6%9C%AF/2018-12-24-linux%20%E8%AE%BE%E7%BD%AE%20root%20%E5%AF%86%E7%A0%81%E5%91%BD%E4%BB%A4/","excerpt":"","text":"前言情景：docker 里的 容器root默认是没有密码的,但是ssh的时候是需要密码登录 解决设置root密码为”123456”1echo \"123456\" |passwd --stdin root","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"在docker 使用 gdb(gnu) gdbserver(gnu)远程调试","slug":"技术/2018-12-24-在docker 使用 gdb gdbserver 远程调试","date":"2018-12-24T12:00:00.000Z","updated":"2020-06-09T10:00:01.729Z","comments":true,"path":"2018/12/24/技术/2018-12-24-在docker 使用 gdb gdbserver 远程调试/","link":"","permalink":"https://ax-codes.github.io/2018/12/24/%E6%8A%80%E6%9C%AF/2018-12-24-%E5%9C%A8docker%20%E4%BD%BF%E7%94%A8%20gdb%20gdbserver%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/","excerpt":"","text":"前言注意: :这里说的gdb 和 gdbserver的版本都都是gnu的gun gdb 官网地址:http://www.gnu.org/software/gdb/gun gdb 官网文档地址:https://sourceware.org/gdb/current/onlinedocs/gdb/gnu gdb下载地址:https://ftp.gnu.org/gnu/gdb/在docker 使用 gdb gdbserver远程调试,在其他机器远程调试步骤应该是一样的 安装gdb 和 gdbserver源码安装编译编译 安装 gdb1:在上面的连接下载对应版本的源码2:进入源码根目录3:./configure –with-all-targets (如果要跨平台编译的时候需要带上这个,不然跨平台调试gdb会报不可识别的文件格式问题)4:make(这里编译需要比较长一段时间)5:make install 编译 安装 gdbserver1:进入src/gdbsever目录2:./configure –with-all-targets (如果要跨平台编译的时候需要带上这个,不然跨平台调试gdb会报不可识别的文件格式问题)3:make4:make install 卸载 gdb1:进入源码根目录的gdb文件夹2:make uninstall 注意:在根目录uninstall不行 卸载 gdbserver1:进入源码根目录的src的gdbserver文件夹2:make uninstall 源安装mac12brew install gdb --with-all-targets brew install gdb-gdbservercentos12yum install gdbyum install gdb-gdbserver 开始调试1:启动docker 容器,这里的2333 和 60522是宿主机器的端口,然后为了方便干脆把ssh的端口也开放,和映射clion测试项目的文件夹1docker run -ti --security-opt seccomp=unconfined -p 127.0.0.1:2333:2333 -p 127.0.0.1:60522:22 -v /Users/ax/CLionProjects/untitled:/untitled centos:6 /bin/bash2:容器里编译程序1g++ main.cpp -o main3:启动gdbserver 这里的main是需要调试的程序名, localhost:2333 表示占用本机的2333端口,在本机的情况下ip或者域名可以忽略1gdbserver localhost:2333 /untitled/main4:开始调试 这里的localhsot:2333表示gdbserver在本机的2333端口,因为我启动容器的时候已经映射了端口; gdb target 有其他参数可以参考官网文档在gdb的命令行下运行12target remote localhost:2333 run clion 配置远程调试1:Run -&gt; Edit Configurations 中添加 GDB Remote Debug2:在 Path mappings:remote 和 local都配置到对应的项目根目录(或者源码根目录) 注意1:macos 默认是安装苹果的gdb版本,最好都安装gnu的gdb,如果需要远程调试最好用8.0.1的版本,因为8.1和8.2好像有bug;2:mac 安装gdb一定要带上 “–with-all-targets” 并且一定要带上,不然远程调试linux程序的时候会报下面的错误123BFD: /Users/ax/CLionProjects/untitled3/cmake-build-debug/untitled3: unknown load command 0x32BFD: /Users/ax/CLionProjects/untitled3/cmake-build-debug/untitled3: unknown load command 0x32\"/Users/ax/CLionProjects/untitled3/cmake-build-debug/./untitled3\": not in executable format: 不可识别的文件格式3:在docker 里远程gdb的时候docker run需要带上”–security-opt seccomp=unconfined”选项,不然在容器启动gdbserver(gdbserver 0.0.0.0:2333 /main) 的时候什么log都没输出,正常来说应该要显示启动gdbserver 调试和正在监听的端口log,所以别的机器gdb run的时候会报错–security-opt seccomp=unconfined选项作用:Docker有个Seccomp filtering功能，以伯克莱封包过滤器（Berkeley Packet Filter，缩写BPF）的方式允许用户对容器内的系统调用（syscall）做自定义的“allow”, “deny”, “trap”, “kill”, or “trace”操作，由于Seccomp filtering的限制，在默认的配置下，会导致我们在用GDB的时候run失败，所以在执行docker run的时候加入–security-opt seccomp=unconfined这个参数，可以关闭seccomp profile的功能;官方解释:https://blog.docker.com/2016/02/docker-engine-1-10-security/4:gdbserver 是本机的话,ip 和 域名可以忽略5:clion 配置远程调试的时候 Path mappings:remote 和 local都配置到对应的项目根目录(或者源码根目录)","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"源码安装cmake","slug":"技术/2015-01-22-源码安装cmake","date":"2018-12-22T04:53:00.000Z","updated":"2020-06-09T10:00:01.589Z","comments":true,"path":"2018/12/22/技术/2015-01-22-源码安装cmake/","link":"","permalink":"https://ax-codes.github.io/2018/12/22/%E6%8A%80%E6%9C%AF/2015-01-22-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85cmake/","excerpt":"","text":"前言cmake 源码下载地址:https://cmake.org/files当我们不想使用源的cmake想自定义cmake版本的时候可以使用上面的连接下载对应的cmake源码,然后编译,安装 命令这里用cmake-3.3.2做例子1234567cd /tmpwget https://cmake.org/files/v3.3/cmake-3.3.2.tar.gz tar xzvf cmake-3.3.2.tar.gz cd cmake-3.3.2./bootstrap gmakemake install 使用源码安装的cmake卸载命令进入到源码make install的路径1make uninstall","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"mac 安装brew","slug":"技术/2018-12-21-mac 安装brew","date":"2018-12-21T12:00:00.000Z","updated":"2020-06-09T10:00:01.726Z","comments":true,"path":"2018/12/21/技术/2018-12-21-mac 安装brew/","link":"","permalink":"https://ax-codes.github.io/2018/12/21/%E6%8A%80%E6%9C%AF/2018-12-21-mac%20%E5%AE%89%E8%A3%85brew/","excerpt":"","text":"前言mac 安装brew 方法终端运行下面命令:1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"mysqld --user=root start 启动数据库报数据库文件损坏问题","slug":"技术/2018-12-21-mysqld --user=root start 启动数据库报数据库文件损坏问题","date":"2018-12-21T12:00:00.000Z","updated":"2020-06-09T10:00:01.727Z","comments":true,"path":"2018/12/21/技术/2018-12-21-mysqld --user=root start 启动数据库报数据库文件损坏问题/","link":"","permalink":"https://ax-codes.github.io/2018/12/21/%E6%8A%80%E6%9C%AF/2018-12-21-mysqld%20--user=root%20start%20%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言mysqld –user=root start 报错 注意:两个- 报错日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354552013-09-02 16:18:46 2544 [Note] Plugin 'FEDERATED' is disabled.2013-09-02 16:18:46 3e8 InnoDB: Warning: Using innodb_additional_mem_pool_size is DEPRECATED. This option may be removed in future releases, together with the option innodb_use_sys_malloc and with the InnoDB's internal memory allocator.2013-09-02 16:18:46 2544 [Note] InnoDB: The InnoDB memory heap is disabled2013-09-02 16:18:46 2544 [Note] InnoDB: Mutexes and rw_locks use Windows interlocked functions2013-09-02 16:18:46 2544 [Note] InnoDB: Compressed tables use zlib 1.2.32013-09-02 16:18:46 2544 [Note] InnoDB: Not using CPU crc32 instructions2013-09-02 16:18:46 2544 [Note] InnoDB: Initializing buffer pool, size = 16.0M2013-09-02 16:18:46 2544 [Note] InnoDB: Completed initialization of buffer pool2013-09-02 16:18:46 2544 [Note] InnoDB: Highest supported file format is Barracuda.2013-09-02 16:18:47 2544 [Note] InnoDB: The log sequence numbers 1600614 and 1600614 in ibdata files do not match the log sequence number 1600644 in the ib_logfiles!2013-09-02 16:18:47 2544 [Note] InnoDB: Database was not shutdown normally!2013-09-02 16:18:47 2544 [Note] InnoDB: Starting crash recovery.2013-09-02 16:18:47 2544 [Note] InnoDB: Reading tablespace information from the .ibd files...2013-09-02 16:18:47 2544 [ERROR] InnoDB: Attempted to open a previously opened tablespace. Previous tablespace drupal/variable uses space ID: 2 at filepath: .\\drupal\\variable.ibd. Cannot open tablespace mysql/innodb_index_stats which uses space ID: 2 at filepath: .\\mysql\\innodb_index_stats.ibdInnoDB: Error: could not open single-table tablespace file .\\mysql\\innodb_index_stats.ibdInnoDB: We do not continue the crash recovery, because the table may becomeInnoDB: corrupt if we cannot apply the log records in the InnoDB log to it.InnoDB: To fix the problem and start mysqld:InnoDB: 1) If there is a permission problem in the file and mysqld cannotInnoDB: open the file, you should modify the permissions.InnoDB: 2) If the table is not needed, or you can restore it from a backup,InnoDB: then you can remove the .ibd file, and InnoDB will do a normalInnoDB: crash recovery and ignore that table.InnoDB: 3) If the file system or the disk is broken, and you cannot removeInnoDB: the .ibd file, you can set innodb_force_recovery &gt; 0 in my.cnfInnoDB: and force InnoDB to continue crash recovery here.I looked for a solution via google but it seems to be a problem just with the drupal database because it's able to connect with MySQL if I remove the database.I hope someone could help me :(. 解决方法1:找到的配置文件(my.cnf) 可以下面的命令查找1/usr/bin/mysql --verbose --help |grep -A 1 'Default options'2:找到下面这行1# innodb_force_recovery = 2 如果没有则新增,打开这个会在mysql启动的时候自动修复损坏的数据库文件3:把注释(#)删除然后保存退出4:重新运行 mysqld –user=root start5:发现没有报”**.ibd”的错误了6:把mycnf的 innodb_force_recovery = 2 注释7:service mysql start12ERROR! MySQL server PID file could not be found!Starting MySQL. SUCCESS!数据库启动成功!","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"gdb 缺少库问题","slug":"技术/2018-12-21-gdb 缺少库问题","date":"2018-12-21T12:00:00.000Z","updated":"2020-06-09T10:00:01.723Z","comments":true,"path":"2018/12/21/技术/2018-12-21-gdb 缺少库问题/","link":"","permalink":"https://ax-codes.github.io/2018/12/21/%E6%8A%80%E6%9C%AF/2018-12-21-gdb%20%E7%BC%BA%E5%B0%91%E5%BA%93%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言macos brew install gdb后,运行gdb报错 报错日志12345axdeMacBook-Pro:~ ax$ gdbdyld: Library not loaded: /usr/local/opt/mpfr/lib/libmpfr.6.dylib Referenced from: /usr/local/bin/gdb Reason: image not foundAbort trap: 6 解决方法1:下载gdb 源码安装 地址: http://ftp.gnu.org/gnu/gdb/2:解压进入文件根目录运行以下命令123./configuremakesudo make install","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"卸载源码安装的gdb报错问题","slug":"技术/2018-12-21-卸载源码安装的gdb报错问题","date":"2018-12-21T12:00:00.000Z","updated":"2020-06-09T10:00:01.727Z","comments":true,"path":"2018/12/21/技术/2018-12-21-卸载源码安装的gdb报错问题/","link":"","permalink":"https://ax-codes.github.io/2018/12/21/%E6%8A%80%E6%9C%AF/2018-12-21-%E5%8D%B8%E8%BD%BD%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E7%9A%84gdb%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言当我们要卸载源码安装的gdb的时候,发现直接在根目录make uninstall会下面的错1the uninstall target is not supported in this tree 报错日志1the uninstall target is not supported in this tree 解决方法cd 到 gdb 根目录下的gdb文件夹执行1make uninstall再次终端运行gdb 发现就找不到命令了","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"windows docker挂载文件夹不起作用问题","slug":"技术/2018-12-21-windows docker挂载文件夹不起作用问题","date":"2018-12-21T12:00:00.000Z","updated":"2020-06-09T10:00:01.727Z","comments":true,"path":"2018/12/21/技术/2018-12-21-windows docker挂载文件夹不起作用问题/","link":"","permalink":"https://ax-codes.github.io/2018/12/21/%E6%8A%80%E6%9C%AF/2018-12-21-windows%20docker%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言windows docker挂载文件夹不起作用问题例如:1docker run -ti --security-opt seccomp&#x3D;unconfined -p 127.0.0.1:60522:22 -v &#x2F;D&#x2F;build:&#x2F;build centos:6 &#x2F;bin&#x2F;bash然后进入容器发现/build是空的 解决1:windows 的 docker 映射文件夹只能映射”C:\\Users” 下的路径,如果觉得文件都放 C:\\Users 不好的话,我们可以创建link,把link放到C:\\Users下1mklink /J \"C:\\Users\\链接名称\" \"D:\\build\\源文件夹名称\"2:注意在windows里盘符要用小写,不能用大写(git bash 进入 /c/Users/ pwd的路径),不然docker容器会识别不到路径","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"windows 使用powershell server搭建ssh服务器","slug":"技术/2018-12-17-windows 使用powershell server搭建ssh服务器","date":"2018-12-17T12:00:00.000Z","updated":"2020-06-09T10:00:01.723Z","comments":true,"path":"2018/12/17/技术/2018-12-17-windows 使用powershell server搭建ssh服务器/","link":"","permalink":"https://ax-codes.github.io/2018/12/17/%E6%8A%80%E6%9C%AF/2018-12-17-windows%20%E4%BD%BF%E7%94%A8powershell%20server%E6%90%AD%E5%BB%BAssh%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"前言powershell server下载地址:http://www.powershellserver.com/download/contact_form_pop/ eg：windows 还有类似openssh 这样搭建ssh服务器的工具,但是感觉powershell server 是最简单的 配置","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"windows 创建linker的命令","slug":"技术/2018-12-06-windows 创建linker的命令","date":"2018-12-06T12:00:00.000Z","updated":"2020-06-09T10:00:01.722Z","comments":true,"path":"2018/12/06/技术/2018-12-06-windows 创建linker的命令/","link":"","permalink":"https://ax-codes.github.io/2018/12/06/%E6%8A%80%E6%9C%AF/2018-12-06-windows%20%E5%88%9B%E5%BB%BAlinker%E7%9A%84%E5%91%BD%E4%BB%A4/","excerpt":"","text":"前言右键文件夹创建快捷方式和用命令行创建快捷方式不同右键文件夹创建快捷方式:点击快捷方式路径会自动变成原路径(不包含快捷方式的路径)命令行创建快捷:点击快捷方式路径还是包含快捷方式的路径 这样有助于更灵活的定制开发或者工作环境 eg：一个文件夹需要放置指定的编译路径下,又要放置在指定的项目管理(git svn)文件夹下,这时候我们可以创建一个git工程的一个文件夹快捷方式,放置指定编译的路径里 命令1mklink /J \"E:\\work\\快捷方式路径\" \"E:\\work\\Web\\原文件夹路径\"","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术随笔","slug":"技术随笔","permalink":"https://ax-codes.github.io/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"生活随笔","slug":"生活随笔","permalink":"https://ax-codes.github.io/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}]},{"title":"clion 破解和配置c++开发环境","slug":"技术/2018-12-06-clion 破解和配置c++开发环境","date":"2018-12-06T12:00:00.000Z","updated":"2020-06-09T10:00:01.713Z","comments":true,"path":"2018/12/06/技术/2018-12-06-clion 破解和配置c++开发环境/","link":"","permalink":"https://ax-codes.github.io/2018/12/06/%E6%8A%80%E6%9C%AF/2018-12-06-clion%20%E7%A0%B4%E8%A7%A3%E5%92%8C%E9%85%8D%E7%BD%AEc++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言clion 官网:https://www.jetbrains.com/clion/clion 选择下载版本:https://www.jetbrains.com/clion/download/#section=windowsclion windows版下载路径:https://www.jetbrains.com/clion/download/download-thanks.html?platform=windows cygwin 搭建c++开发环境在本博客搜索 “cygwin 搭建c++开发环境” clion 破解方法1 2 3windows:打开C:\\Windows\\System32\\drivers\\etc目录下的“hosts”，将“0.0.0.0 account.jetbrains.com”添加到hosts文件最后，然后保存退出mac:打开/etc目录下的“hosts”，将“0.0.0.0 account.jetbrains.com”添加到hosts文件最后，然后保存退出 4回到clion2018激活界面，点选“Activation code”，并将注册码复制到下面的编辑框中，然后点击“OK”即可激活成功 clion 使用 cygwin 配置编译和调试环境 clion c++项目目录结构","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"cygwin 搭建c++开发环境","slug":"技术/2018-12-05-cygwin 搭建c++开发环境","date":"2018-12-05T12:00:00.000Z","updated":"2020-06-09T10:00:01.703Z","comments":true,"path":"2018/12/05/技术/2018-12-05-cygwin 搭建c++开发环境/","link":"","permalink":"https://ax-codes.github.io/2018/12/05/%E6%8A%80%E6%9C%AF/2018-12-05-cygwin%20%E6%90%AD%E5%BB%BAc++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言cygwin官网:http://www.cygwin.com/cygwin.exe 64位下载路径:http://www.cygwin.com/setup-x86_64.execygwin.exe 32位下载路径:http://www.cygwin.com/setup-x86.exe cygwin 简介Cygwin是一个在windows平台上运行的类UNIX模拟环境，是cygnus solutions公司开发的自由软件（该公司开发的著名工具还有eCos，不过现已被Redhat收购）。它对于学习UNIX/Linux操作环境，或者从UNIX到Windows的应用程序移植，或者进行某些特殊的开发工作，尤其是使用GNU工具集在Windows上进行嵌入式系统开发，非常有用。随着嵌入式系统开发在国内日渐流行，越来越多的开发者对Cygwin产生了兴趣。Cygwin 提供一个UNIX 模拟 DLL 以及在其上层构建的多种可以在 Linux 系统中找到的软件包，在 Windows XP SP3 以上的版本提供良好的支持。Cygwin主要由Red Hat及其下属社区负责维护。 cygwin 安装1 2 3 4 5 6 这里为了获得最快的下载速度提供三个下载地址:Cygwin中国镜像的地址:http://www.cygwin.cn/阿里云镜像:http://mirrors.aliyun.com/cygwin/163镜像:http://mirrors.163.com/cygwin/这里用163镜像为例子 7根据时间排序,选择最新版本 8在search 分别搜索gcc-core、gcc-g++、make、gdb、binutils 然后安装 测试是否安装成功在cygwin的安装目录的bin目录下搜索 gcc.exe、g++.exe、make.exe、gdb.exe、binutils.exe 看是否都存在 命令行安装gcc 和 g++的方法(如果可以的话看看能不将 gcc-core、gcc-g++、make、gdb、binutils 全部命令行安装)直接在 setup-x86_64.exe 或 setup-x86.exe 运行以下命令1setup-x86_64.exe -q -P wget -P gcc-g++ -P make -P diffutils -P libmpfr-devel -P libgmp-devel -P libmpc-devel","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"docker批量删除容器,镜像","slug":"技术/2018-12-01-docker批量删除容器,镜像","date":"2018-12-01T12:00:00.000Z","updated":"2020-06-09T10:00:01.702Z","comments":true,"path":"2018/12/01/技术/2018-12-01-docker批量删除容器,镜像/","link":"","permalink":"https://ax-codes.github.io/2018/12/01/%E6%8A%80%E6%9C%AF/2018-12-01-docker%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8,%E9%95%9C%E5%83%8F/","excerpt":"","text":"前言docker批量删除容器,镜像 删除所有容器1docker rm `docker ps -a -q` 删除所有镜像1docker rmi `docker images -q` 按条件删除镜像没有标签的景象1docker rmi `docker images -q | awk '/^&lt;none&gt;/ &#123; print $3 &#125;'`根据条件查询出的镜像1docker rmi --force `docker images | grep 条件(镜像备注) | awk '&#123;print $3&#125;'`","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"docker 新增或者修改源","slug":"技术/2018-12-01-docker 新增或者修改源","date":"2018-12-01T12:00:00.000Z","updated":"2020-06-09T10:00:01.701Z","comments":true,"path":"2018/12/01/技术/2018-12-01-docker 新增或者修改源/","link":"","permalink":"https://ax-codes.github.io/2018/12/01/%E6%8A%80%E6%9C%AF/2018-12-01-docker%20%E6%96%B0%E5%A2%9E%E6%88%96%E8%80%85%E4%BF%AE%E6%94%B9%E6%BA%90/","excerpt":"","text":"前言docker 新增或者修改源 方法1:/etc/docker/daemon.json1vi /etc/docker/daemon.json2:在里面新增或者修改源3:macos/linux重启docker:sudo service docker restart windows重启docker:打开virtual box选择docker虚拟机点击重启 例子比如我需要安装一个centos6,但是国外的源最低只有7的,可以在/etc/docker/daemon.json新增123&#123; \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"]&#125;然后重启docker(sudo service docker restart)d最后:docker pull centos:6","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"git只管理项目里的指定文件夹","slug":"技术/2018-11-22-git只管理项目里的指定文件夹","date":"2018-11-22T01:53:00.000Z","updated":"2020-06-09T10:00:01.700Z","comments":true,"path":"2018/11/22/技术/2018-11-22-git只管理项目里的指定文件夹/","link":"","permalink":"https://ax-codes.github.io/2018/11/22/%E6%8A%80%E6%9C%AF/2018-11-22-git%E5%8F%AA%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"","text":"前言git只管理项目里的指定文件夹的方法 命令1234567git initgit config --global user.name \"git用户名\"git config --global user.email \"git邮箱\"git config core.sparsecheckout trueecho '/Web/*' &gt;&gt; .git/info/sparse-checkout #'/Web/*'表示需要管理的指定文件夹git remote add origin 项目地址git pull origin master","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"在vscode里编写markdown","slug":"技术/2018-11-14-在vscode里编写markdown","date":"2018-11-13T03:53:00.000Z","updated":"2020-06-09T10:00:01.700Z","comments":true,"path":"2018/11/13/技术/2018-11-14-在vscode里编写markdown/","link":"","permalink":"https://ax-codes.github.io/2018/11/13/%E6%8A%80%E6%9C%AF/2018-11-14-%E5%9C%A8vscode%E9%87%8C%E7%BC%96%E5%86%99markdown/","excerpt":"","text":"前言在vscode里编写markdown 安装插件在插件里搜索Markdown Preview Enhanced并安装 导出html在预览界面里右键有导出","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"Beyond Compare 4 提示错误“这个授权密钥已被吊销”的解决办法","slug":"技术/2018-11-13-Beyond Compare 4 提示错误“这个授权密钥已被吊销”的解决办法","date":"2018-11-13T01:53:00.000Z","updated":"2020-06-09T10:00:01.699Z","comments":true,"path":"2018/11/13/技术/2018-11-13-Beyond Compare 4 提示错误“这个授权密钥已被吊销”的解决办法/","link":"","permalink":"https://ax-codes.github.io/2018/11/13/%E6%8A%80%E6%9C%AF/2018-11-13-Beyond%20Compare%204%20%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF%E2%80%9C%E8%BF%99%E4%B8%AA%E6%8E%88%E6%9D%83%E5%AF%86%E9%92%A5%E5%B7%B2%E8%A2%AB%E5%90%8A%E9%94%80%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"前言Beyond Compare 错误提示：这个授权密钥已被吊销。 解决方法删除以下目录中的所有文件即可 C:\\Users\\Administrator\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4 备注Administrator能需要替换成你的用户名,比如我的是 C:\\Users\\ax\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"mysql能用localhost连接不能使用127.0.0.1连接的解决办法","slug":"技术/2018-10-25-mysql能用localhost连接不能使用127.0.0.1连接的解决办法","date":"2018-10-25T09:00:00.000Z","updated":"2020-06-09T10:00:01.698Z","comments":true,"path":"2018/10/25/技术/2018-10-25-mysql能用localhost连接不能使用127.0.0.1连接的解决办法/","link":"","permalink":"https://ax-codes.github.io/2018/10/25/%E6%8A%80%E6%9C%AF/2018-10-25-mysql%E8%83%BD%E7%94%A8localhost%E8%BF%9E%E6%8E%A5%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8127.0.0.1%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"前言因为用nodejs的mysql 解决1.vim /etc/my.cnf2.注释skip_networking3.bind_address=127.0.0.1(没有的话新增)4.重启mysql","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"NLog的使用和配置","slug":"技术/2018-09-20-NLog的使用和配置","date":"2018-09-20T01:53:00.000Z","updated":"2020-06-09T10:00:01.696Z","comments":true,"path":"2018/09/20/技术/2018-09-20-NLog的使用和配置/","link":"","permalink":"https://ax-codes.github.io/2018/09/20/%E6%8A%80%E6%9C%AF/2018-09-20-NLog%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前言NLog是一种可以向控制台,文件,数据,邮件等写日志的类库 NLog安装可以直接在Nuget包管理工具安装,demo使用的是4.5.10的版本如果要将日志写到数据库,则需要安装MySql.Data,也可以直接在Nuget包管理工具下载安装 NLog Nuget包和NLog.Config Nuget包 NLog.Config配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd\" autoReload=\"true\" throwExceptions=\"false\" 是否打开NLog的调试输出,有时候没有打印日志,可打开此开关调试,看是否有报错,默认是关闭为false的 internalLogLevel=\"Off\" internalLogFile=\"c:\\temp\\nlog-internal.log\"&gt; &lt;!-- optional, add some variables https://github.com/nlog/NLog/wiki/Configuration-file#variables --&gt; &lt;!--配置这个是因为可以让下面的target 选择输出的模板 也是根据name字段选择--&gt; &lt;variable name=\"variable1\" value=\"$&#123;newline&#125;date： $&#123;date&#125;$&#123;newline&#125;level： $&#123;level&#125;$&#123;newline&#125;logger： $&#123;logger&#125;$&#123;newline&#125;machinename： $&#123;machinename&#125;$&#123;newline&#125;message： $&#123;message&#125;$&#123;newline&#125;appdomain： $&#123;appdomain&#125;$&#123;newline&#125;assembly-version： $&#123;assembly-version&#125;$&#123;newline&#125;basedir： $&#123;basedir&#125;$&#123;newline&#125;callsite： $&#123;callsite&#125;$&#123;newline&#125;callsite-linenumber： $&#123;callsite-linenumber&#125;$&#123;newline&#125;counter： $&#123;counter&#125;$&#123;newline&#125;nlogdir： $&#123;nlogdir&#125;$&#123;newline&#125;processid： $&#123;processid&#125;$&#123;newline&#125;processname： $&#123;processname&#125;$&#123;newline&#125;specialfolder： $&#123;specialfolder&#125;$&#123;newline&#125;stacktrace: $&#123;stacktrace&#125;$&#123;newline&#125;-----------------------------------------------------------\" /&gt; &lt;!-- See https://github.com/nlog/nlog/wiki/Configuration-file for information on customizing logging rules and outputs. --&gt; &lt;targets&gt; &lt;!--输出至控制台--&gt; &lt;target name=\"console\" xsi:type=\"ColoredConsole\" layout=\"$&#123;longdate&#125; $&#123;message&#125; $&#123;exception:format=tostring&#125;\"&gt;&lt;/target&gt; &lt;!--VS输出窗口 需要调试的时候才有--&gt; &lt;target name=\"debugger\" xsi:type=\"Debugger\" layout=\"$&#123;longdate&#125; $&#123;message&#125; $&#123;exception:format=tostring&#125;\" /&gt; &lt;!--保存至文件--&gt; &lt;target name=\"log_file\" xsi:type=\"File\" fileName=\"$&#123;basedir&#125;/Logs/$&#123;shortdate&#125;/$&#123;level:uppercase=false:padding=-5&#125;.txt\" layout=\"$&#123;longdate&#125; | $&#123;message&#125; $&#123;onexception:$&#123;exception:format=tostring&#125; $&#123;newline&#125; $&#123;stacktrace&#125; $&#123;newline&#125;\" /&gt; &lt;!--输出至邮件--&gt; &lt;target xsi:type=\"Mail\" name=\"infoMail\" smtpServer=\"smtp.163.com\" smtpPort=\"25\" smtpAuthentication=\"Basic\" smtpUserName=\"发送邮箱账号 eg:demo@163.com\" smtpPassword=\"发送邮箱密码\" enableSsl=\"true\" 是否使用ssl访问特定的SMTP邮件服务器 addNewLines=\"true\" from=\"发送邮箱账号 eg:demo@163.com\" to=\"接收邮箱账号 eg:demo@qq.com\" 如果有多个邮箱可以用逗号分隔 subject=\"Project Exception Mail\" 发件人的邮箱 header=\"*********************\" 内容的头部 body=\"$&#123;longdate&#125; | $&#123;message&#125; \" 内容的主体部分 footer=\"*********************\"/&gt; 内容的footer部分 &lt;!--输出至数据库 不是web项目--&gt; &lt;!--表结构--&gt; &lt;!--CREATE TABLE `log` ( `Id` int(10) unsigned NOT NULL AUTO_INCREMENT, `Application` varchar(50) DEFAULT NULL, `Logged` datetime DEFAULT NULL, `Level` varchar(50) DEFAULT NULL, `Message` text DEFAULT NULL, `UserName` varchar(512) Default Null, `Logger` text DEFAULT NULL, `Callsite` text DEFAULT NULL, `Exception` text DEFAULT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;--&gt; &lt;target xsi:type=\"Database\" name=\"mysqlDb\" dbProvider=\"MySql.Data.MySqlClient.MySqlConnection, MySql.Data\" connectionString=\"Server=47.104.87.242;User Id=root;Password=GuoXing123;Database=gx_test;Character Set=utf8;SslMode=none;\"&gt; &lt;commandText&gt; insert into log ( Application, Logged, Level, Message, Username, Logger, CallSite, Exception ) values ( @Application, @Logged, @Level, @Message, @Username, @Logger, @Callsite, @Exception ); &lt;/commandText&gt; &lt;parameter name=\"@application\" layout=\"yourappname\" /&gt; &lt;parameter name=\"@logged\" layout=\"$&#123;date&#125;\" /&gt; &lt;parameter name=\"@level\" layout=\"$&#123;level&#125;\" /&gt; &lt;parameter name=\"@message\" layout=\"$&#123;message&#125;\" /&gt; &lt;parameter name=\"@username\" layout=\"$&#123;identity&#125;\" /&gt; &lt;parameter name=\"@logger\" layout=\"$&#123;logger&#125;\" /&gt; &lt;parameter name=\"@callSite\" layout=\"$&#123;callsite&#125;\" /&gt; &lt;parameter name=\"@exception\" layout=\"$&#123;exception:tostring&#125;\" /&gt; &lt;/target&gt; &lt;!--输出至数据库 是web项目 web项目的话因为有 $&#123;aspnet-request-host&#125; $&#123;aspnet-request-url:IncludeQueryString=true&#125; $&#123;aspnet-Request-ip&#125; 这几个字段要获取,所以我们要按照NLog.Web包才行,不然会报错--&gt; &lt;!--表结构--&gt; &lt;!--CREATE TABLE `log` ( `Id` int(10) unsigned NOT NULL AUTO_INCREMENT, `Application` varchar(50) DEFAULT NULL, `Logged` datetime DEFAULT NULL, `Level` varchar(50) DEFAULT NULL, `Message` text DEFAULT NULL, `UserName` varchar(512) Default Null, `ServerName` text Default Null, `Url` text NULL, `RemoteAddress` nvarchar(100) NULL, `Logger` text DEFAULT NULL, `Callsite` text DEFAULT NULL, `Exception` text DEFAULT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;--&gt; &lt;target xsi:type=\"Database\" name=\"mysqlDb\" dbProvider=\"MySql.Data.MySqlClient.MySqlConnection, MySql.Data\" connectionString=\"Server=47.104.87.242;User Id=root;Password=GuoXing123;Database=gx_test;Character Set=utf8;SslMode=none;\"&gt; &lt;commandText&gt; insert into log ( Application, Logged, Level, Message, Username, ServerName, Url,RemoteAddress, Logger, CallSite, Exception ) values ( @Application, @Logged, @Level, @Message, @Username, @ServerName, @Url,@RemoteAddress, @Logger, @Callsite, @Exception ); &lt;/commandText&gt; &lt;parameter name=\"@application\" layout=\"yourappname\" /&gt; &lt;parameter name=\"@logged\" layout=\"$&#123;date&#125;\" /&gt; &lt;parameter name=\"@level\" layout=\"$&#123;level&#125;\" /&gt; &lt;parameter name=\"@message\" layout=\"$&#123;message&#125;\" /&gt; &lt;parameter name=\"@username\" layout=\"$&#123;identity&#125;\" /&gt; &lt;parameter name=\"@serverName\" layout=\"$&#123;aspnet-request-host&#125;\" /&gt; &lt;parameter name=\"@url\" layout=\"$&#123;aspnet-request-url:IncludeQueryString=true&#125;\" /&gt; &lt;parameter name=\"@remoteAddress\" layout=\"$&#123;aspnet-Request-ip&#125;\" /&gt; &lt;parameter name=\"@logger\" layout=\"$&#123;logger&#125;\" /&gt; &lt;parameter name=\"@callSite\" layout=\"$&#123;callsite&#125;\" /&gt; &lt;parameter name=\"@exception\" layout=\"$&#123;exception:tostring&#125;\" /&gt; &lt;/target&gt; &lt;rules&gt; &lt;!-- add your logging rules here --&gt; &lt;!--设置输出级别,和输出到哪里,writeTo对应的是targets对应target的name;没有指定level就是所有等级--&gt; &lt;logger name=\"*\" writeTo=\"infoMail\" /&gt; &lt;!--&lt;logger name=\"*\" writeTo=\"debugger\" /&gt;--&gt; &lt;!--&lt;logger name=\"*\" writeTo=\"File\" /&gt;--&gt; &lt;!-- Write all events with minimal level of Debug (So Debug, Info, Warn, Error and Fatal, but not Trace) to \"f\" &lt;logger name=\"*\" minlevel=\"Debug\" writeTo=\"f\" /&gt; --&gt; &lt;/rules&gt;&lt;/nlog&gt; 测试123456789public static void Main(string[] args) &#123; Logger logger = LogManager.GetCurrentClassLogger(); logger.Trace(\"Trace Message\"); logger.Debug(\"Debug Message\"); logger.Info(\"Info Message\"); logger.Error(\"Error Message\"); logger.Fatal(\"Fatal Message\"); &#125; 备注如果没有输出日志可以打开NLog.conf里的nlog节点的throwExceptions属性(设置为true)","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"Linux使用ntp同步时间","slug":"技术/2018-09-14-Linux使用ntp同步机器时间","date":"2018-09-14T01:53:00.000Z","updated":"2020-06-09T10:00:01.689Z","comments":true,"path":"2018/09/14/技术/2018-09-14-Linux使用ntp同步机器时间/","link":"","permalink":"https://ax-codes.github.io/2018/09/14/%E6%8A%80%E6%9C%AF/2018-09-14-Linux%E4%BD%BF%E7%94%A8ntp%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%99%A8%E6%97%B6%E9%97%B4/","excerpt":"","text":"前言使用ntp同步多台机器时间1:ntp server：选择ntp 客户端同步的server 启动命令:/etc/init.d/ntpd start …2:ntpdate: ntp客户端,需要单独安装 ntpdate -u ntp server ip(eg:ntpdate -u 192.168.199.222)上面的两个可以下载rpm包安装 rpm -ivh 包名 ntp配置解析ntp服务器配置1.按上图修改/etc/ntp.conf文件2.启动NTP时间服务器：service ntpd start3.设置NTP开机自动启动：chkconfig ntpd on4.查看NTP是否正常运行：netstat -tlunp | grep ntp5.配置防火墙过滤规则：/sbin/iptables -I INPUT -p udp –dport 123 -j ACCEPT如何配置：/etc/sysconfig/iptables 文件内配置开放udp 123端口： -A INPUT -p udp –destination-port 123 -j ACCEPT ntp客户端配置1.按上图修改/etc/ntp.conf文件2.启动NTP时间客户端：service ntpd start 客户端和服务端的程序一样,只是config里的权限和时间服务器ip不同3.测试 ntpdate -u 112.222.22.111;如果返回下图结果,则说明成功 启动ntp server 报错,并找不到ntp.log问题解决:因为我们使用ntpdate的时候都要指定ntp server,所以在内网同步多台机器的时候,当service ntpd start的时候没有启动成功,我们想看日志,但发现 find / -name “ntp.log” 没有找到ntp的log,这个时候我们可以去/var/log/message 里面看,然后解决里面的问题重启ntpd就行,启动后再在客户机里ntpdate -u 服务机ip 发现成功 启动ntp server 报”Cannot find user ntp”问题解决:新建ntp用户就行1useradd ntp crontab 配置 ntpdate每分钟同步一次1* * * * * sleep 60; /usr/sbin/ntpdate -u 112.222.22.111 &gt;&gt; /tmp/ntpdate_112.222.22.111.log","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"}]},{"title":"使用DotNetCore.WindowsService编写windows服务","slug":"技术/2018-09-14-使用DotNetCore.WindowsService编写windows服务","date":"2018-09-14T01:53:00.000Z","updated":"2020-06-09T10:00:01.696Z","comments":true,"path":"2018/09/14/技术/2018-09-14-使用DotNetCore.WindowsService编写windows服务/","link":"","permalink":"https://ax-codes.github.io/2018/09/14/%E6%8A%80%E6%9C%AF/2018-09-14-%E4%BD%BF%E7%94%A8DotNetCore.WindowsService%E7%BC%96%E5%86%99windows%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"前言使用DotNetCore.WindowsService 安装windows服务DotNetCore.WindowsService github地址:https://github.com/PeterKottas/DotNetCore.WindowsService Nuget包安装命令1Install-Package PeterKottas.DotNetCore.WindowsService 备注DotNetCore.WindowsService 命令格式eg:安装命令,比如我们需要安装JobSchedule.exe,则在生成路径里执行1JobSchedule.exe action:install这样我就能在windows服务里找到JobSchedule服务了 操作Create .NETCore console app. Create your first service, something like this:123456789101112131415161718192021222324252627282930313233343536public class ExampleService : IMicroService&#123; public void Start() &#123; Console.WriteLine(\"I started\"); &#125; public void Stop() &#123; Console.WriteLine(\"I stopped\"); &#125;&#125;You can also inherit MicroService base class and take advantage of built in timers:public class ExampleService : MicroService, IMicroService&#123; public void Start() &#123; this.StartBase(); Timers.Start(\"Poller\", 1000, () =&gt; &#123; Console.WriteLine(\"Polling at &#123;0&#125;\\n\", DateTime.Now.ToString(\"o\")); &#125;, (e) =&gt; &#123; Console.WriteLine(\"Exception while polling: &#123;0&#125;\\n\", e.ToString()); &#125;); Console.WriteLine(\"I started\"); &#125; public void Stop() &#123; this.StopBase(); Console.WriteLine(\"I stopped\"); &#125;&#125;Api for services (and yeah, it’s simmilar to Topshelf, thanks for inspiration, I just couldn’t wait for you guys to implement this):12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ServiceRunner&lt;ExampleService&gt;.Run(config =&gt;&#123; var name = config.GetDefaultName(); config.Service(serviceConfig =&gt; &#123; serviceConfig.ServiceFactory((extraArguments, microServiceController) =&gt; &#123; return new ExampleService(); &#125;); serviceConfig.OnStart((service, extraArguments) =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; started\", name); service.Start(); &#125;); serviceConfig.OnStop(service =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; stopped\", name); service.Stop(); &#125;); serviceConfig.OnInstall(service =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; installed\", name); &#125;); serviceConfig.OnUnInstall(service =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; uninstalled\", name); &#125;); serviceConfig.OnPause(service =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; paused\", name); &#125;); serviceConfig.OnContinue(service =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; continued\", name); &#125;); serviceConfig.OnShutdown(service =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; shutdown\", name); &#125;); serviceConfig.OnError(e =&gt; &#123; Console.WriteLine(\"Service &#123;0&#125; errored with exception : &#123;1&#125;\", name, e.Message); &#125;); &#125;);&#125;);Optionally set the name of the service like this:1234ServiceRunner&lt;ExampleService&gt;.Run(config =&gt;&#123; config.SetName(\"MyTestService\");&#125;);Run the service without arguments and it runs like console app. Run the service with action:install and it will install the service. Run the service with action:uninstall and it will uninstall the service. Run the service with action:start and it will start the service. Run the service with action:stop and it will stop the service. Run the service with action:pause and it will pause the service. Run the service with action:continue and it will continue the service. Run the service with username:YOUR_USERNAME, password:YOUR_PASSWORD and action:install which installs it for the given account. Run the service with built-in-account:(NetworkService|LocalService|LocalSystem) and action:install which installs it for the given built in account. Defaults to LocalSystem. Run the service with description:YOUR_DESCRIPTION and it setup description for the service. Run the service with display-name:YOUR_DISPLAY_NAME and it setup Display name for the service. Run the service with name:YOUR_NAME and it setup name for the service. Run the service with start-immediately:(true|false) to start service immediately after install. Defaults to true. You can find the complete example in PeterKottas.DotNetCore.Example project. Install the service using powershell: dotnet.exe $serviceDllPath action:install","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":".net core引用项目方法","slug":"技术/2018-09-07-.net core引用项目方法","date":"2018-09-07T01:53:00.000Z","updated":"2020-06-09T10:00:01.687Z","comments":true,"path":"2018/09/07/技术/2018-09-07-.net core引用项目方法/","link":"","permalink":"https://ax-codes.github.io/2018/09/07/%E6%8A%80%E6%9C%AF/2018-09-07-.net%20core%E5%BC%95%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言.net core引用项目 直接使用NuGet包方法引用引用同一解决方案里的项目修改需要引用的项目下的.csproj文件在这个文件的节点下新增 节点,如果没有ItemGroup节点可以新增,然后你就可以引用这个外部项目了","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"使用.NET IL Linker优化.net core发布包","slug":"技术/2018-09-07-使用.NET IL Linker优化.net core发布包","date":"2018-09-07T01:53:00.000Z","updated":"2020-06-09T10:00:01.688Z","comments":true,"path":"2018/09/07/技术/2018-09-07-使用.NET IL Linker优化.net core发布包/","link":"","permalink":"https://ax-codes.github.io/2018/09/07/%E6%8A%80%E6%9C%AF/2018-09-07-%E4%BD%BF%E7%94%A8.NET%20IL%20Linker%E4%BC%98%E5%8C%96.net%20core%E5%8F%91%E5%B8%83%E5%8C%85/","excerpt":"","text":"前言我们打包.net core发布包的时候会发现打包生成的public文件夹有好几十M,这个时候我们可以使用IL Linker来瘦身,不过瘦身后我们会发现,差不多减小了一半大小,不过一般来讲应该最起码还是有二三十M,不过现在这应该是已经到极限了,希望微软后面能给出解决方案吧,下面介绍一下怎样用IL Linker来优化发布包 使用.NET IL linker优化发布包 cd 到工程根目录,执行 1dotnet new nuget 执行完后会创建一个nuget.config文件 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;configuration&gt; &lt;packageSources&gt; &lt;!--To inherit the global NuGet package sources remove the &lt;clear/&gt; line below --&gt; &lt;clear/&gt; &lt;/packageSources&gt; &lt;/configuration&gt; 将nuget.config修改成 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;configuration&gt; &lt;packageSources&gt; &lt;add key=\"dotnet-core\" value=\"https://dotnet.myget.org/F/dotnet-core/api/v3/index.json\"/&gt; &lt;/packageSources&gt; &lt;/configuration&gt; 这样我们就能够连接到微软自己的测试用 NuGet 源。继续在命令行里面敲 1dotnet add package ILLink.Tasks -v 0.1.4-preview-981901 最后我们就可以执行下面命令发布了 1dotnet publish -c release -r ubuntu.18.04-x64","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"使用DotnetSpider爬取优酷数据","slug":"技术/2018-09-07-使用DotnetSpider爬取优酷数据","date":"2018-09-07T01:53:00.000Z","updated":"2020-06-09T10:00:01.689Z","comments":true,"path":"2018/09/07/技术/2018-09-07-使用DotnetSpider爬取优酷数据/","link":"","permalink":"https://ax-codes.github.io/2018/09/07/%E6%8A%80%E6%9C%AF/2018-09-07-%E4%BD%BF%E7%94%A8DotnetSpider%E7%88%AC%E5%8F%96%E4%BC%98%E9%85%B7%E6%95%B0%E6%8D%AE/","excerpt":"","text":"前言使用DotnetSpider爬取优酷数据.net core版本:.net core 2dotnetspider版本:DotnetSpider2.Core(2.4.4):(可直接搜索DotnetSpider2.Core nuget包) demo 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788using DotnetSpider.Core;using DotnetSpider.Core.Downloader;using DotnetSpider.Core.Pipeline;using DotnetSpider.Core.Processor;using DotnetSpider.Core.Scheduler;using DotnetSpider.Core.Selector;using System;using System.Collections.Generic;using System.Text;namespace DotnetSpiderTest&#123; public class YoukuVideo &#123; public string Name &#123; get; set; &#125; &#125; public class YoukuPageProcessor : BasePageProcessor &#123; protected override void Handle(Page page) &#123; // 利用 Selectable 查询并构造自己想要的数据对象 var totalVideoElements = page.Selectable.SelectList(Selectors.XPath(\"//div[@class='yk-pack pack-film']\")).Nodes(); List&lt;YoukuVideo&gt; results = new List&lt;YoukuVideo&gt;(); foreach (var videoElement in totalVideoElements) &#123; var video = new YoukuVideo(); video.Name = videoElement.Select(Selectors.XPath(\".//img[@class='quic']/@alt\")).GetValue(); results.Add(video); &#125; // Save data object by key. 以自定义KEY存入page对象中供Pipeline调用 page.AddResultItem(\"VideoResult\", results); &#125; &#125; public class YoukuPipeline : BasePipeline &#123; private static long count = 0; public override void Process(IEnumerable&lt;ResultItems&gt; resultItems, ISpider spider) &#123; foreach (var resultItem in resultItems) &#123; Console.WriteLine(); Console.WriteLine(\"=================================================\"); StringBuilder builder = new StringBuilder(); foreach (YoukuVideo entry in resultItem.Results[\"VideoResult\"]) &#123; builder.Append($\" [YoukuVideo &#123;count&#125;] &#123;entry.Name&#125;\"); &#125; Console.WriteLine(builder); Console.WriteLine(); Console.WriteLine(\"=================================================\"); &#125; // Other actions like save data to DB. 可以自由实现插入数据库或保存到文件 &#125; &#125; class Program &#123; static void Main(string[] args) &#123; // Config encoding, header, cookie, proxy etc... 定义采集的 Site 对象, 设置 Header、Cookie、代理等 var site = new Site &#123; EncodingName = \"UTF-8\", RemoveOutboundLinks = true &#125;; site.Domains = new[] &#123; \"list.youku.com\" &#125;;//必须设置这个域名,因为启动爬虫的时候有个域名是否为空校验,不然会报错 for (int i = 1; i &lt; 5; ++i) &#123; // Add start/feed urls. 添加初始采集链接 site.AddStartUrl($\"http://list.youku.com/category/show/c_96_s_1_d_1_p_&#123;i&#125;.html\"); &#125; Spider spider = Spider.Create(site, // use memoery queue scheduler. 使用内存调度 new QueueDuplicateRemovedScheduler(), // use custmize processor for youku 为优酷自定义的 Processor new YoukuPageProcessor()) // use custmize pipeline for youku 为优酷自定义的 Pipeline .AddPipeline(new YoukuPipeline()); spider.Downloader = new HttpClientDownloader(); spider.ThreadNum = 1; spider.EmptySleepTime = 3000; // Start crawler 启动爬虫 spider.Run(); &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"Linux下使用ifconfig报没有命令","slug":"技术/2018-09-06-Linux下使用ifconfig报没有命令","date":"2018-09-06T05:53:00.000Z","updated":"2020-06-09T10:00:01.676Z","comments":true,"path":"2018/09/06/技术/2018-09-06-Linux下使用ifconfig报没有命令/","link":"","permalink":"https://ax-codes.github.io/2018/09/06/%E6%8A%80%E6%9C%AF/2018-09-06-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8ifconfig%E6%8A%A5%E6%B2%A1%E6%9C%89%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux下使用ifconfig报没有命令错误的解决方法安装net-tools","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"}]},{"title":"ubuntu下安装.net core","slug":"技术/2018-09-06-ubuntu下安装.net core","date":"2018-09-06T05:53:00.000Z","updated":"2020-06-09T10:00:01.678Z","comments":true,"path":"2018/09/06/技术/2018-09-06-ubuntu下安装.net core/","link":"","permalink":"https://ax-codes.github.io/2018/09/06/%E6%8A%80%E6%9C%AF/2018-09-06-ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85.net%20core/","excerpt":"","text":"前言11111ubuntu下安装.net core,我们直接安装dotnetcore环境利用的部署方式是依赖框架的部署(所以的.net core程序公用一个环境),官网还提供了独立部署 使用shell脚本自动安装 下载 dotnet-install.sh(shell 脚本也可以从微软.net core官网下载) 直接在主机运行脚本 如下图表示安装成功 配置环境变量我们的.net core程序默认是在/root/.dotnet下,所以我们需要配置环境变量 1export PATH=$PATH:/root/.dotnet 最后我们就可以使用dotnet 命令了","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"艾弗森生涯百大过人集锦","slug":"生活/2018-08-28-艾弗森生涯百大过人集锦","date":"2018-08-28T00:00:00.000Z","updated":"2020-06-09T10:00:01.876Z","comments":true,"path":"2018/08/28/生活/2018-08-28-艾弗森生涯百大过人集锦/","link":"","permalink":"https://ax-codes.github.io/2018/08/28/%E7%94%9F%E6%B4%BB/2018-08-28-%E8%89%BE%E5%BC%97%E6%A3%AE%E7%94%9F%E6%B6%AF%E7%99%BE%E5%A4%A7%E8%BF%87%E4%BA%BA%E9%9B%86%E9%94%A6/","excerpt":"","text":"艾弗森生涯百大过人集锦艾弗森生涯百大过人集锦","categories":[{"name":"生活","slug":"生活","permalink":"https://ax-codes.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://ax-codes.github.io/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}]},{"title":"vs2017调试不能多文件调试python代码问题","slug":"技术/2018-08-26-vs2017调试不能多文件调试python代码问题","date":"2018-08-26T13:53:00.000Z","updated":"2020-06-09T10:00:01.674Z","comments":true,"path":"2018/08/26/技术/2018-08-26-vs2017调试不能多文件调试python代码问题/","link":"","permalink":"https://ax-codes.github.io/2018/08/26/%E6%8A%80%E6%9C%AF/2018-08-26-vs2017%E8%B0%83%E8%AF%95%E4%B8%8D%E8%83%BD%E5%A4%9A%E6%96%87%E4%BB%B6%E8%B0%83%E8%AF%95python%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言安装vs2017调试python不能跨文件调试问题,使用的是自己安装的anconda 解决勾选下图的单选框,再重新启动启动文件,发现可以调试了","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"mysql启动提示(The server quit without updating PID file(…))失败","slug":"技术/2018-08-16-mysql启动提示(The server quit without updating PID file(…))失败","date":"2018-08-16T09:43:00.000Z","updated":"2020-06-09T10:00:01.672Z","comments":true,"path":"2018/08/16/技术/2018-08-16-mysql启动提示(The server quit without updating PID file(…))失败/","link":"","permalink":"https://ax-codes.github.io/2018/08/16/%E6%8A%80%E6%9C%AF/2018-08-16-mysql%E5%90%AF%E5%8A%A8%E6%8F%90%E7%A4%BA(The%20server%20quit%20without%20updating%20PID%20file(%E2%80%A6))%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"前言linux启动mysql失败报错: 解决121: /etc/init.d/mysqld start2: /etc/init.d/mysql start 连接mysql 发现连接成功","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Docker在windows下无法开启伪终端解决方法","slug":"技术/2018-07-09-Docker在windows下无法开启伪终端解决方法","date":"2018-07-09T09:43:00.000Z","updated":"2020-06-09T10:00:01.671Z","comments":true,"path":"2018/07/09/技术/2018-07-09-Docker在windows下无法开启伪终端解决方法/","link":"","permalink":"https://ax-codes.github.io/2018/07/09/%E6%8A%80%E6%9C%AF/2018-07-09-Docker%E5%9C%A8windows%E4%B8%8B%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E4%BC%AA%E7%BB%88%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"问题在windows下面安装了docker以后，运行docker run -it ubuntu /bin/bash失败，提示错误“cannot enable tty mode on non tty input” 解决第一种在命令前面加上winpty1winpty docker run -it ubuntu &#x2F;bin&#x2F;bash 第二种方案更好（为什么自己去感受吧）12docker-machine ssh defaultdocker run -it ubuntu &#x2F;bin&#x2F;bash","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"linux crontab 使用python脚本定时执行命令","slug":"技术/2018-07-09-linux crontab 使用python脚本定时执行命令","date":"2018-07-09T09:43:00.000Z","updated":"2020-06-09T10:00:01.672Z","comments":true,"path":"2018/07/09/技术/2018-07-09-linux crontab 使用python脚本定时执行命令/","link":"","permalink":"https://ax-codes.github.io/2018/07/09/%E6%8A%80%E6%9C%AF/2018-07-09-linux%20crontab%20%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/","excerpt":"","text":"使用nohup1nohup python -u scheduler.py &gt; ..&#x2F;log&#x2F;sync_table_partition.log 2&gt;&amp;1 使用-u参数，使得python不启用缓冲,直接输出内容","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"win10vpn连接报错(ERROR因为安全层在初始化与远程计算机的协商时遇到了一个处理错误)解决方法","slug":"技术/2018-05-24-win10vpn连接报错(ERROR因为安全层在初始化与远程计算机的协商时遇到了一个处理错误)解决方法","date":"2018-05-24T00:00:00.000Z","updated":"2020-06-09T10:00:01.671Z","comments":true,"path":"2018/05/24/技术/2018-05-24-win10vpn连接报错(ERROR因为安全层在初始化与远程计算机的协商时遇到了一个处理错误)解决方法/","link":"","permalink":"https://ax-codes.github.io/2018/05/24/%E6%8A%80%E6%9C%AF/2018-05-24-win10vpn%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99(ERROR%E5%9B%A0%E4%B8%BA%E5%AE%89%E5%85%A8%E5%B1%82%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8D%8F%E5%95%86%E6%97%B6%E9%81%87%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF)%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"Step 1.确保IPsec Policy Agent服务已启动Step 2.确保路由和远程访问（Routing and Remote Access）和远程访问连接管理器服务（Remote Access Connection Manager）启动Step 3.注册表添加 ProhibitIpSec 注册表项12注册表路径HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\Rasman\\Parameters创建ProhibitIpSec注册表项，选择DWORD类型并将其设置为 1 的值 Step 4.注册表添加 AllowL2TPWeakCrypto 注册表项12注册表路径HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\Rasman\\Parameters创建 AllowL2TPWeakCrypto 注册表项，选择DWORD类型并将其设置为 1 的值 Step 5.重启计算机","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"python sftp上传文件代码","slug":"技术/2018-05-21-python sftp上传文件代码","date":"2018-05-21T09:43:00.000Z","updated":"2020-06-09T10:00:01.670Z","comments":true,"path":"2018/05/21/技术/2018-05-21-python sftp上传文件代码/","link":"","permalink":"https://ax-codes.github.io/2018/05/21/%E6%8A%80%E6%9C%AF/2018-05-21-python%20sftp%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81/","excerpt":"","text":"前言需要安装paramiko模块 注意如果直接上传文件则远程路径需要带上”文件名” 123456789101112131415161718192021222324252627282930313233343536373839404142# coding=utf-8import paramikoimport osdef sftp_upload(host,port,username,password,local,remote): sf = paramiko.Transport((host,port)) sf.connect(username = username,password = password) sftp = paramiko.SFTPClient.from_transport(sf) try: if os.path.isdir(local):#判断本地参数是目录还是文件 for f in os.listdir(local):#遍历本地目录 sftp.put(os.path.join(local+f),os.path.join(remote+f))#上传目录中的文件 else: sftp.put(local,remote)#上传文件 except Exception,e: print('upload exception:',e) sf.close()def sftp_download(host,port,username,password,local,remote): sf = paramiko.Transport((host,port)) sf.connect(username = username,password = password) sftp = paramiko.SFTPClient.from_transport(sf) try: if os.path.isdir(local):#判断本地参数是目录还是文件 for f in sftp.listdir(remote):#遍历远程目录 sftp.get(os.path.join(remote+f),os.path.join(local+f))#下载目录中文件 else: sftp.get(remote,local)#下载文件 except Exception,e: print('download exception:',e) sf.close()if __name__ == '__main__': host = '192.168.199.182'#主机 port = 22 #端口 username = 'root' #用户名 password = 'root123' #密码 local = 'D:\\\\ftptest.txt'#本地文件或目录，与远程一致，当前为windows目录格式，window目录中间需要使用双斜线 remote = '/root/ftpfile/ftptest.txt'#远程文件或目录，与本地一致，当前为linux目录格式 sftp_upload(host,port,username,password,local,remote)#上传 #sftp_download(host,port,username,password,local,remote)#下载 paramiko.SSHException: Incompatible ssh peer (no acceptable kex algorithm) 问题有时候paramiko的版本低会出现这个报错：paramiko.SSHException: Incompatible ssh peer (no acceptable kex algorithm)解决:执行下面命令12pip install --upgrade pippip install paramiko --upgrade","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"python使用tcp socket例子","slug":"技术/2018-05-17-python使用tcp socket例子","date":"2018-05-17T03:00:00.000Z","updated":"2020-06-09T10:00:01.669Z","comments":true,"path":"2018/05/17/技术/2018-05-17-python使用tcp socket例子/","link":"","permalink":"https://ax-codes.github.io/2018/05/17/%E6%8A%80%E6%9C%AF/2018-05-17-python%E4%BD%BF%E7%94%A8tcp%20socket%E4%BE%8B%E5%AD%90/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding: utf-8 -*import socketimport threadingimport timeimport systype = sys.getfilesystemencoding() #获取系统默认编码类型# 3、tcp的通信def tcp_server(): # 1、创建套接字 tcp_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 2、绑定本地信息 address = ('127.0.0.1', 7788) tcp_fd.bind(address) # 3、使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了 tcp_fd.listen(5) while True: # 4、如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务器 # newSocket用来为这个客户端服务 # tcpSerSocket就可以省下来专门等待其他新客户端的链接 new_fd, client_address = tcp_fd.accept() # 5、接收对方发送过来的数据，最大接收1024个字节 receive_data = new_fd.recv(1024) print('server: receive data:', receive_data.decode(encoding='utf-8')) # 6、发送一些数据到客户端 new_fd.send(b\"thank you !\") # print(new_fd.getpeername()) # print(new_fd.getsockname()) # 7、关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接 new_fd.close() # 关闭监听套接字，只要这个套接字关闭了，就意味着整个程序不能再接收任何新的客户端的连接 tcp_fd.close()def tcp_client(num): # 1、创建socket tcp_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 2、链接服务器 server_address = ('127.0.0.1', 7788) tcp_fd.connect(server_address) # 3、发送数据 tcp_fd.send(b'hello world.') # 4、接收对方发送过来的数据，最大接收1024个字节 receive_data = tcp_fd.recv(1024) print('client-%s receive data:' % num, receive_data.decode(encoding='utf-8')) # 5、关闭套接字 # print(tcp_fd.getpeername()) # print(tcp_fd.getsockname()) tcp_fd.close()if __name__ == \"__main__\": t1 = threading.Thread(target=tcp_server) t1.start() time.sleep(5) th = [] for i in range(5): t = threading.Thread(target=tcp_client, args=(i,)) t.start() time.sleep(1) th.append(t) for t in th: t.join()","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"同时安装python2和python3后 使用pip报错问题","slug":"技术/2018-04-27-同时安装python2和python3后 使用pip报错问题","date":"2018-04-27T12:00:00.000Z","updated":"2020-06-09T10:00:01.669Z","comments":true,"path":"2018/04/27/技术/2018-04-27-同时安装python2和python3后 使用pip报错问题/","link":"","permalink":"https://ax-codes.github.io/2018/04/27/%E6%8A%80%E6%9C%AF/2018-04-27-%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85python2%E5%92%8Cpython3%E5%90%8E%20%E4%BD%BF%E7%94%A8pip%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言同时安装 python2 和 python3 后使用 pip 报错问题 python2 pip -V or python3 pip -V 报错日志1E:\\Python27\\python2.exe: can&#39;t find &#39;__main__&#39; module in &#39;pip&#39; 解决方法在 python2 或者 python3 后面加上 -mpython2 -m pip -V or python3 -m pip -V表示已模块的方式运行默认的不用加","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"python使用Selenium自动化操作网页","slug":"技术/2018-04-03-python使用Selenium自动化操作网页","date":"2018-04-03T00:00:00.000Z","updated":"2020-06-09T10:00:01.667Z","comments":true,"path":"2018/04/03/技术/2018-04-03-python使用Selenium自动化操作网页/","link":"","permalink":"https://ax-codes.github.io/2018/04/03/%E6%8A%80%E6%9C%AF/2018-04-03-python%E4%BD%BF%E7%94%A8Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%93%8D%E4%BD%9C%E7%BD%91%E9%A1%B5/","excerpt":"","text":"前言conda install selenium","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"编译和安装boost库","slug":"技术/2018-02-21-编译和安装boost库","date":"2018-02-21T12:00:00.000Z","updated":"2020-06-09T10:00:01.666Z","comments":true,"path":"2018/02/21/技术/2018-02-21-编译和安装boost库/","link":"","permalink":"https://ax-codes.github.io/2018/02/21/%E6%8A%80%E6%9C%AF/2018-02-21-%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85boost%E5%BA%93/","excerpt":"","text":"前言这里用的是centos6 作为例子;boost的版本是boost_1_63_0boost库官网:http://www.boost.org/boost源码下载地址:https://www.boost.org/users/download/ 编译1:进入源码根目录运行1./bootstrap.shwindows 运行./bootstrap.bat2:编译 这里需要比较长的时间1./b23:安装1./b2 install","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"python(ImportError No module named win32api)","slug":"技术/2018-01-26-python(ImportError No module named win32api)","date":"2018-01-26T12:00:00.000Z","updated":"2020-06-09T10:00:01.665Z","comments":true,"path":"2018/01/26/技术/2018-01-26-python(ImportError No module named win32api)/","link":"","permalink":"https://ax-codes.github.io/2018/01/26/%E6%8A%80%E6%9C%AF/2018-01-26-python(ImportError%20No%20module%20named%20win32api)/","excerpt":"","text":"前言环境:windows(64位) python2.7(64位) 报错日志1ImportError No module named win32api 解决方法pip install pypiwin32","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"json数组转tree数据","slug":"技术/2018-01-22-json数组转tree数据","date":"2018-01-22T03:00:00.000Z","updated":"2020-06-09T10:00:01.663Z","comments":true,"path":"2018/01/22/技术/2018-01-22-json数组转tree数据/","link":"","permalink":"https://ax-codes.github.io/2018/01/22/%E6%8A%80%E6%9C%AF/2018-01-22-json%E6%95%B0%E7%BB%84%E8%BD%ACtree%E6%95%B0%E6%8D%AE/","excerpt":"","text":"前言json数组转tree数据 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//传入数据var data=[ &#123;id:1,parent:0,text:'A'&#125;, &#123;id:2,parent:4,text:\"B\"&#125;, &#123;id:3,parent:7,text:\"C\"&#125;, &#123;id:4,parent:1,text:\"D\"&#125;, &#123;id:5,parent:0,text:\"E\"&#125;, &#123;id:6,parent:5,text:'B'&#125;, &#123;id:7,parent:4,text:\"F\"&#125;];//转换方法function treeUtil(data,key,parentKey,map) &#123; this.data=data; this.key=key; this.parentKey=parentKey; this.treeParentKey=parentKey; //parentKey要转换成什么属性名称 this.treeKey=key; //key要转换成什么属性名称 this.map=map; if(map)&#123; if(map[key])this.treeKey=map[key]; &#125; this.toTree=function () &#123; var data=this.data; var pos=&#123;&#125;; var tree=[]; var i=0; while(data.length!=0)&#123; if(data[i][this.parentKey]==0)&#123; var _temp = this.copy(data[i]); tree.push(_temp); pos[data[i][this.key]]=[tree.length-1]; data.splice(i,1); i--; &#125;else&#123; var posArr=pos[data[i][this.parentKey]]; if(posArr!=undefined)&#123; var obj=tree[posArr[0]]; for(var j=1;j&lt;posArr.length;j++)&#123; obj=obj.children[posArr[j]]; &#125; var _temp=this.copy(data[i]); obj.children.push(_temp); pos[data[i][this.key]]=posArr.concat([obj.children.length-1]); data.splice(i,1); i--; &#125; &#125; i++; if(i&gt;data.length-1)&#123; i=0; &#125; &#125; return tree; &#125; this.copy=function (item) &#123; var _temp=&#123; children:[] &#125;; _temp[this.treeKey]=item[this.key]; for(var _index in item)&#123; if(_index!=this.key &amp;&amp; _index!=this.parentKey)&#123; var _property = item[_index]; if((!!this.map) &amp;&amp; this.map[_index]) _temp[this.map[_index]]=_property; else _temp[_index]=_property; &#125; &#125; return _temp; &#125;&#125;//调用 map用来做名称转换var map=&#123;\"text\":\"title\",\"id\":\"id0\"&#125;;var tree1 = new treeUtil(data,'id','parent',map);console.log(tree1.toTree()); 结果p","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://ax-codes.github.io/tags/js/"}]},{"title":"Scrapy学习篇(四)-第一个项目","slug":"技术/2018-01-19-Scrapy学习篇(四)-第一个项目","date":"2018-01-19T12:00:00.000Z","updated":"2020-07-13T09:44:41.903Z","comments":true,"path":"2018/01/19/技术/2018-01-19-Scrapy学习篇(四)-第一个项目/","link":"","permalink":"https://ax-codes.github.io/2018/01/19/%E6%8A%80%E6%9C%AF/2018-01-19-Scrapy%E5%AD%A6%E4%B9%A0%E7%AF%87(%E5%9B%9B)-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"前言上一篇我们已经安装好了 Scrapy 现在我们将开始使用 Scrapy 抓取数据我们将爬取 Scrapy 官网文档地址的数据,链接:https://doc.scrapy.org/en/latest/ 创建项目startproject进入到我们需要将项目文件放置的地址执行: 1scrapy startproject mySpider 注意:mySpider 是我们的项目名称 项目结构执行完创建命令后该路径下会生成 mySpider 文件夹,目录结构: 12345678910mySpider&#x2F; scrapy.cfg mySpider&#x2F; __init__.py items.py pipelines.py settings.py spiders&#x2F; __init__.py ... 文件的作用:scrapy.cfg: 项目的配置文件.mySpider/: 项目的 Python 模块,将会从这里引用代码.mySpider/middlewares.py：中间件mySpider/items.py: 项目的目标文件.(一般直接用再爬虫代码里生成对象)mySpider/pipelines.py: 项目的管道文件.(必须在 setting 里注册,然后在爬虫代码里返回 item 才会触发)mySpider/settings.py: 项目的设置文件.mySpider/spiders/: 存储爬虫代码目录. 创建爬虫文件可以在项目目录里使用命令创建,也可以直接在”mySpider/spiders/“目录下手动创建,这里我们使用命令创建,因为这样会自动帮我们生成 spider 模板代码: 1scrapy genspider test \"doc.scrapy.org/en/latest\" 注意:doc.scrapy.org/en/latest 这里不用加上 http 或者 https,模板会自动加上 执行完上面创建爬虫的命令后,会在”mySpider/spiders/“里生成一个”test.py”文件,内容为: 1234567891011# -*- coding: utf-8 -*-import scrapyclass TestSpider(scrapy.Spider): name = 'test' allowed_domains = ['doc.scrapy.org/en/latest'] start_urls = ['http://doc.scrapy.org/en/latest/'] def parse(self, response): pass 内容解释:name = “” :这个爬虫的识别名称,必须是唯一的,在不同的爬虫必须定义不同的名字allow_domains = [] 是搜索的域名范围,也就是爬虫的约束区域,规定爬虫只爬取这个域名下的网页,不存在的 URL 会被忽略start_urls = () :爬取的 URL 元祖/列表.爬虫从这里开始抓取数据,所以,第一次下载的数据将会从这些 urls 开始.其他子 URL 将会从这些起始 URL 中继承性生成parse(self, response) :解析的方法,每个初始 URL 完成下载后将被调用,调用的时候传入从每一个 URL 传回的 Response 对象来作为唯一参数,主要作用如下:负责解析返回的网页数据(response.body),提取结构化数据(生成 item)生成需要下一页的 URL 请求.将 start_urls 的值修改为需要爬取的第一个 url,如果我们需要爬取该域名下的其他界面,可以把连接添加到 start_urls 运行爬虫将”mySpider/spiders/test.py”的内容修改为 1234567891011121314151617# -*- coding: utf-8 -*-import scrapy# 以下三行是在 Python2.x版本中解决乱码问题，Python3.x 版本的可以去掉import sysreload(sys)sys.setdefaultencoding(\"utf-8\")class TestSpider(scrapy.Spider): name = 'test' allowed_domains = ['doc.scrapy.org/en/latest'] start_urls = ['http://doc.scrapy.org/en/latest/'] def parse(self, response): filename = \"teacher.html\" open(filename, 'w').write(response.body)#保存body到teacher.html文件 pass","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"Scrapy学习篇(三)-Scrapy的常用命令","slug":"技术/2018-01-18-Scrapy学习篇(三)-Scrapy的常用命令","date":"2018-01-18T12:00:00.000Z","updated":"2020-06-09T10:00:01.662Z","comments":true,"path":"2018/01/18/技术/2018-01-18-Scrapy学习篇(三)-Scrapy的常用命令/","link":"","permalink":"https://ax-codes.github.io/2018/01/18/%E6%8A%80%E6%9C%AF/2018-01-18-Scrapy%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%89)-Scrapy%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"前言Scrapy的命令一般分为两种,一种是全局命令,一种是项目命令全局命令:可以在使用到Scrapy的任何地方使用项目命令:只能在项目目录里执行 全局命令startproject1scrapy startproject &lt;project_name&gt; 这个命令是scrapy最为常用的命令之一,它将会在当前目录下创建一个名为 &lt;project_name&gt;的项目. settings1scrapy settings [options] 该命令将会输出Scrapy默认设定,当然如果你在项目中运行这个命令将会输出项目的设定值. runspider1scrapy runspider &lt;spider_file.py&gt; 在未创建项目的情况下,运行一个编写在Python文件中的spider. shell1scrapy shell [url] 以给定的URL(如果给出)或者空(没有给出URL)启动Scrapy shell.例如,scrapy shell http://www.baidu.com将会打开百度URL,并且启动交互式命令行,可以用来做一些测试. fetch1scrapy fetch &lt;url&gt; 使用Scrapy下载器(downloader)下载给定的URL,并将获取到的内容送到标准输出.简单的来说,就是打印url的html代码. view1scrapy view &lt;url&gt; 在你的默认浏览器中打开给定的URL,并以Scrapy spider获取到的形式展现. 有些时候spider获取到的页面和普通用户看到的并不相同,一些动态加载的内容是看不到的, 因此该命令可以用来检查spider所获取到的页面. version1scrapy version [-v] 输出Scrapy版本.配合 -v 运行时,该命令同时输出Python, Twisted以及平台的信息. 项目命令crawl1scrapy crawl &lt;spider_name&gt;使用你项目中的spider进行爬取,即启动你的项目.这个命令将会经常用到,我们会在后面的内容中经常使用.check1crapy check [-l] &lt;spider&gt;运行contract检查,检查你项目中的错误之处.list1scrapy list列出当前项目中所有可用的spider.每行输出一个spider.genspider1scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt;在当前项目中创建spider.该方法可以使用提前定义好的模板来生成spider.您也可以自己创建spider的源码文件. 总结常用的命令一般只有startproject和crawl,一个是用来创建项目,一个是用来运行项目.","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"Scrapy学习篇(二)-Scrapy的安装","slug":"技术/2018-01-17-Scrapy学习篇(二)-Scrapy的安装","date":"2018-01-17T12:00:00.000Z","updated":"2020-06-09T10:00:01.662Z","comments":true,"path":"2018/01/17/技术/2018-01-17-Scrapy学习篇(二)-Scrapy的安装/","link":"","permalink":"https://ax-codes.github.io/2018/01/17/%E6%8A%80%E6%9C%AF/2018-01-17-Scrapy%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%BA%8C)-Scrapy%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"","text":"前言Scrapy的安装 Scrapy的安装Windows12pip install --upgrade pippip install Scrapy ubuntu12sudo apt-get install python-dev python-pip libxml2-dev libxslt1-dev zlib1g-dev libffi-dev libssl-devsudo pip install scrapy macos12345$ sudo pip install virtualenv$ virtualenv scrapyenv$ cd scrapyenv$ source bin/activate$ pip install Scrapy 测试1scrapy version 备注如果pip install scrapy失败,可以在博客里搜索”windows pip install Scrapy 报错问题”","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"Scrapy学习篇(一)-项目框架","slug":"技术/2018-01-16-Scrapy学习篇(一)-项目框架","date":"2018-01-16T12:00:00.000Z","updated":"2020-06-09T10:00:01.659Z","comments":true,"path":"2018/01/16/技术/2018-01-16-Scrapy学习篇(一)-项目框架/","link":"","permalink":"https://ax-codes.github.io/2018/01/16/%E6%8A%80%E6%9C%AF/2018-01-16-Scrapy%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80)-%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6/","excerpt":"","text":"前言Scrapy 是用 Python 实现的一个为了爬取网站数据、提取结构性数据而编写的应用框架Scrapy 常应用在包括数据挖掘,信息处理或存储历史数据等一系列的程序中通常我们可以很简单的通过 Scrapy 框架实现一个爬虫,抓取指定网站的内容或图片Scrapy官网文档:https://doc.scrapy.org/en/latest/ 框架图示 框架组件Scrapy Engine(引擎): 负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯,信号、数据传递等.Scheduler(调度器): 它负责接受引擎发送过来的Request请求,并按照一定的方式进行整理排列,入队,当引擎需要时,交还给引擎.Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求,并将其获取到的Responses交还给Scrapy Engine(引擎),由引擎交给Spider来处理.Spider（爬虫）：它负责处理所有Responses,从中分析提取数据,获取Item字段需要的数据,并将需要跟进的URL提交给引擎,再次进入Scheduler(调度器).Item Pipeline(管道)：它负责处理Spider中获取到的Item,并进行进行后期处理（详细分析、过滤、存储等）的地方.Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件.Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）. 数据流向引擎从Spider中获取到初始Requests.引擎将从Spider获取到的Requests放入调度器,并请求下一个要爬取的Requests.调度器返回下一个要爬取的Requests给引擎引擎将Requests通过下载器中间件转发给下载器(Downloader).一旦页面下载完毕,下载器生成一个该页面的Response,并将其通过下载中间件(返回(response)方向)发送给引擎.引擎从下载器中接收到Response并通过Spider中间件(输入方向)发送给Spider处理.Spider处理Response并返回爬取到的Item及(跟进的)新的Request给引擎.引擎将(Spider返回的)爬取到的Item交给ItemPipeline处理,将(Spider返回的)Request交给调度器,并请求下一个Requests（如果存在的话）.(从第一步)重复直到调度器中没有更多地Request. 总结一般我们的业务逻辑主要集中在spider的request的创建response的处理,item的实例化和使用pipeline的数据存储","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"docker命令详解","slug":"技术/2017-12-26-docker命令详解","date":"2017-12-26T12:00:00.000Z","updated":"2020-06-09T10:00:01.658Z","comments":true,"path":"2017/12/26/技术/2017-12-26-docker命令详解/","link":"","permalink":"https://ax-codes.github.io/2017/12/26/%E6%8A%80%E6%9C%AF/2017-12-26-docker%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"前言此次操作都是在unbantu17.01下进行,docker版本是17.10.0-ce,docker-compose是1.17.1. docker 存在的意义 使用dokcer加速本地开发和构建，开发人员可以构建、运行并分享Docker容器，容器可以在开发环境中构建，然后轻松地提交到测试环境中，并最终进入生产环境 能够让独立服务或应用程序在不同环境中，得到相同的运行结果。 用docker 创建隔离环境进行测试 docker 可以让开发者先在本机上构建一个复杂的程序测试，而不是一开始就在生产环境进行测试 目录 docker概念 docker的使用命令 操作docker镜像 启动容器 查看容器 保存和加载镜像 登录Docker Hub 发布docker镜像 构建镜像 docker概念 Docker 的常用文档:https://docs.docker.com/ Docker 镜像: 用户基于镜像来运行自己的容器，可以把镜像当做容器的『源代码』，镜像体积很小，易于分享、存储和更新 Registry: Docker 用 Registry 保存用户构建的镜像，Registry 分为公共和私有两种: Docker 公司运营的公共 Registry 叫做 Docker Hub，我们可以在上面注册账号，分享并保存自己的镜像。 可以在 Docker Hub 保存自己的私有镜像或者架设自己私有的 Registry Docker 容器: 把应用程序或服务打包放进去，容器是基于镜像启动的，容器中可以运行一个或多个进程。 镜像是 Docker 生命周期中的构建或打包阶段 容器则是启动或执行阶段 docker的使用命令1 docker 命令介绍 1234567891011121314151617181920212223242526272829303132docker --help管理命令: container 管理容器 image 管理镜像 network 管理网络命令： attach 介入到一个正在运行的容器 build 根据 Dockerfile 构建一个镜像 commit 根据容器的更改创建一个新的镜像 cp 在本地文件系统与容器中复制 文件/文件夹 create 创建一个新容器 exec 在容器中执行一条命令 images 列出镜像 kill 杀死一个或多个正在运行的容器 logs 取得容器的日志 pause 暂停一个或多个容器的所有进程 ps 列出所有容器 pull 拉取一个镜像或仓库到 registry push 推送一个镜像或仓库到 registry rename 重命名一个容器 restart 重新启动一个或多个容器 rm 删除一个或多个容器 rmi 删除一个或多个镜像 run 在一个新的容器中执行一条命令 search 在 Docker Hub 中搜索镜像 start 启动一个或多个已经停止运行的容器 stats 显示一个容器的实时资源占用 stop 停止一个或多个正在运行的容器 tag 为镜像创建一个新的标签 top 显示一个容器内的所有进程 unpause 恢复一个或多个容器内所有被暂停的进程 docker run命令:1234567891011121314151617181920212223242526272829303132333435363738394041docker run [OPTIONS] IMAGE [COMMAND] [ARG...] -d, --detach=false 指定容器运行于前台还是后台，默认为false -i, --interactive=false 打开STDIN，用于控制台交互 -t, --tty=false 分配tty设备，该可以支持终端登录，默认为false -u, --user=\"\" 指定容器的用户 -a, --attach=[] 登录容器（必须是以docker run -d启动的容器） -w, --workdir=\"\" 指定容器的工作目录 -c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 -e, --env=[] 指定环境变量，容器中可以使用该环境变量 -m, --memory=\"\" 指定容器的内存上限 -P, --publish-all=false 指定容器暴露的端口 -p, --publish=[] 指定容器暴露的端口 -h, --hostname=\"\" 指定容器的主机名 -v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录 --volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 --cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities --cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities --cidfile=\"\" 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 --cpuset=\"\" 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU --device=[] 添加主机设备给容器，相当于设备直通 --dns=[] 指定容器的dns服务器 --dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 --entrypoint=\"\" 覆盖image的入口点 --env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 --expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 --link=[] 指定容器间的关联，使用其他容器的IP、env等信息 --lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 --name=\"\" 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 --net=\"bridge\" 容器网络设置: bridge 使用docker daemon指定的网桥 host //容器使用主机的网络 container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 none 容器使用自己的网络（类似--net=bridge），但是不进行配置 --privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities --restart=\"no\" 指定容器停止后的重启策略: no：容器退出时不重启 on-failure：容器故障退出（返回值非零）时重启 always：容器退出时总是重启 --rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) --sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 2.更详细的功能参数配置 参数 解释 –api-enable-cors=false 开放远程API调用的 CORS 头信息。这个接口开关对想进行二次开发的上层应用提供了支持. -b, –bridge=”” 挂载已经存在的网桥设备到 Docker 容器里。注意，使用 none 可以停用容器里的网络. –bip=”” 使用 CIDR 地址来设定网络桥的 IP。注意，此参数和 -b 不能一起使用. -D, –debug=false 开启Debug模式。例如：docker -d -D -d, –daemon=false 开启Daemon模式. –dns=[] 强制容器使用DNS服务器.例如： docker -d –dns 8.8.8.8 –dns-search=[] 强制容器使用指定的DNS搜索域名.例如： docker -d –dns-search example.com -e, –exec-driver=”native” 强制容器使用指定的运行时驱动.例如：docker -d -e lxc -G, –group=”docker” 在后台运行模式下，赋予指定的Group到相应的unix socket上。注意，当此参数 –group 赋予空字符串时，将去除组信息。 -g, –graph=”/var/lib/docker” 配置Docker运行时根目录 -H, –host=[] 在后台模式下指定socket绑定，可以绑定一个或多个 tcp://host:port, unix:///path/to/socket, fd://* 或 fd://socketfd。例如：$ docker -H tcp://0.0.0.0:2375 ps 或者 $ export DOCKER_HOST=”tcp://0.0.0.0:2375” $ docker ps –icc=true 启用内联容器的通信. –ip=”0.0.0.0” 容器绑定IP时使用的默认IP地址. –ip-forward=true 启动容器的 net.ipv4.ip_forward. –iptables=true 启动Docker容器自定义的iptable规则. –mtu=0 设置容器网络的MTU值，如果没有这个参数，选用默认 route MTU，如果没有默认route，就设置成常量值 1500. -p, –pidfile=”/var/run/docker.pid” 后台进程PID文件路径. -r, –restart=true 重启之前运行中的容器. -s, –storage-driver=”” 强制容器运行时使用指定的存储驱动，例如,指定使用devicemapper, 可以这样：docker -d -s devicemapper –selinux-enabled=false 启用selinux支持 –storage-opt=[] 配置存储驱动的参数 –tls=false 启动TLS认证开关 –tlscacert=”/Users/dxiao/.docker/ca.pem” 通过CA认证过的的certificate文件路径 –tlscert=”/Users/dxiao/.docker/cert.pem” TLS的certificate文件路径 –tlskey=”/Users/dxiao/.docker/key.pem” TLS的key文件路径 –tlsverify=false 使用TLS并做后台进程与客户端通讯的验证 -v, –version=false 显示版本信息 *注意：其中带有[] 的启动参数可以指定多次，例如1docker run -a stdin -a stdout -a stderr -i -t ubuntu /bin/bash docker基本信息 查看系统内核 1uname -r 启动docker 境像 1systemctl start docker 3.查看docker版本 1docker verison 4.显示docker系统的信息 1docker info 操作docker镜像1.检索image 1docker search image-name 2.下载image 1docker pull image-name 3.列出镜像列表 1docker images 4.删除一个或者多个镜像 1docker rmi image-name 5.显示一个镜像的历史 1docker history image-name 6.通过容器创建镜像 从已经创建的容器中更新镜像，并且提交这个镜像 使用 Dockerfile 指令来创建一个新的镜像下面通过已存在的容器创建一个新的镜像。 1234567docker commit -m=\"First Image\" -a=\"keke\" 7a15f99695c0 keke/unbantu:17.10.0上面命令参数说明：* -m 提交的描述信息* -a 指定镜像作者* 7a15f99695c0 记住这个是容器id，不是镜像id* keke/unbantu:17.10.0 创建的目标镜像名 在Docker 注册账户，发布的镜像都在这个页面里展示 将上面做的镜像unbantu，起个新的名字unbantu-test 1docker tag keke/unbantu:17.10.0 keke/unbantu-test:lastest 登录docker 1docker login 4.上传unbantu镜像1docker push keke/unbantu-test:lastest 启动容器docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。 1.在容器中安装新的程序12345docker run image-name apt-get install -y -name``` 2.在容器中运行\"echo\"命令，输出\"hello word\"```shelldocker run image-name echo \"hello word\"3.交互式进入容器中1docker run -i -t image_name /bin/bash注意:在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失. 查看容器1.列出当前所有正在运行的container1docker ps 2.列出所有的container1docker ps -a 3.列出最近一次启动的container1docker ps -l 4.保存对容器的修改当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。 1.保存对容器的修改; -a, –author=”” Author; -m, –message=”” Commit message1docker commit ID new-image-name 5.操作容器 1.删除所有容器1docker rm `docker ps -a -q` 2.删除单个容器; -f, –force=false; -l, –link=false Remove the specified link and not the underlying container; -v, –volumes=false Remove the volumes associated to the container1docker rm Name/ID 3.停止、启动、杀死一个容器123docker stop Name/ID docker start Name/ID docker kill Name/ID 4.从一个容器中取日志; -f, –follow=false Follow log output; -t, –timestamps=false Show timestamps1docker logs Name/ID 5.列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的1docker diff Name/ID 6.显示一个运行的容器里面的进程信息1docker top Name/ID 7.从容器里面拷贝文件/目录到本地一个路径 12docker cp Name:/container-path to-path docker cp ID:/container-path to-path 8.重启一个正在运行的容器; -t, –time=10 Number of seconds to try to stop for before killing the container, Default=101docker restart Name/ID 9.附加到一个运行的容器上面; –no-stdin=false Do not attach stdin; –sig-proxy=true Proxify all received signal to the process1docker attach ID #重新启动并运行一个交互式会话shell注意：使用这个命令可以挂载正在后台运行的容器，在开发应用的过程中运用这个命令可以随时观察容器內进程的运行状况. 保存和加载镜像当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。 1.保存镜像到一个tar包; -o, –output=”” Write to an file1docker save image-name -o file-path 2.加载一个tar包格式的镜像; -i, –input=”” Read from a tar archive file1docker load -i file-path 3.从机器A拷贝到机器B12345docker save image-name &gt; /home/keke/main.tar*使用scp将main.tar拷到机器A上:docker load &lt; /home/keke/main.tar 登录1.登陆registry server; -e, –email=”” Email; -p, –password=”” Password; -u, –username=”” Username 1docker login 发布docker镜像1docker push new-image-name 构建镜像 Dockerfile文件使用 docker build命令会根据Dockerfile文件及上下文构建新Docker镜像。构建上下文是指Dockerfile所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以，构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。 构建镜像 将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像： 12$ ~/Downloads/hello-system$ sudo docker build .Sending build context to Docker daemon 70.14kB 说明：构建会在Docker后台守护进程（daemon）中执行，而不是CLI中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将Dockerfile文件放在该目录下。 在构建上下文中使用的Dockerfile文件，是一个构建指令文件。为了提高构建性能，可以通过.dockerignore文件排除上下文目录下，不需要的文件和目录。 Dockerfile一般位于构建上下文的根目录下，也可以通过-f指定该文件的位置： 1$ sudo docker build -f /home/keke/Downloads/hello-system/Dockerfile . 构建时,还可以通过-t参数指定构建成后,镜像的仓库,标签等： 镜像标签 1$ ~/Downloads/hello-system$ sudo docker build -t keke/myapp . 如果存在多个仓库下，或使用多个镜像标签，就可以使用多个-t参数： 1$ docker build -t keke/myapp:1.0.2 -t keke/myapp:latest . 在Docker守护进程执行Dockerfile中的指令前，首先会对Dockerfile进行语法检查，有语法错误时会返回：123$ docker build -t test/myapp .Sending build context to Docker daemon 2.048 kBError response from daemon: Unknown instruction: RUNCMD Dockerfile文件格式Dockerfile文件中指令不区分大小写，但为了更易区分，约定使用大写形式。 Docker 会依次执行Dockerfile中的指令，文件中的第一条指令必须是FROM，FROM指令用于指定一个基础镜像。 FROM指令用于指定其后构建新镜像所使用的基础镜像。FROM指令必是Dockerfile文件中的首条命令，启动构建流程后，Docker将会基于该镜像构建新镜像，FROM后的命令也会基于这个基础镜像。 Dockerfile文件格式如下： 12# CommentINSTRUCTION arguments Dockerfile文件中指令不区分大小写，但为了更易区分，约定使用大写形式。 Docker 会依次执行Dockerfile中的指令，文件中的第一条指令必须是FROM,FROM指令用于指定一个基础镜像。 FROM语法格式为：1FROM &lt;image&gt; 或 FROM &lt;image&gt;:&lt;tag&gt; 通过FROM指定的镜像，可以是任何有效的基础镜像。FROM有以下限制： FROM必须是Dockerfile中第一条非注释命令在一个Dockerfile文件中创建多个镜像时，FROM可以多次出现。只需在每个新命令FROM之前，记录提交上次的镜像ID。tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像 RUNRUN用于在镜像容器中执行命令,其有以下两种命令执行方式：shell执行在这种方式会在shell中执行命令，Linux下默认使用/bin/sh -c，Windows下使用cmd /S /C。注意：通过SHELL命令修改RUN所使用的默认shell 1RUN &lt;command&gt; exec执行1RUN [\"executable\", \"param1\", \"param2\"]RUN可以执行任何命令，然后在当前镜像上创建一个新层并提交。提交后的结果镜像将会用在Dockerfile文件的下一步。 通过RUN执行多条命令时，可以通过\\换行执行：12RUN /bin/bash -c 'source $HOME/.bashrc; \\echo $HOME' 也可以在同一行中，通过分号分隔命令：1RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定–no-cache参数，如：docker build –no-cache。 CMDCMD用于指定在容器启动时所要执行的命令。CMD有以下三种格式： 123CMD [\"executable\",\"param1\",\"param2\"]CMD [\"param1\",\"param2\"]CMD command param1 param2 CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。CMD与RUN在功能实现上也有相似之处。如：1docker run -t -i keke/static /bin/true 等价于：cmd [\"/bin/true\"] CMD在Dockerfile文件中仅可指定一次，指定多次时，会覆盖前的指令。另外，docker run命令也会覆盖Dockerfile中CMD命令。如果docker run运行容器时，使用了Dockerfile中CMD相同的命令，就会覆盖Dockerfile中的CMD命令。如，我们在构建镜像的Dockerfile文件中使用了如下指令：1CMD [\"/bin/bash\"] 使用docker build构建一个新镜像，镜像名为keke/test。构建完成后，使用这个镜像运行一个新容器，运行效果如下：1sudo docker run -i -t keke/test 在使用docker run运行容器时，我们并没有在命令结尾指定会在容器中执行的命令，这时Docker就会执行在Dockerfile的CMD中指定的命令。如果不想使用CMD中指定的命令，就可以在docker run命令的结尾指定所要运行的命令：1sudo docker run -i -t keke/test /bin/ps这时，docker run结尾指定的/bin/ps命令覆盖了Dockerfile的CMD中指定的命令. ENTRYPOINTENTRYPOINT用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过ENTRYPOINT指定的程序都会被设置为默认程序。ENTRYPOINT有以下两种形式：12ENTRYPOINT [\"executable\", \"param1\", \"param2\"]ENTRYPOINT command param1 param2 ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。docker run运行容器时指定的参数都会被传递给ENTRYPOINT，且会覆盖CMD命令指定的参数。如，执行docker run -d时， -d参数将被传递给入口点。也可以通过docker run –entrypoint重写ENTRYPOINT入口点。如：可以像下面这样指定一个容器执行程序：1ENTRYPOINT [\"/usr/bin/nginx\"] 完整构建代码：1234567FROM ...MAINTAINER keke \"2536495681@gmail.com\"RUN ...# 指定容器内的程序将会使用容器的指定端口# 配合 docker run -pEXPOSE ... 使用docker build构建镜像，并将镜像指定为keke/test： 1sudo docker build -t=\"itbilu/test\" . 构建完成后，使用keke/test启动一个容器：1sudo docker run -i -t keke/test -g \"daemon off;\"在运行容器时，我们使用了-g “daemon off;” ，这个参数将会被传递给ENTRYPOINT，最终在容器中执行的命令为/usr/sbin/nginx -g “daemon off;” 。 EXPOSEEXPOSE用于指定容器在运行时监听的端口：1EXPOSE &lt;port&gt; [&lt;port&gt;...] EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口。 RUN: 指定镜像被构建时要运行的命令 CMD: 指定容器被启动时要运行的命令 ENTRYPOINT: 同 CMD ，但不会被 docker run -t 覆盖 WORKDIR: CMD/ENTRYPOINT 会在这个目录下执行 VOLUME:创建挂载点，即向基于所构建镜像创始的容器添加卷 ADD:用于复制构建环境中的文件或目录到镜像中 COPY:同样用于复制构建环境中的文件或目录到镜像中 1docker history images-name 1.从新镜像启动容器1docker run -d -p 4000:80 --name [name] #可以在 Dokcer 宿主机上指定一个具体的端口映射到容器的80端口上 守护容器docker run -d container-name #创建守护容器 docker top container-name #查看容器内进程 docker exec container-name touch a.txt #在容器内部运行进程 docker stop container-name #停止容器 关于docker觉得此文章不错可以给我star！如果还有遇到问题可以加我微信Sen0676备注下来自github,进go实战群详细交流！ 参考资料官方英文资源 Docker官网：http://www.docker.com Docker windows入门：https://docs.docker.com/windows/ Docker Linux 入门：https://docs.docker.com/linux/ Docker mac 入门：https://docs.docker.com/mac/ Docker 用户指引：https://docs.docker.com/engine/userguide/ Docker 官方博客：http://blog.docker.com/ Docker Hub: https://hub.docker.com/ Docker开源： https://www.docker.com/open-source 中文资源 Docker中文网站：http://www.docker.org.cn Docker中文文档：http://www.dockerinfo.net/document Docker安装手册：http://www.docker.org.cn/book/install.html 一小时Docker教程 ：https://blog.csphere.cn/archives/22 Docker中文指南：http://www.widuu.com/chinese_docker/index.html 其它资源 Docker 快速手册！ Docker 教程 MySQL Docker 单一机器上如何配置自动备份 Docker — 从入门到实践 docker问答 moby https://wiki.openstack.org/wiki/Docker https://wiki.archlinux.org/index.php/Docker 引用自 github:https://github.com/KeKe-Li/docker-directive","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"docker","slug":"docker","permalink":"https://ax-codes.github.io/tags/docker/"}]},{"title":"error LNK2038 检测到“_ITERATOR_DEBUG_LEVEL”的不匹配项 值“0”不匹配值“2”(service.obj 中)","slug":"技术/2017-02-26-error LNK2038 检测到“_ITERATOR_DEBUG_LEVEL”的不匹配项 值“0”不匹配值“2”(service.obj 中)","date":"2017-02-26T12:00:00.000Z","updated":"2020-06-09T10:00:01.657Z","comments":true,"path":"2017/02/26/技术/2017-02-26-error LNK2038 检测到“_ITERATOR_DEBUG_LEVEL”的不匹配项 值“0”不匹配值“2”(service.obj 中)/","link":"","permalink":"https://ax-codes.github.io/2017/02/26/%E6%8A%80%E6%9C%AF/2017-02-26-error%20LNK2038%20%E6%A3%80%E6%B5%8B%E5%88%B0%E2%80%9C_ITERATOR_DEBUG_LEVEL%E2%80%9D%E7%9A%84%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%A1%B9%20%E5%80%BC%E2%80%9C0%E2%80%9D%E4%B8%8D%E5%8C%B9%E9%85%8D%E5%80%BC%E2%80%9C2%E2%80%9D(service.obj%20%E4%B8%AD)/","excerpt":"","text":"前言windows vs2012编译c++项目报错 报错log12345671&gt; iconv-wrapper.lib(encoding.obj) : 找到 MSIL .netmodule 或使用 /GL 编译的模块；正在使用 /LTCG 重新启动链接；将 /LTCG 添加到链接命令行以改进链接器性能1&gt;LINK : warning LNK4075: 忽略“/INCREMENTAL”(由于“/LTCG”规范)1&gt;service.obj : warning LNK4075: 忽略“/EDITANDCONTINUE”(由于“/OPT:LBR”规范)1&gt;iconv-wrapper.lib(encoding.obj) : error LNK2038: 检测到“_ITERATOR_DEBUG_LEVEL”的不匹配项: 值“0”不匹配值“2”(service.obj 中)1&gt;iconv-wrapper.lib(encoding.obj) : error LNK2038: 检测到“RuntimeLibrary”的不匹配项: 值“MT_StaticRelease”不匹配值“MDd_DynamicDebug”(service.obj 中)1&gt;LINK : warning LNK4098: 默认库“LIBCMT”与其他库的使用冲突；请使用 /NODEFAULTLIB:library1&gt;E:\\work\\webserver-boost-sqm\\platform\\windows\\\\..\\..\\build\\dbin\\webserver-sqm-unicom-gd.exe : fatal error LNK1319: 检测到 2 个不匹配项 解决检查链接库,可能原因是编译debug但是使用了release版本的库,或者编译release使用了debug版本的库","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"自动同步远程hexo博客脚本","slug":"技术/2017-01-19-自动同步远程hexo博客脚本","date":"2017-01-19T12:00:00.000Z","updated":"2020-06-09T10:00:01.656Z","comments":true,"path":"2017/01/19/技术/2017-01-19-自动同步远程hexo博客脚本/","link":"","permalink":"https://ax-codes.github.io/2017/01/19/%E6%8A%80%E6%9C%AF/2017-01-19-%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E8%BF%9C%E7%A8%8Bhexo%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC/","excerpt":"","text":"前言因为每次电脑装新系统都要同步博客,所以写个小的自动化脚本只想脚本前需要先生成ssh密钥放到对应到ssh服务器,和安装node,mac如果安装了brew的话可以直接”sudo brew install node “ 安装node执行路径:在你要放博客到文件夹里执行 脚本12345678910111213141516#安装hexonpm install hexo-cli -gnpm install hexo --savegit initgit remote add origin git@gitee.com:AXSS/hexo.git#这是hexo博客源码地址git pullgit fetch --all git reset --hard origin/master hexo gcd ./publicrm -rf ./git initgit remote add origin git@gitee.com:AXSS/AXSS.git#hexo发布(生成)文件地址git pullgit fetch --all git reset --hard origin/master","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"windows编写的shell脚本在linux执行编码错误问题","slug":"技术/2017-01-16-windows编写的shell脚本在linux执行编码错误问题","date":"2017-01-16T12:00:00.000Z","updated":"2020-06-09T10:00:01.656Z","comments":true,"path":"2017/01/16/技术/2017-01-16-windows编写的shell脚本在linux执行编码错误问题/","link":"","permalink":"https://ax-codes.github.io/2017/01/16/%E6%8A%80%E6%9C%AF/2017-01-16-windows%E7%BC%96%E5%86%99%E7%9A%84shell%E8%84%9A%E6%9C%AC%E5%9C%A8linux%E6%89%A7%E8%A1%8C%E7%BC%96%E7%A0%81%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言在windwos下用记事本编写了个shell脚本,拿到cygwin下运行没问题,但是拿到linux下运行就出问题 报错日志1./beijingsqm_update.sh: line 13: syntax error near unexpected token `$'\\r' 解决方法使用vi打开该脚本设置fileformat(ff)1:set ff=unix 保存退出1:wq","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"mac使用anyconnect连接vpn方法","slug":"技术/2016-01-16-mac使用anyconnect连接vpn","date":"2016-01-16T12:00:00.000Z","updated":"2020-06-09T10:00:01.637Z","comments":true,"path":"2016/01/16/技术/2016-01-16-mac使用anyconnect连接vpn/","link":"","permalink":"https://ax-codes.github.io/2016/01/16/%E6%8A%80%E6%9C%AF/2016-01-16-mac%E4%BD%BF%E7%94%A8anyconnect%E8%BF%9E%E6%8E%A5vpn/","excerpt":"","text":"前言mac使用anyconnect连接vpn方法下载:直接appstore下载或者在官网下载:https://software.cisco.com/download/home/283000185 安装1. 2. 3. 4. 5.注意:这里需要全选 6. 7. 8. 9. 10. 11. 连接1.输入vpnip或者域名 2.输入vpn用户名 3.输入该用户名密码 4.出现下图表示连接成功 备注anyconnect版本不一样可能安装的方式会不一样,主要都是下一步一下步就行,安装的步骤五记得全选就行","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"效率工具/插件","slug":"效率工具-插件","permalink":"https://ax-codes.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"其他工具/插件","slug":"其他工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"电影网站","slug":"生活/2015-07-28-电影网站","date":"2015-07-28T00:00:00.000Z","updated":"2020-06-09T10:00:01.876Z","comments":true,"path":"2015/07/28/生活/2015-07-28-电影网站/","link":"","permalink":"https://ax-codes.github.io/2015/07/28/%E7%94%9F%E6%B4%BB/2015-07-28-%E7%94%B5%E5%BD%B1%E7%BD%91%E7%AB%99/","excerpt":"","text":"且听风铃点击跳转","categories":[{"name":"生活","slug":"生活","permalink":"https://ax-codes.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://ax-codes.github.io/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}]},{"title":"图片","slug":"生活/2015-07-27-图片","date":"2015-07-27T00:00:00.000Z","updated":"2020-06-09T10:00:01.874Z","comments":true,"path":"2015/07/27/生活/2015-07-27-图片/","link":"","permalink":"https://ax-codes.github.io/2015/07/27/%E7%94%9F%E6%B4%BB/2015-07-27-%E5%9B%BE%E7%89%87/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"https://ax-codes.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://ax-codes.github.io/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}]},{"title":"使用indent美化你的代码","slug":"技术/2015-07-26-使用indent美化你的代码","date":"2015-07-26T00:00:00.000Z","updated":"2020-06-09T10:00:01.637Z","comments":true,"path":"2015/07/26/技术/2015-07-26-使用indent美化你的代码/","link":"","permalink":"https://ax-codes.github.io/2015/07/26/%E6%8A%80%E6%9C%AF/2015-07-26-%E4%BD%BF%E7%94%A8indent%E7%BE%8E%E5%8C%96%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"","text":"使用参数说明:http://www.worldhello.net/doc/program_rules/indent.html 常见风格indent参数设置:http://www.worldhello.net/doc/program_rules/appendix-indent.html 参考：C Style: Standards and Guidelines：http://syque.com/cstyle/index.htmGNU Coding Standards：http://www.gnu.org/prep/standards/standards.html几种常见风格配置:http://www.gnu.org/software/indent/manual/html_section/indent_4.html#SEC4","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"C++Socket通信","slug":"技术/2015-07-20-C++Socket","date":"2015-07-20T00:00:00.000Z","updated":"2020-06-09T10:00:01.636Z","comments":true,"path":"2015/07/20/技术/2015-07-20-C++Socket/","link":"","permalink":"https://ax-codes.github.io/2015/07/20/%E6%8A%80%E6%9C%AF/2015-07-20-C++Socket/","excerpt":"","text":"什么是socket使用标准Unix 文件描述符 (file descriptor) 和其它程序通讯的方式Unix 程序在执行任何形式的 I/O 的时候，程序是在读或者写一个文件描述符,所以socket就是一个文件描述符号socket从哪里获取:从系统获取socket,然后进行文件读或写操作 Internet的两个套接字类型tcp:tcp我们也称之为流协议,他是一种安全,有序的网络协议,因为他使用了”传输控制协议(每次通信都需要三次握手)”,我们常见的tcp/ip就是指流协议,ip处理internet的路由而已;常见的用tcp协议通信的有:telentudp:udp我们称之为数据报协议,他是一种无连接和不保证数据的网络协议,因为他给连接到客户端发包,然后客户端收没收到,乱不乱序是不管的,不会像tcp客户端没有收到会重新发送,常见的udp协议通信的有:ftp解决udp丢包问题:每次发送一个数据包到客户端都监听看客户端是否主动响应是否接收到包,如果超时或者错误则重新发送 服务端操作socket步骤 创建socket(socket) bind ip和port(bind) 监听(listen) 请求到来后根据连接请求,并返回一个socket(accept) 用返回的socket和客户端通信(send/recv) 返回,等待另一端接受请求 关闭(close) 客户端操作socket步骤 创建socket(socket) 向服务端发送请求(content) 和服务端进行通信(send/recv) 关闭套接字(close)","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"C++11中原子操作","slug":"技术/2015-07-16-C++11中原子操作","date":"2015-07-16T00:00:00.000Z","updated":"2020-06-09T10:00:01.635Z","comments":true,"path":"2015/07/16/技术/2015-07-16-C++11中原子操作/","link":"","permalink":"https://ax-codes.github.io/2015/07/16/%E6%8A%80%E6%9C%AF/2015-07-16-C++11%E4%B8%AD%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","excerpt":"","text":"前言在以前我们操作同一个变量的时候需要加锁,保证多线程同时操作的数据的准确性,但是加了锁后会导致性能的大幅减少,所以这种情况下我们可以将变量的类型定义为atomic,这样既能保证了不会报错,也保证了数据的准确性在c++98中多线程操作数据有可能不会报错,但是不能保证数据的准确性 使用boost12#include &lt;boost/atomic.hpp&gt;using namespace boost;c++1112#include &lt;atomic&gt;using namespace std; 通过一个atomic泛型类来定义了一系列关于该值的原子操作这些原子操作不可被打断原子操作数最好在初始化时赋值，否在并发时会发生不可预知的错误 actomic:整形:char, signed char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long, char16_t, char32_t, wchar_tactomic&lt;T*&gt;:指针类型 c++98多线程操作数据同时读:不用加有写有读:需要加同时写:需要加","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"网站的演变过程(图片)","slug":"技术/2015-07-10-网站的演变过程(图片)","date":"2015-07-10T00:00:00.000Z","updated":"2020-06-09T10:00:01.633Z","comments":true,"path":"2015/07/10/技术/2015-07-10-网站的演变过程(图片)/","link":"","permalink":"https://ax-codes.github.io/2015/07/10/%E6%8A%80%E6%9C%AF/2015-07-10-%E7%BD%91%E7%AB%99%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B(%E5%9B%BE%E7%89%87)/","excerpt":"","text":"网站的演变过程(图片)","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"Windows CMD中git push错误Permission denied (publickey)的解决办法","slug":"技术/2015-07-02-Windows CMD中git push错误Permission denied (publickey)的解决办法","date":"2015-07-02T00:00:00.000Z","updated":"2020-06-09T10:00:01.632Z","comments":true,"path":"2015/07/02/技术/2015-07-02-Windows CMD中git push错误Permission denied (publickey)的解决办法/","link":"","permalink":"https://ax-codes.github.io/2015/07/02/%E6%8A%80%E6%9C%AF/2015-07-02-Windows%20CMD%E4%B8%ADgit%20push%E9%94%99%E8%AF%AFPermission%20denied%20(publickey)%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"前言Windows CMD中git push错误Permission denied (publickey)但git终端可以的解决办法 解决方法把id_rsa，id_rsa.pub拷贝到git.ssh目录下,然后重新打开终端push发现成功","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"VS导入自定义外部工具脚本","slug":"技术/2015-06-29-VS导入自定义外部工具脚本","date":"2015-06-29T00:00:00.000Z","updated":"2020-06-09T10:00:01.630Z","comments":true,"path":"2015/06/29/技术/2015-06-29-VS导入自定义外部工具脚本/","link":"","permalink":"https://ax-codes.github.io/2015/06/29/%E6%8A%80%E6%9C%AF/2015-06-29-VS%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/","excerpt":"","text":"前言在vs工具面板添加我们需要经常处理的命令,或者一些加快效率的脚本(比如:用批处理调用lua的一些生成代码的脚本,一些操作数据库的脚本等),将这些功能集成进vs,从而增加开发效率由于一个一个新增比较慢,所以我们定义好脚本需要的时候导入一次就行 效果 .vssettings内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\"?&gt;&lt;UserSettings&gt; &lt;ApplicationIdentity version=\"12.0\" /&gt; &lt;ToolsOptions /&gt; &lt;Category name=\"Environment_Group\" RegisteredName=\"Environment_Group\"&gt; &lt;Category name=\"Environment_ExternalTools\" Category=\"&#123;E8FAE9E8-FBA2-4474-B134-AB0FFCFB291D&#125;\" Package=\"&#123;DA9FB551-C724-11d0-AE1F-00A0C90FFFC3&#125;\" RegisteredName=\"Environment_ExternalTools\" PackageName=\"Visual Studio Environment Package\"&gt; &lt;ExternalTools&gt; &lt;UserCreatedTool&gt; &lt;Arguments&gt;&lt;/Arguments&gt; &lt;CloseOnExit&gt;true&lt;/CloseOnExit&gt; &lt;Command&gt;cmd&lt;/Command&gt; &lt;Index&gt;0&lt;/Index&gt; &lt;InitialDirectory&gt;&lt;/InitialDirectory&gt; &lt;IsGUIapp&gt;false&lt;/IsGUIapp&gt; &lt;NameID&gt;0&lt;/NameID&gt; &lt;Package&gt;&#123;00000000-0000-0000-0000-000000000000&#125;&lt;/Package&gt; &lt;PromptForArguments&gt;true&lt;/PromptForArguments&gt; &lt;SaveAllDocs&gt;true&lt;/SaveAllDocs&gt; &lt;Title&gt;1-cmd1&lt;/Title&gt; &lt;Unicode&gt;false&lt;/Unicode&gt; &lt;UseOutputWindow&gt;true&lt;/UseOutputWindow&gt; &lt;UseTaskList&gt;false&lt;/UseTaskList&gt; &lt;/UserCreatedTool&gt; &lt;UserCreatedTool&gt; &lt;Arguments&gt;&lt;/Arguments&gt; &lt;CloseOnExit&gt;true&lt;/CloseOnExit&gt; &lt;Command&gt;$(SolutionDir)..\\cmd&lt;/Command&gt; &lt;Index&gt;1&lt;/Index&gt; &lt;InitialDirectory&gt;&lt;/InitialDirectory&gt; &lt;IsGUIapp&gt;false&lt;/IsGUIapp&gt; &lt;NameID&gt;0&lt;/NameID&gt; &lt;Package&gt;&#123;00000000-0000-0000-0000-000000000000&#125;&lt;/Package&gt; &lt;PromptForArguments&gt;true&lt;/PromptForArguments&gt; &lt;SaveAllDocs&gt;true&lt;/SaveAllDocs&gt; &lt;Title&gt;2-cmd2&lt;/Title&gt; &lt;Unicode&gt;false&lt;/Unicode&gt; &lt;UseOutputWindow&gt;true&lt;/UseOutputWindow&gt; &lt;UseTaskList&gt;false&lt;/UseTaskList&gt; &lt;/UserCreatedTool&gt; &lt;UserCreatedTool&gt; &lt;Arguments&gt;&lt;/Arguments&gt; &lt;CloseOnExit&gt;false&lt;/CloseOnExit&gt; &lt;Command&gt;$(SolutionDir)..\\cmd&lt;/Command&gt; &lt;Index&gt;2&lt;/Index&gt; &lt;InitialDirectory&gt;&lt;/InitialDirectory&gt; &lt;IsGUIapp&gt;false&lt;/IsGUIapp&gt; &lt;NameID&gt;0&lt;/NameID&gt; &lt;Package&gt;&#123;00000000-0000-0000-0000-000000000000&#125;&lt;/Package&gt; &lt;PromptForArguments&gt;true&lt;/PromptForArguments&gt; &lt;SaveAllDocs&gt;true&lt;/SaveAllDocs&gt; &lt;Title&gt;3-cmd3&lt;/Title&gt; &lt;Unicode&gt;false&lt;/Unicode&gt; &lt;UseOutputWindow&gt;true&lt;/UseOutputWindow&gt; &lt;UseTaskList&gt;false&lt;/UseTaskList&gt; &lt;/UserCreatedTool&gt; &lt;ExcludeRegisteredTool SourceKeyName=\"Create GUID\" /&gt; &lt;ExcludeRegisteredTool SourceKeyName=\"Error Loo&amp;amp;kup\" /&gt; &lt;ExcludeRegisteredTool SourceKeyName=\"PreEmptive Dot&amp;amp;fuscator and Analytics\" /&gt; &lt;ExcludeRegisteredTool SourceKeyName=\"Sp&amp;amp;y++\" /&gt; &lt;ExcludeRegisteredTool SourceKeyName=\"Spy++ (x64)\" /&gt; &lt;/ExternalTools&gt; &lt;/Category&gt; &lt;/Category&gt;&lt;/UserSettings&gt; 节点解释ApplicationIdentity version=”12.0”:表示当前的vs版本,我的是vs2013,可根据自己的情况切换 2:表示第几个UserCreatedTool子节点的解释如下图所示,在工具-&gt;外部工具即可显示","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"ubuntu下常用的软件安装,配置","slug":"技术/2015-06-19-ubuntu下常用的软件安装,配置","date":"2015-06-19T00:00:00.000Z","updated":"2020-06-09T10:00:01.626Z","comments":true,"path":"2015/06/19/技术/2015-06-19-ubuntu下常用的软件安装,配置/","link":"","permalink":"https://ax-codes.github.io/2015/06/19/%E6%8A%80%E6%9C%AF/2015-06-19-ubuntu%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85,%E9%85%8D%E7%BD%AE/","excerpt":"","text":"阿里云服务器设置开放端口控制台-&gt;云服务器ECS-&gt;网络和安全-&gt;安全组-&gt;选择对应的安全组的管理实例-&gt;选择安全组规则-&gt;新增或者删除授权,如下图 mysqlmysql的默认端口3306命令:12345678910111213141516171819202122232425262728293031323334353637383940414243444546sudo apt-get install mysql-server-5.7 #这里需要输入两次密码sudo apt-get install mysql-client-5.7sudo apt-get install libmysqlclient-dev-5.7sudo netstat -tap | grep mysql #校验mysql是否安装成功show databases;use mysql;show tables;describe 表名;#启动mysql：#方式一：/etc/init.d/mysql start#方式二：sudo start mysql#方式三：sudo service mysql start#停止mysql：#方式一：/etc/init.d/mysql stop #方式二：sudo stop mysql#方式三：sudo service mysql stop#重启mysql：#方式一：/etc/init.d/mysql restart#方式二：sudo restart mysql#方式三：sudo service mysql restart#查看版本号select version();#mysql授权访问vi /etc/mysql/mysql.conf.d/mysqld.cnf 将 bind-address = 127.0.0.1注销​重启mysqlgrant all privileges on *.* to 'root'@'%' identified by 'xxxxxxx';#%表示所有机器 xxxxxx:密码flush privileges;​重新连接应该就可以了如果没使用包安管理工具安装的话,有的方法可能没用,找到配置文件操作的话比较保险 ftp服务器配置ftp的默认端口:21 netstat -apn|grep ftp 123456789101112131415161718192021#使用下列命令安装sudo apt-get install vsftpd#安装完后，ftp的配置文件在/etc/vsftpd.conf#可以使用下列命令来打开，关闭，重启ftp服务/etc/init.d/vsftpd start/etc/init.d/vsftpd stop/etc/init.d/vsftpd restart#默认安装ftp的配置路径和文件的解释(部分路径可能需要修改)```shell/usr/sbin/vsftpd ---- VSFTPD的主程序/etc/init.d/vsftpd ---- 启动脚本/etc/vsftpd.conf ---- 主配置文件/etc/pam.d/vsftpd ---- PAM认证文件/etc/vsftpd.ftpusers ---- 禁止使用VSFTPD的用户列表文件/etc/vsftpd.user_list ---- 禁止或允许使用VSFTPD的用户列表文件/var/ftp ---- 匿名用户主目录/var/ftp/pub ---- 匿名用户的下载目录 配置vsftpd.conf编辑/etc/vsftpd.conf文件: #表示使用本地用户登录到ftp时的默认目录local_root=/ #表示匿名用户登录到ftp时的默认目录anon_root=/ 查看端口情况12netstat -apn|grep 端口号netstat -tunlp |grep 端口号 压缩解压1234567891011121314151617181920212223242526272829303132333435363738ZIP:zip是比较常用的文档压缩格式，最大的有点是跨平台，缺点是支持的压缩率不是很高。 #压缩zip -r studio.zip directory_to_compress#解压unzip studio.zipTAR:好处是只消耗非常少的CPU及时间打包，只是一个打包工具，并不负责压缩。#压缩tar -cvf studio.tar directory_to_compress#解包到当前目录下tar -xvf studio.tar#到指定目录下tar -xvf studio.tar -C /tmp/extract/TAR.GZ:压缩时不会占用太多的CPU，就可以得到一个非常理想的压缩率。 #压缩tar -zcvf studio.tar.gz directory_to_compress#解压到当前目录tar -zxvf studio.tar.gz#到指定目录tar -zxvf studio.tar.gz -C /tmp/extract/TAR.BZ2:这种压缩格式是这几种方式中压缩率最好的#压缩tar -jcvf studio.tar.bz2 directory_to_compress#解压到当前目录tar -jxvf studio.tar.bz2#到指定目录tar -jxvf studio.tar.bz2 -C /tmp/extract/","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"}]},{"title":"ubuntu apt-install 报Unable to locate package的解决方法","slug":"技术/2015-06-14-ubuntu apt-install 报Unable to locate package的解决方法","date":"2015-06-14T00:00:00.000Z","updated":"2020-06-09T10:00:01.625Z","comments":true,"path":"2015/06/14/技术/2015-06-14-ubuntu apt-install 报Unable to locate package的解决方法/","link":"","permalink":"https://ax-codes.github.io/2015/06/14/%E6%8A%80%E6%9C%AF/2015-06-14-ubuntu%20apt-install%20%E6%8A%A5Unable%20to%20locate%20package%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言ubuntu apt-install 报Unable to locate package的解决方法 情景使用新买的阿里云ubuntu服务器用apt-get install的时候报错 解决方法执行1sudo apt-get update然后就可以安装了","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"}]},{"title":"linux 下root无法登录ftp问题","slug":"技术/2015-06-12-linux 下root无法登录ftp问题","date":"2015-06-12T00:00:00.000Z","updated":"2020-06-09T10:00:01.625Z","comments":true,"path":"2015/06/12/技术/2015-06-12-linux 下root无法登录ftp问题/","link":"","permalink":"https://ax-codes.github.io/2015/06/12/%E6%8A%80%E6%9C%AF/2015-06-12-linux%20%E4%B8%8Broot%E6%97%A0%E6%B3%95%E7%99%BB%E5%BD%95ftp%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言linux 下root无法登录ftp问题 解决将vim /ect/ftpusers 下的root注释然后 /ect/init.d/vsftpd restart 即可","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"}]},{"title":"Hexo编译和提交git的python脚本","slug":"技术/2015-06-03-Hexo编译和提交git的python脚本","date":"2015-06-03T00:00:00.000Z","updated":"2020-06-09T10:00:01.624Z","comments":true,"path":"2015/06/03/技术/2015-06-03-Hexo编译和提交git的python脚本/","link":"","permalink":"https://ax-codes.github.io/2015/06/03/%E6%8A%80%E6%9C%AF/2015-06-03-Hexo%E7%BC%96%E8%AF%91%E5%92%8C%E6%8F%90%E4%BA%A4git%E7%9A%84python%E8%84%9A%E6%9C%AC/","excerpt":"","text":"前言Hexo编译和提交git的python脚本环境:windows python脚步存放路径:hexo博客的根目录(执行hexo s或者hexo g的目录)运行:python push.py(push.py是你的文件名) 脚本12345678910111213141516171819import osprint('===开始执行===')os.system(\"hexo g\")print('===git add .===')os.system(\"git add .\")print(\"===git commit -am 'ax'===\")os.system(\"git commit -am 'ax'\")print('===git push origin master===')os.system(\"git push origin master\")print('===cd public===')os.chdir('.\\\\public')print('===git add .===')os.system(\"git add .\")print(\"===git commit -am 'ax'===\")os.system(\"git commit -am 'ax'\")print('===git push origin master===')os.system(\"git push origin master\")print('===执行结束===') 备注如果在运行的时候报Permission denied (publickey)这个错误的话,可以这样解决:把id_rsa，id_rsa.pub拷贝到git.ssh目录下","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"Hexo更新源文件和部署文件的python脚本","slug":"技术/2015-05-27-Hexo同时更新源文件和部署文件的python脚本","date":"2015-05-27T00:00:00.000Z","updated":"2020-06-09T10:00:01.624Z","comments":true,"path":"2015/05/27/技术/2015-05-27-Hexo同时更新源文件和部署文件的python脚本/","link":"","permalink":"https://ax-codes.github.io/2015/05/27/%E6%8A%80%E6%9C%AF/2015-05-27-Hexo%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6%E7%9A%84python%E8%84%9A%E6%9C%AC/","excerpt":"","text":"前言Hexo编译和提交git的python脚本环境:windows python脚步存放路径:hexo博客的根目录(执行hexo s或者hexo g的目录)运行:python update.py(push.py是你的文件名) 脚本1234567891011121314import osprint('===开始执行===')print('===git pull origin master===')os.system(\"git pull origin master\")print('===git merge remoter/origin/master===')os.system(\"git merge remoter/origin/master\")print('===cd public===')os.chdir('.\\\\public')print('===git pull origin master===')os.system(\"git pull origin master\")print('===git merge remoter/origin/master===')os.system(\"git merge remoter/origin/master\")print('===执行结束===') 备注如果在运行的时候报Permission denied (publickey)这个错误的话,可以这样解决:把id_rsa，id_rsa.pub拷贝到git.ssh目录下","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"git常用操作整理","slug":"技术/2015-05-25-git常用操作整理","date":"2015-05-25T00:00:00.000Z","updated":"2020-06-09T10:00:01.623Z","comments":true,"path":"2015/05/25/技术/2015-05-25-git常用操作整理/","link":"","permalink":"https://ax-codes.github.io/2015/05/25/%E6%8A%80%E6%9C%AF/2015-05-25-git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/","excerpt":"","text":"安装官网连接:https://git-scm.com/ git初始化本地仓库1git init git全局配置12git config --global user.name \"ax\"git config --global user.email \"1069784176@qq.com\" 配置远程仓库1234git remote -v //列表git remote rm origin //删除git remote add origin git@gitee.com:AXingGit/axblog.git //新增 配置好这个后,可以直接用git的gui来操作 github 和 码云ssh测试12ssh -T git@github.com #githubssh -T git@gitee.com #码云 新增当前文件夹下的所有文件1git add . 提交文件1git commit -am 'remark' 推送到远程指定分支1git push origin master 从远程指定分支更新1git pull origin master 查看分支1git branch -a 合并分支1git merge remoter/origin/master #remoter/origin/master为当前分支要合并到哪个分支 查看分支状态1git status 冲突合并12345678910111213#1. 把远程仓库master分支下载到本地并存为tmp分支git fetch origin master:tmp#2. 查看tmp分支与本地原有分支的不同git diff tmp这里主要是看看有没有其他的改动…#3. 将tmp分支和本地的master分支合并git merge tmp这个时候呢,本地与远程就没有冲突了,而且还保留了我今天的代码,现在Push就OK啦！#4. 最后别忘记删除tmp分支git branch -d tmp git pull时出现冲突 放弃本地修改，使远程库内容强制覆盖本地代码12git fetch --all //只是下载代码到本地，不进行合并操作git reset --hard origin/master //把HEAD指向最新下载的版本","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"数据库优化常用方案","slug":"技术/2015-05-16-数据库优化常用方案","date":"2015-05-16T00:00:00.000Z","updated":"2020-06-09T10:00:01.622Z","comments":true,"path":"2015/05/16/技术/2015-05-16-数据库优化常用方案/","link":"","permalink":"https://ax-codes.github.io/2015/05/16/%E6%8A%80%E6%9C%AF/2015-05-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言 sql语句的解析是从右到左的 数据库优化方式 主机性能 内存使用性能 SQL语句执行性能 sql语句优化 使用select语句尽量多用字段,使用 效率更低因为使用 ,数据库还要去查询数据字典,然后解析列名,直接写列名会提高效率 查询数量:select()会有一个展开的过程,建议用字段,但是count()不会直接展开,直接就是扫描,查询数量,而count(1)还要找到对应的字段所以效率就低了 查询一条语句,尽量在后面加上”limit1”（数据库查询到一条即停止）sqlserver使用 top 插入多条数据到同一张表时,直接拼接sql,插入一次,减少交互次数 12insert into user(name) values(‘m’); insert into user(name) values(‘n’);#错误insert into user(name) values(‘m’), (‘n’);#正确 sql语句优化遵循原则 尽量避免在列上运算,这样会导致索引失效 使用 JOIN 时,应该用小结果集驱动大结果集,同时把复杂的 JOIN 查询拆分成多个query,因为JOIN 多个表,可能导致更多的锁定和堵塞 使用LIKE 时,避免使用 %% select 指定查询字段,不要全查出来,节省内存 使用批量插入语句节省交互 使用批量插入语句节省交互 123select * from t where 1 limit 100000,10 ；可改为:select * from twhere id between 100000 and 100010； 不要使用rand 函数取多条随机记录 避免使用 NULL 不要做无谓的排序操作,而应尽可能在索引中完成排序 删除所有记录的时候,用truncate 替代 delete,因为 delete 删除记录时,会扫描整个表,然后再一条一条删除,而 truncate table user; 是一次性删除整个表的所有内容,会提高效率 尽量多使用commit,因为 commit 会释放回滚点 callback 用 where 子句替换 having 子句,where 先执行,having 后执行因为 having 会先分组,比较占内存 多使用内部函数提高SQL效率,例如多使用concat连接,代替‘||’的符号连接 表名过长时,尽量使用表的别名,因为长表名更加的耗费扫描时间 使用列的别名,同样地,长列名也会耗费扫描时间 二者都能使用尽量使用where（与having比较）：where先过滤（数据就少了）再分组 123select a.*, b.* from a,b where a.id=b.a_id; 注意from后面的表名: 如果多表查询是完全无关系的话,将记录和列名最少的表写在最后,然后依次类推 如果多表查询是有关系的话,将引用最多的表放在最后,然后依次类推,这样速度会有所提高 where子句中的连接顺序(where也采用从右往左解析):当使用where子句连接的时候,要将可以过滤掉最大数量记录的条件写在where子句的最右边,这样,可以过滤掉大量数据后,再执行其他条件,可以提高效率","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"pycharm去除警告下划线","slug":"技术/2015-05-10-pycharm去除警告下划线","date":"2015-05-10T00:00:00.000Z","updated":"2020-06-09T10:00:01.620Z","comments":true,"path":"2015/05/10/技术/2015-05-10-pycharm去除警告下划线/","link":"","permalink":"https://ax-codes.github.io/2015/05/10/%E6%8A%80%E6%9C%AF/2015-05-10-pycharm%E5%8E%BB%E9%99%A4%E8%AD%A6%E5%91%8A%E4%B8%8B%E5%88%92%E7%BA%BF/","excerpt":"","text":"方法依次找到Editor→Colors&amp;Fonts→General，然后在右侧子选项中找到Errors and Warnings，展开后找到Weak Warning。这里控制着所有错误提醒的方式和形式，那些烦人的波浪线就是这个Weak Warning，在右侧的配置区可以去掉或者换成其他提醒方式都是可以的。下面有预览，你可以实时查看修改后的效果","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"csharp的IOC模型Autofac","slug":"技术/2015-04-30-csharp的IOC模型Autofac","date":"2015-04-30T00:00:00.000Z","updated":"2020-06-09T10:00:01.619Z","comments":true,"path":"2015/04/30/技术/2015-04-30-csharp的IOC模型Autofac/","link":"","permalink":"https://ax-codes.github.io/2015/04/30/%E6%8A%80%E6%9C%AF/2015-04-30-csharp%E7%9A%84IOC%E6%A8%A1%E5%9E%8BAutofac/","excerpt":"","text":"前言 Autofac是一款IOC框架，比较于其他的IOC框架，如Spring.NET，Unity，Castle等等所包含的，它很轻量级性能上非常高。 官网:http://autofac.org/ 源码:https://github.com/autofac/Autofac 理解:在web层引用业务层,如果web里多个地方创建了这个对象,那么业务改了之后,在new的地方需要改很多地方,但是如果用了依赖注入那么只需要改autofac注册这个类到对象的地方就行,不用每一个使用业务层对象的地方都要改,因为web层使用的都直接是接口对象,没有new了,同理,其他层也是一样 ioc:依赖注入 备注:最新版本下载可以看到，包括源码，示例文档，与之相关的测试项目，生成的DLL文件，其他文档 ioc实际应用场景以两种日志记录和数据库使用两种场景来分析 日志记录：有时需要调试分析，需要记录日志信息，这时可以采用输出到控制台、文件、数据库、远程服务器等；假设最初采用输出到控制台，直接在程序中实例化ILogger logger = new ConsoleLogger()，但有时又需要输出到别的文件中，也许关闭日志输出，就需要更改程序，把ConsoleLogger改成FileLogger或者NoLogger，此时不断的更改代码，就显得心里不好了，如果采用依赖注入，就显得特别舒畅 数据库操作：几乎任何项目都离不开数据库的使用，数据库种类特别多：oracle、mysql、sqlserver、informix、postgresql… …，数据库语法也不尽相同，假如开始使用的是oracle，有一天改成了postgresql，这时采用依赖注入就显得圆润的多 ioc优点 传统的代码，每个对象负责管理与自己需要依赖的对象，导致如果需要切换依赖对象的实现类时，需要修改多处地方。同时，过度耦合也使得对象难以进行单元测试。 依赖注入把对象的创造交给外部去管理,很好的解决了代码紧耦合（tight couple）的问题，是一种让代码实现松耦合（loose couple）的机制。 松耦合让代码更具灵活性，能更好地应对需求变动，以及方便单元测试。 ioc缺点 在java语言中基本采用反射的方式来实现依赖注入，在一定程度会影响性能","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"csharp中依赖注入(IOC)的理解","slug":"技术/2015-04-29-csharp中依赖注入(IOC)的理解","date":"2015-04-29T00:00:00.000Z","updated":"2020-06-09T10:00:01.618Z","comments":true,"path":"2015/04/29/技术/2015-04-29-csharp中依赖注入(IOC)的理解/","link":"","permalink":"https://ax-codes.github.io/2015/04/29/%E6%8A%80%E6%9C%AF/2015-04-29-csharp%E4%B8%AD%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5(IOC)%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"前言 常用的ioc框架如Spring.NET，Unity，Castle,autofac等等 ioc:依赖注入 ioc实际应用场景以两种日志记录和数据库使用两种场景来分析 日志记录：有时需要调试分析，需要记录日志信息，这时可以采用输出到控制台、文件、数据库、远程服务器等；假设最初采用输出到控制台，直接在程序中实例化ILogger logger = new ConsoleLogger()，但有时又需要输出到别的文件中，也许关闭日志输出，就需要更改程序，把ConsoleLogger改成FileLogger或者NoLogger，此时不断的更改代码，就显得心里不好了，如果采用依赖注入，就显得特别舒畅 数据库操作：几乎任何项目都离不开数据库的使用，数据库种类特别多：oracle、mysql、sqlserver、informix、postgresql… …，数据库语法也不尽相同，假如开始使用的是oracle，有一天改成了postgresql，这时采用依赖注入就显得圆润的多 ioc优点 传统的代码，每个对象负责管理与自己需要依赖的对象，导致如果需要切换依赖对象的实现类时，需要修改多处地方。同时，过度耦合也使得对象难以进行单元测试。 依赖注入把对象的创造交给外部去管理,很好的解决了代码紧耦合（tight couple）的问题，是一种让代码实现松耦合（loose couple）的机制。 松耦合让代码更具灵活性，能更好地应对需求变动，以及方便单元测试。 ioc缺点 在java语言中基本采用反射的方式来实现依赖注入，在一定程度会影响性能 总结在web层引用业务层,如果web里多个地方创建了这个对象,那么业务改了之后,在new的地方需要改很多地方,但是如果用了依赖注入那么只需要改autofac注册这个类到对象的地方就行,不用每一个使用业务层对象的地方都要改,因为web层使用的都直接是接口对象,没有new了,同理,其他层也是一样","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":".net的Webservice创建和使用","slug":"技术/2015-04-20-.net的Webservice创建和使用","date":"2015-04-20T00:00:00.000Z","updated":"2020-06-09T10:00:01.614Z","comments":true,"path":"2015/04/20/技术/2015-04-20-.net的Webservice创建和使用/","link":"","permalink":"https://ax-codes.github.io/2015/04/20/%E6%8A%80%E6%9C%AF/2015-04-20-.net%E7%9A%84Webservice%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言 什么是webServicewebService是一种使用http传输SOAP协议数据的远程调用技术 webService三要素SOAP：规范XML标签WSDL：服务端的使用说明书UDDI：目录 创建 在web网站里添加对应的”web服务(ASMX)”然后会生成.asmx的文件,内容默认为:然后我们可以根据自己的需求创建自定义的方法返回数据,注意每个方法都是一个接口 发布 创建自定义web配置文件,输入名称 发布方法选择文件系统,然后选择路径 选择debug还是release后点击发布 在iis上新建站点选择发布的文件路径 然后打开浏览器输入 http://localhost:8080/webservice.asmx (8080是自定义的端口,webservice.asmx是我的webservice文件,你需要改成自己的)如果显示下图,则说明成功: 调用方法一:根据指定的WebService地址的WSDL,然后解析模拟生成一个代理类,通过反射调用里面的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using System;using System.IO;using System.Collections.Generic;using System.Linq;using System.Collections;using System.Web;using System.Net;using System.Reflection;using System.CodeDom;using System.CodeDom.Compiler;using System.Web.Services;using System.Text;using System.Web.Services.Description;using System.Web.Services.Protocols;using System.Xml.Serialization;using System.Windows.Forms;namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; WebClient client &#x3D; new WebClient(); String url &#x3D; &quot;http:&#x2F;&#x2F;localhost:3182&#x2F;Service1.asmx?WSDL&quot;;&#x2F;&#x2F;这个地址可以写在Config文件里面，这里取出来就行了.在原地址后面加上： ?WSDL Stream stream &#x3D; client.OpenRead(url); ServiceDescription description &#x3D; ServiceDescription.Read(stream); ServiceDescriptionImporter importer &#x3D; new ServiceDescriptionImporter();&#x2F;&#x2F;创建客户端代理代理类。 importer.ProtocolName &#x3D; &quot;Soap&quot;; &#x2F;&#x2F;指定访问协议。 importer.Style &#x3D; ServiceDescriptionImportStyle.Client; &#x2F;&#x2F;生成客户端代理。 importer.CodeGenerationOptions &#x3D; CodeGenerationOptions.GenerateProperties | CodeGenerationOptions.GenerateNewAsync; importer.AddServiceDescription(description, null, null); &#x2F;&#x2F;添加WSDL文档。 CodeNamespace nmspace &#x3D; new CodeNamespace(); &#x2F;&#x2F;命名空间 nmspace.Name &#x3D; &quot;TestWebService&quot;; CodeCompileUnit unit &#x3D; new CodeCompileUnit(); unit.Namespaces.Add(nmspace); ServiceDescriptionImportWarnings warning &#x3D; importer.Import(nmspace, unit); CodeDomProvider provider &#x3D; CodeDomProvider.CreateProvider(&quot;CSharp&quot;); CompilerParameters parameter &#x3D; new CompilerParameters(); parameter.GenerateExecutable &#x3D; false; parameter.OutputAssembly &#x3D; &quot;MyTest.dll&quot;;&#x2F;&#x2F;输出程序集的名称 parameter.ReferencedAssemblies.Add(&quot;System.dll&quot;); parameter.ReferencedAssemblies.Add(&quot;System.XML.dll&quot;); parameter.ReferencedAssemblies.Add(&quot;System.Web.Services.dll&quot;); parameter.ReferencedAssemblies.Add(&quot;System.Data.dll&quot;); CompilerResults result &#x3D; provider.CompileAssemblyFromDom(parameter, unit); if (result.Errors.HasErrors) &#123; &#x2F;&#x2F; 显示编译错误信息 &#125; Assembly asm &#x3D; Assembly.LoadFrom(&quot;MyTest.dll&quot;);&#x2F;&#x2F;加载前面生成的程序集 Type t &#x3D; asm.GetType(&quot;TestWebService.TestWebService&quot;); object o &#x3D; Activator.CreateInstance(t); MethodInfo method &#x3D; t.GetMethod(&quot;GetPersons&quot;);&#x2F;&#x2F;GetPersons是服务端的方法名称,你想调用服务端的什么方法都可以在这里改,最好封装一下 String[] item &#x3D; (String[])method.Invoke(o, null); &#x2F;&#x2F;注：method.Invoke(o, null)返回的是一个Object,如果你服务端返回的是DataSet,这里也是用(DataSet)method.Invoke(o, null)转一下就行了,method.Invoke(0,null)这里的null可以传调用方法需要的参数,string[]形式的 foreach (string str in item) Console.WriteLine(str); &#x2F;&#x2F;上面是根据WebService地址，模似生成一个代理类,如果你想看看生成的代码文件是什么样子，可以用以下代码保存下来，默认是保存在bin目录下面 TextWriter writer &#x3D; File.CreateText(&quot;MyTest.cs&quot;); provider.GenerateCodeFromCompileUnit(unit, writer, null); writer.Flush(); writer.Close(); &#125; &#125;&#125; 方法二:利用 wsdl.exe生成webservice代理类根据提供的wsdl生成webservice代理类，然后在代码里引用这个类文件。步骤： 在开始菜单找到 Microsoft Visual Studio 2010 下面的Visual Studio Tools ， 点击Visual Studio 命令提示(2010)，打开命令行2.在命令行中输入： wsdl /language:c# /n:TestDemo /out:d:/Temp/TestService.cs http://jm1.services.gmcc.net/ad/Services/AD.asmx?wsdl这句命令行的意思是：对最后面的服务地址进行编译，在D盘temp 目录下生成testservice文件。3.把上面命令编译后的cs文件，复制到我们项目中，在项目代码中可以直接new 一个出来后，可以进行调用。贴出由命令行编译出来的代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425&#x2F;&#x2F;------------------------------------------------------------------------------&#x2F;&#x2F; &lt;auto-generated&gt;&#x2F;&#x2F; 此代码由工具生成。&#x2F;&#x2F; 运行时版本:4.0.30319.225&#x2F;&#x2F;&#x2F;&#x2F; 对此文件的更改可能会导致不正确的行为，并且如果&#x2F;&#x2F; 重新生成代码，这些更改将会丢失。&#x2F;&#x2F; &lt;&#x2F;auto-generated&gt;&#x2F;&#x2F;------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 此源代码由 wsdl 自动生成, Version&#x3D;4.0.30319.1。&#x2F;&#x2F; namespace Bingosoft.Module.SurveyQuestionnaire.DAL &#123; using System; using System.Diagnostics; using System.Xml.Serialization; using System.ComponentModel; using System.Web.Services.Protocols; using System.Web.Services; using System.Data; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] [System.Diagnostics.DebuggerStepThroughAttribute()] [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)] [System.Web.Services.WebServiceBindingAttribute(Name&#x3D;&quot;WebserviceForILookSoap&quot;, Namespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;)] public partial class WebserviceForILook : System.Web.Services.Protocols.SoapHttpClientProtocol &#123; private System.Threading.SendOrPostCallback GetRecordNumOperationCompleted; private System.Threading.SendOrPostCallback GetVoteListOperationCompleted; private System.Threading.SendOrPostCallback VoteOperationCompleted; private System.Threading.SendOrPostCallback GiveUpOperationCompleted; private System.Threading.SendOrPostCallback GetQuestionTaskListOperationCompleted; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public WebserviceForILook() &#123; this.Url &#x3D; &quot;http:&#x2F;&#x2F;st1.services.gmcc.net&#x2F;qnaire&#x2F;Services&#x2F;WebserviceForILook.asmx&quot;; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public event GetRecordNumCompletedEventHandler GetRecordNumCompleted; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public event GetVoteListCompletedEventHandler GetVoteListCompleted; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public event VoteCompletedEventHandler VoteCompleted; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public event GiveUpCompletedEventHandler GiveUpCompleted; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public event GetQuestionTaskListCompletedEventHandler GetQuestionTaskListCompleted; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.Web.Services.Protocols.SoapDocumentMethodAttribute(&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;GetRecordNum&quot;, RequestNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, ResponseNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, Use&#x3D;System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle&#x3D;System.Web.Services.Protocols.SoapParameterStyle.Wrapped)] public int[] GetRecordNum(string appcode, string userID) &#123; object[] results &#x3D; this.Invoke(&quot;GetRecordNum&quot;, new object[] &#123; appcode, userID&#125;); return ((int[])(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.IAsyncResult BeginGetRecordNum(string appcode, string userID, System.AsyncCallback callback, object asyncState) &#123; return this.BeginInvoke(&quot;GetRecordNum&quot;, new object[] &#123; appcode, userID&#125;, callback, asyncState); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public int[] EndGetRecordNum(System.IAsyncResult asyncResult) &#123; object[] results &#x3D; this.EndInvoke(asyncResult); return ((int[])(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GetRecordNumAsync(string appcode, string userID) &#123; this.GetRecordNumAsync(appcode, userID, null); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GetRecordNumAsync(string appcode, string userID, object userState) &#123; if ((this.GetRecordNumOperationCompleted &#x3D;&#x3D; null)) &#123; this.GetRecordNumOperationCompleted &#x3D; new System.Threading.SendOrPostCallback(this.OnGetRecordNumOperationCompleted); &#125; this.InvokeAsync(&quot;GetRecordNum&quot;, new object[] &#123; appcode, userID&#125;, this.GetRecordNumOperationCompleted, userState); &#125; private void OnGetRecordNumOperationCompleted(object arg) &#123; if ((this.GetRecordNumCompleted !&#x3D; null)) &#123; System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs &#x3D; ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg)); this.GetRecordNumCompleted(this, new GetRecordNumCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState)); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.Web.Services.Protocols.SoapDocumentMethodAttribute(&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;GetVoteList&quot;, RequestNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, ResponseNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, Use&#x3D;System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle&#x3D;System.Web.Services.Protocols.SoapParameterStyle.Wrapped)] public System.Data.DataSet GetVoteList(string appcode, string userID) &#123; object[] results &#x3D; this.Invoke(&quot;GetVoteList&quot;, new object[] &#123; appcode, userID&#125;); return ((System.Data.DataSet)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.IAsyncResult BeginGetVoteList(string appcode, string userID, System.AsyncCallback callback, object asyncState) &#123; return this.BeginInvoke(&quot;GetVoteList&quot;, new object[] &#123; appcode, userID&#125;, callback, asyncState); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.Data.DataSet EndGetVoteList(System.IAsyncResult asyncResult) &#123; object[] results &#x3D; this.EndInvoke(asyncResult); return ((System.Data.DataSet)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GetVoteListAsync(string appcode, string userID) &#123; this.GetVoteListAsync(appcode, userID, null); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GetVoteListAsync(string appcode, string userID, object userState) &#123; if ((this.GetVoteListOperationCompleted &#x3D;&#x3D; null)) &#123; this.GetVoteListOperationCompleted &#x3D; new System.Threading.SendOrPostCallback(this.OnGetVoteListOperationCompleted); &#125; this.InvokeAsync(&quot;GetVoteList&quot;, new object[] &#123; appcode, userID&#125;, this.GetVoteListOperationCompleted, userState); &#125; private void OnGetVoteListOperationCompleted(object arg) &#123; if ((this.GetVoteListCompleted !&#x3D; null)) &#123; System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs &#x3D; ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg)); this.GetVoteListCompleted(this, new GetVoteListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState)); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.Web.Services.Protocols.SoapDocumentMethodAttribute(&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;Vote&quot;, RequestNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, ResponseNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, Use&#x3D;System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle&#x3D;System.Web.Services.Protocols.SoapParameterStyle.Wrapped)] public bool Vote(string appcode, string userID, string qTaskID, string answer) &#123; object[] results &#x3D; this.Invoke(&quot;Vote&quot;, new object[] &#123; appcode, userID, qTaskID, answer&#125;); return ((bool)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.IAsyncResult BeginVote(string appcode, string userID, string qTaskID, string answer, System.AsyncCallback callback, object asyncState) &#123; return this.BeginInvoke(&quot;Vote&quot;, new object[] &#123; appcode, userID, qTaskID, answer&#125;, callback, asyncState); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public bool EndVote(System.IAsyncResult asyncResult) &#123; object[] results &#x3D; this.EndInvoke(asyncResult); return ((bool)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void VoteAsync(string appcode, string userID, string qTaskID, string answer) &#123; this.VoteAsync(appcode, userID, qTaskID, answer, null); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void VoteAsync(string appcode, string userID, string qTaskID, string answer, object userState) &#123; if ((this.VoteOperationCompleted &#x3D;&#x3D; null)) &#123; this.VoteOperationCompleted &#x3D; new System.Threading.SendOrPostCallback(this.OnVoteOperationCompleted); &#125; this.InvokeAsync(&quot;Vote&quot;, new object[] &#123; appcode, userID, qTaskID, answer&#125;, this.VoteOperationCompleted, userState); &#125; private void OnVoteOperationCompleted(object arg) &#123; if ((this.VoteCompleted !&#x3D; null)) &#123; System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs &#x3D; ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg)); this.VoteCompleted(this, new VoteCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState)); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.Web.Services.Protocols.SoapDocumentMethodAttribute(&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;GiveUp&quot;, RequestNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, ResponseNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, Use&#x3D;System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle&#x3D;System.Web.Services.Protocols.SoapParameterStyle.Wrapped)] public bool GiveUp(string appcode, string userID, string qTaskID) &#123; object[] results &#x3D; this.Invoke(&quot;GiveUp&quot;, new object[] &#123; appcode, userID, qTaskID&#125;); return ((bool)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.IAsyncResult BeginGiveUp(string appcode, string userID, string qTaskID, System.AsyncCallback callback, object asyncState) &#123; return this.BeginInvoke(&quot;GiveUp&quot;, new object[] &#123; appcode, userID, qTaskID&#125;, callback, asyncState); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public bool EndGiveUp(System.IAsyncResult asyncResult) &#123; object[] results &#x3D; this.EndInvoke(asyncResult); return ((bool)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GiveUpAsync(string appcode, string userID, string qTaskID) &#123; this.GiveUpAsync(appcode, userID, qTaskID, null); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GiveUpAsync(string appcode, string userID, string qTaskID, object userState) &#123; if ((this.GiveUpOperationCompleted &#x3D;&#x3D; null)) &#123; this.GiveUpOperationCompleted &#x3D; new System.Threading.SendOrPostCallback(this.OnGiveUpOperationCompleted); &#125; this.InvokeAsync(&quot;GiveUp&quot;, new object[] &#123; appcode, userID, qTaskID&#125;, this.GiveUpOperationCompleted, userState); &#125; private void OnGiveUpOperationCompleted(object arg) &#123; if ((this.GiveUpCompleted !&#x3D; null)) &#123; System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs &#x3D; ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg)); this.GiveUpCompleted(this, new GiveUpCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState)); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.Web.Services.Protocols.SoapDocumentMethodAttribute(&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;GetQuestionTaskList&quot;, RequestNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, ResponseNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;, Use&#x3D;System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle&#x3D;System.Web.Services.Protocols.SoapParameterStyle.Wrapped)] public System.Data.DataSet GetQuestionTaskList(string appcode, string userID) &#123; object[] results &#x3D; this.Invoke(&quot;GetQuestionTaskList&quot;, new object[] &#123; appcode, userID&#125;); return ((System.Data.DataSet)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.IAsyncResult BeginGetQuestionTaskList(string appcode, string userID, System.AsyncCallback callback, object asyncState) &#123; return this.BeginInvoke(&quot;GetQuestionTaskList&quot;, new object[] &#123; appcode, userID&#125;, callback, asyncState); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.Data.DataSet EndGetQuestionTaskList(System.IAsyncResult asyncResult) &#123; object[] results &#x3D; this.EndInvoke(asyncResult); return ((System.Data.DataSet)(results[0])); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GetQuestionTaskListAsync(string appcode, string userID) &#123; this.GetQuestionTaskListAsync(appcode, userID, null); &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public void GetQuestionTaskListAsync(string appcode, string userID, object userState) &#123; if ((this.GetQuestionTaskListOperationCompleted &#x3D;&#x3D; null)) &#123; this.GetQuestionTaskListOperationCompleted &#x3D; new System.Threading.SendOrPostCallback(this.OnGetQuestionTaskListOperationCompleted); &#125; this.InvokeAsync(&quot;GetQuestionTaskList&quot;, new object[] &#123; appcode, userID&#125;, this.GetQuestionTaskListOperationCompleted, userState); &#125; private void OnGetQuestionTaskListOperationCompleted(object arg) &#123; if ((this.GetQuestionTaskListCompleted !&#x3D; null)) &#123; System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs &#x3D; ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg)); this.GetQuestionTaskListCompleted(this, new GetQuestionTaskListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState)); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public new void CancelAsync(object userState) &#123; base.CancelAsync(userState); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] public delegate void GetRecordNumCompletedEventHandler(object sender, GetRecordNumCompletedEventArgs e); &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] [System.Diagnostics.DebuggerStepThroughAttribute()] [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)] public partial class GetRecordNumCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs &#123; private object[] results; internal GetRecordNumCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : base(exception, cancelled, userState) &#123; this.results &#x3D; results; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public int[] Result &#123; get &#123; this.RaiseExceptionIfNecessary(); return ((int[])(this.results[0])); &#125; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] public delegate void GetVoteListCompletedEventHandler(object sender, GetVoteListCompletedEventArgs e); &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] [System.Diagnostics.DebuggerStepThroughAttribute()] [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)] public partial class GetVoteListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs &#123; private object[] results; internal GetVoteListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : base(exception, cancelled, userState) &#123; this.results &#x3D; results; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.Data.DataSet Result &#123; get &#123; this.RaiseExceptionIfNecessary(); return ((System.Data.DataSet)(this.results[0])); &#125; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] public delegate void VoteCompletedEventHandler(object sender, VoteCompletedEventArgs e); &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] [System.Diagnostics.DebuggerStepThroughAttribute()] [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)] public partial class VoteCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs &#123; private object[] results; internal VoteCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : base(exception, cancelled, userState) &#123; this.results &#x3D; results; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public bool Result &#123; get &#123; this.RaiseExceptionIfNecessary(); return ((bool)(this.results[0])); &#125; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] public delegate void GiveUpCompletedEventHandler(object sender, GiveUpCompletedEventArgs e); &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] [System.Diagnostics.DebuggerStepThroughAttribute()] [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)] public partial class GiveUpCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs &#123; private object[] results; internal GiveUpCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : base(exception, cancelled, userState) &#123; this.results &#x3D; results; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public bool Result &#123; get &#123; this.RaiseExceptionIfNecessary(); return ((bool)(this.results[0])); &#125; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] public delegate void GetQuestionTaskListCompletedEventHandler(object sender, GetQuestionTaskListCompletedEventArgs e); &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;wsdl&quot;, &quot;4.0.30319.1&quot;)] [System.Diagnostics.DebuggerStepThroughAttribute()] [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)] public partial class GetQuestionTaskListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs &#123; private object[] results; internal GetQuestionTaskListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : base(exception, cancelled, userState) &#123; this.results &#x3D; results; &#125; &#x2F;&#x2F;&#x2F; &lt;remarks&#x2F;&gt; public System.Data.DataSet Result &#123; get &#123; this.RaiseExceptionIfNecessary(); return ((System.Data.DataSet)(this.results[0])); &#125; &#125; &#125;&#125; 方法三:利用http 协议的get 和post(ajax)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198using System;using System.Collections;using System.IO;using System.Net;using System.Text;using System.Xml;using System.Xml.Serialization;namespace Bingosoft.RIA.Common&#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 利用WebRequest&#x2F;WebResponse进行WebService调用的类 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public class WebServiceCaller &#123; #region Tip:使用说明 &#x2F;&#x2F;webServices 应该支持Get和Post调用，在web.config应该增加以下代码 &#x2F;&#x2F;&lt;webServices&gt; &#x2F;&#x2F; &lt;protocols&gt; &#x2F;&#x2F; &lt;add name&#x3D;&quot;HttpGet&quot;&#x2F;&gt; &#x2F;&#x2F; &lt;add name&#x3D;&quot;HttpPost&quot;&#x2F;&gt; &#x2F;&#x2F; &lt;&#x2F;protocols&gt; &#x2F;&#x2F;&lt;&#x2F;webServices&gt; &#x2F;&#x2F;调用示例： &#x2F;&#x2F;Hashtable ht &#x3D; new Hashtable(); &#x2F;&#x2F;Hashtable 为webservice所需要的参数集 &#x2F;&#x2F;ht.Add(&quot;str&quot;, &quot;test&quot;); &#x2F;&#x2F;ht.Add(&quot;b&quot;, &quot;true&quot;); &#x2F;&#x2F;XmlDocument xx &#x3D; WebSvcCaller.QuerySoapWebService(&quot;http:&#x2F;&#x2F;localhost:81&#x2F;service.asmx&quot;, &quot;HelloWorld&quot;, ht); &#x2F;&#x2F;MessageBox.Show(xx.OuterXml); #endregion &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 需要WebService支持Post调用 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public static XmlDocument QueryPostWebService(String URL, String MethodName, Hashtable Pars) &#123; HttpWebRequest request &#x3D; (HttpWebRequest)HttpWebRequest.Create(URL + &quot;&#x2F;&quot; + MethodName); request.Method &#x3D; &quot;POST&quot;; request.ContentType &#x3D; &quot;application&#x2F;x-www-form-urlencoded&quot;; SetWebRequest(request); byte[] data &#x3D; EncodePars(Pars); WriteRequestData(request, data); return ReadXmlResponse(request.GetResponse()); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 需要WebService支持Get调用 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public static XmlDocument QueryGetWebService(String URL, String MethodName, Hashtable Pars) &#123; HttpWebRequest request &#x3D; (HttpWebRequest)HttpWebRequest.Create(URL + &quot;&#x2F;&quot; + MethodName + &quot;?&quot; + ParsToString(Pars)); request.Method &#x3D; &quot;GET&quot;; request.ContentType &#x3D; &quot;application&#x2F;x-www-form-urlencoded&quot;; SetWebRequest(request); return ReadXmlResponse(request.GetResponse()); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 通用WebService调用(Soap),参数Pars为String类型的参数名、参数值 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public static XmlDocument QuerySoapWebService(String URL, String MethodName, Hashtable Pars) &#123; if (_xmlNamespaces.ContainsKey(URL)) &#123; return QuerySoapWebService(URL, MethodName, Pars, _xmlNamespaces[URL].ToString()); &#125; else &#123; return QuerySoapWebService(URL, MethodName, Pars, GetNamespace(URL)); &#125; &#125; private static XmlDocument QuerySoapWebService(String URL, String MethodName, Hashtable Pars, string XmlNs) &#123; _xmlNamespaces[URL] &#x3D; XmlNs;&#x2F;&#x2F;加入缓存，提高效率 HttpWebRequest request &#x3D; (HttpWebRequest)HttpWebRequest.Create(URL); request.Method &#x3D; &quot;POST&quot;; request.ContentType &#x3D; &quot;text&#x2F;xml; charset&#x3D;utf-8&quot;; request.Headers.Add(&quot;SOAPAction&quot;, &quot;\\&quot;&quot; + XmlNs + (XmlNs.EndsWith(&quot;&#x2F;&quot;) ? &quot;&quot; : &quot;&#x2F;&quot;) + MethodName + &quot;\\&quot;&quot;); SetWebRequest(request); byte[] data &#x3D; EncodeParsToSoap(Pars, XmlNs, MethodName); WriteRequestData(request, data); XmlDocument doc &#x3D; new XmlDocument(), doc2 &#x3D; new XmlDocument(); doc &#x3D; ReadXmlResponse(request.GetResponse()); XmlNamespaceManager mgr &#x3D; new XmlNamespaceManager(doc.NameTable); mgr.AddNamespace(&quot;soap&quot;, &quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;); String RetXml &#x3D; doc.SelectSingleNode(&quot;&#x2F;&#x2F;soap:Body&#x2F;*&#x2F;*&quot;, mgr).InnerXml; doc2.LoadXml(&quot;&lt;root&gt;&quot; + RetXml + &quot;&lt;&#x2F;root&gt;&quot;); AddDelaration(doc2); return doc2; &#125; private static string GetNamespace(String URL) &#123; HttpWebRequest request &#x3D; (HttpWebRequest)WebRequest.Create(URL + &quot;?WSDL&quot;); SetWebRequest(request); WebResponse response &#x3D; request.GetResponse(); StreamReader sr &#x3D; new StreamReader(response.GetResponseStream(), Encoding.UTF8); XmlDocument doc &#x3D; new XmlDocument(); doc.LoadXml(sr.ReadToEnd()); sr.Close(); return doc.SelectSingleNode(&quot;&#x2F;&#x2F;@targetNamespace&quot;).Value; &#125; private static byte[] EncodeParsToSoap(Hashtable Pars, String XmlNs, String MethodName) &#123; XmlDocument doc &#x3D; new XmlDocument(); doc.LoadXml(&quot;&lt;soap:Envelope xmlns:xsi&#x3D;\\&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance\\&quot; xmlns:xsd&#x3D;\\&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema\\&quot; xmlns:soap&#x3D;\\&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;\\&quot;&gt;&lt;&#x2F;soap:Envelope&gt;&quot;); AddDelaration(doc); &#x2F;&#x2F;XmlElement soapBody &#x3D; doc.createElement_x_x(&quot;soap&quot;, &quot;Body&quot;, &quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;); XmlElement soapBody &#x3D; doc.CreateElement(&quot;soap&quot;, &quot;Body&quot;, &quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;); &#x2F;&#x2F;XmlElement soapMethod &#x3D; doc.createElement_x_x(MethodName); XmlElement soapMethod &#x3D; doc.CreateElement(MethodName); soapMethod.SetAttribute(&quot;xmlns&quot;, XmlNs); foreach (string k in Pars.Keys) &#123; &#x2F;&#x2F;XmlElement soapPar &#x3D; doc.createElement_x_x(k); XmlElement soapPar &#x3D; doc.CreateElement(k); soapPar.InnerXml &#x3D; ObjectToSoapXml(Pars[k]); soapMethod.AppendChild(soapPar); &#125; soapBody.AppendChild(soapMethod); doc.DocumentElement.AppendChild(soapBody); return Encoding.UTF8.GetBytes(doc.OuterXml); &#125; private static string ObjectToSoapXml(object o) &#123; XmlSerializer mySerializer &#x3D; new XmlSerializer(o.GetType()); MemoryStream ms &#x3D; new MemoryStream(); mySerializer.Serialize(ms, o); XmlDocument doc &#x3D; new XmlDocument(); doc.LoadXml(Encoding.UTF8.GetString(ms.ToArray())); if (doc.DocumentElement !&#x3D; null) &#123; return doc.DocumentElement.InnerXml; &#125; else &#123; return o.ToString(); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 设置凭证与超时时间 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;request&quot;&gt;&lt;&#x2F;param&gt; private static void SetWebRequest(HttpWebRequest request) &#123; request.Credentials &#x3D; CredentialCache.DefaultCredentials; request.Timeout &#x3D; 10000; &#125; private static void WriteRequestData(HttpWebRequest request, byte[] data) &#123; request.ContentLength &#x3D; data.Length; Stream writer &#x3D; request.GetRequestStream(); writer.Write(data, 0, data.Length); writer.Close(); &#125; private static byte[] EncodePars(Hashtable Pars) &#123; return Encoding.UTF8.GetBytes(ParsToString(Pars)); &#125; private static String ParsToString(Hashtable Pars) &#123; StringBuilder sb &#x3D; new StringBuilder(); foreach (string k in Pars.Keys) &#123; if (sb.Length &gt; 0) &#123; sb.Append(&quot;&amp;&quot;); &#125; &#x2F;&#x2F;sb.Append(HttpUtility.UrlEncode(k) + &quot;&#x3D;&quot; + HttpUtility.UrlEncode(Pars[k].ToString())); &#125; return sb.ToString(); &#125; private static XmlDocument ReadXmlResponse(WebResponse response) &#123; StreamReader sr &#x3D; new StreamReader(response.GetResponseStream(), Encoding.UTF8); String retXml &#x3D; sr.ReadToEnd(); sr.Close(); XmlDocument doc &#x3D; new XmlDocument(); doc.LoadXml(retXml); return doc; &#125; private static void AddDelaration(XmlDocument doc) &#123; XmlDeclaration decl &#x3D; doc.CreateXmlDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, null); doc.InsertBefore(decl, doc.DocumentElement); &#125; private static Hashtable _xmlNamespaces &#x3D; new Hashtable();&#x2F;&#x2F;缓存xmlNamespace，避免重复调用GetNamespace &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"vscode运行code-runner的时候中文乱码","slug":"技术/2015-04-11-vscode运行code-runner的时候输入乱码","date":"2015-04-11T00:00:00.000Z","updated":"2020-06-09T10:00:01.614Z","comments":true,"path":"2015/04/11/技术/2015-04-11-vscode运行code-runner的时候输入乱码/","link":"","permalink":"https://ax-codes.github.io/2015/04/11/%E6%8A%80%E6%9C%AF/2015-04-11-vscode%E8%BF%90%E8%A1%8Ccode-runner%E7%9A%84%E6%97%B6%E5%80%99%E8%BE%93%E5%85%A5%E4%B9%B1%E7%A0%81/","excerpt":"","text":"问题vscode运行code-runner的时候中文乱码,但在终端显示不会 解决在setting里加入1\"code-runner.runInTerminal\": true,表示将我们的将内容输出到终端显示","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"},{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"},{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"python3操作mysql帮助类","slug":"技术/2015-04-10-python3操作mysql帮助类","date":"2015-04-10T00:00:00.000Z","updated":"2020-06-09T10:00:01.613Z","comments":true,"path":"2015/04/10/技术/2015-04-10-python3操作mysql帮助类/","link":"","permalink":"https://ax-codes.github.io/2015/04/10/%E6%8A%80%E6%9C%AF/2015-04-10-python3%E6%93%8D%E4%BD%9Cmysql%E5%B8%AE%E5%8A%A9%E7%B1%BB/","excerpt":"","text":"前言 python3没有mysqldb,只有python2才有,所以我们在python使用的pymysql,安装命令1conda install PyMySQL 代码是引用https://www.cnblogs.com/dfcao/p/lightweight-python-mysql-class.html的python2的LightMysql进行的修改,修改过程只需将Mysql模块替换成pymysql模块,和一些python3的语法 如果你想使用python2操作mysql的话可以使用这个https://www.cnblogs.com/dfcao/p/lightweight-python-mysql-class.html可以参考这里的 代码sql创建好数据库后,创建表,表结构sql如下:123456789-- ------------------------------ Table structure for customer-- ----------------------------DROP TABLE IF EXISTS `customer`;CREATE TABLE `customer` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Cost` int(11) DEFAULT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=latin1; 模块代码(MysqlHelper.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# -*- coding: utf-8 -*-import pymysqlimport timeimport reclass MysqlHelper: \"\"\"Lightweight python class connects to MySQL. \"\"\" _dbconfig = None _cursor = None _connect = None _error_code = '' # error_code from MySQLdb TIMEOUT_DEADLINE = 30 # quit connect if beyond 30S TIMEOUT_THREAD = 10 # threadhold of one connect TIMEOUT_TOTAL = 0 # total time the connects have waste def __init__(self, dbconfig): try: self._dbconfig = dbconfig self.dbconfig_test(dbconfig) self._connect = pymysql.connect( host=self._dbconfig['host'], port=self._dbconfig['port'], user=self._dbconfig['user'], passwd=self._dbconfig['passwd'], db=self._dbconfig['db'], charset=self._dbconfig['charset'], connect_timeout=self.TIMEOUT_THREAD) except pymysql.Error as e: self._error_code = e.args[0] error_msg = \"%s --- %s\" % (time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())), type(e).__name__), e.args[0], e.args[1] print(error_msg) # reconnect if not reach TIMEOUT_DEADLINE. if self.TIMEOUT_TOTAL &lt; self.TIMEOUT_DEADLINE: interval = 0 self.TIMEOUT_TOTAL += (interval + self.TIMEOUT_THREAD) time.sleep(interval) # return self.__init__(dbconfig) raise Exception(error_msg) self._cursor = self._connect.cursor(pymysql.cursors.DictCursor) def dbconfig_test(self, dbconfig): flag = True if type(dbconfig) is not dict: print('dbconfig is not dict') flag = False else: for key in ['host','port','user','passwd','db']: if key in dbconfig.items(): print(\"dbconfig error: do not have %s\" % key) flag = False if not 'charset' in dbconfig.items(): self._dbconfig['charset'] = 'utf8' if not flag: raise Exception('Dbconfig Error') return flag def query(self, sql, ret_type='all'): try: self._cursor.execute(\"SET NAMES utf8\") self._cursor.execute(sql) if ret_type == 'all': return self.rows2array(self._cursor.fetchall()) elif ret_type == 'one': return self._cursor.fetchone() elif ret_type == 'count': return self._cursor.rowcount except pymysql.Error as e: self._error_code = e.args[0] print(\"Mysql execute error:\",e.args[0],e.args[1]) return False def dml(self, sql): '''update or delete or insert''' try: self._cursor.execute(sql) type = self.dml_type(sql) # if primary key is auto increase, return inserted ID. if type == 'insert': insert_id = self._connect.insert_id()#必须在commit之前,不然会是0 self._connect.commit() return insert_id else: self._connect.commit() return True except pymysql.Error as e: self._error_code = e.args[0] print(\"Mysql execute error:\",e.args[0],e.args[1]) return False def dml_type(self, sql): re_dml = re.compile('^(?P&lt;dml&gt;\\w+)\\s+', re.I) m = re_dml.match(sql) if m: if m.group(\"dml\").lower() == 'delete': return 'delete' elif m.group(\"dml\").lower() == 'update': return 'update' elif m.group(\"dml\").lower() == 'insert': return 'insert' print(\"%s --- Warning: '%s' is not dml.\" % (time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())), sql)) return False def rows2array(self, data): '''transfer tuple to array.''' result = [] for da in data: if type(da) is not dict: raise Exception('Format Error: data is not a dict.') result.append(da) return result def __del__(self): '''free source.''' try: self._cursor.close() self._connect.close() except: pass def close(self): self.__del__() 引用代码1234567891011121314151617181920212223242526272829from MysqlHelper import MysqlHelperif __name__ == '__main__': # 配置信息，其中host, port, user, passwd, db为必需 dbconfig = &#123;'host':'127.0.0.1', 'port': 3306, 'user':'root', 'passwd':'123', 'db':'pytest', 'charset':'utf8'&#125; db = MysqlHelper(dbconfig) # 创建MysqlHelper对象，若连接超时，会自动重连 # 查找(select, show)都使用query()函数 sql_select = \"SELECT * FROM Customer\" result_all = db.query(sql_select) # 返回全部数据 result_count = db.query(sql_select, 'count') # 返回有多少行 result_one = db.query(sql_select, 'one') # 返回一行 # 增删改都使用dml()函数 sql_insert = \"insert into Customer(Cost) values(20)\" result_insert = db.dml(sql_insert) sql_update = \"update Customer set Cost=2 where Id=2\" result_update = db.dml(sql_update) # sql_delete = \"delete from Customer where Id=2\" # result_delete = db.dml(sql_delete) print(result_insert) db.close() # 操作结束，关闭对象","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"mysql插入中文报错","slug":"技术/2015-04-09-mysql插入中文报错","date":"2015-04-09T00:00:00.000Z","updated":"2020-06-09T10:00:01.612Z","comments":true,"path":"2015/04/09/技术/2015-04-09-mysql插入中文报错/","link":"","permalink":"https://ax-codes.github.io/2015/04/09/%E6%8A%80%E6%9C%AF/2015-04-09-mysql%E6%8F%92%E5%85%A5%E4%B8%AD%E6%96%87%E6%8A%A5%E9%94%99/","excerpt":"","text":"报错Incorrect string value: ‘\\xE7\\xA8\\x8B\\xE5\\xBA\\x8F…’ for column ‘title’ at row 1 解决 修改数据库的编码 1alter table tags default character set utf8; 更改列的编码 1alter table tags change title title varchar(50) character set utf8; 然后执行sql发现可以插入了","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"python3用requests爬取网页内容","slug":"技术/2015-04-04-python3用requests爬取网页内容","date":"2015-04-04T00:00:00.000Z","updated":"2020-06-09T10:00:01.612Z","comments":true,"path":"2015/04/04/技术/2015-04-04-python3用requests爬取网页内容/","link":"","permalink":"https://ax-codes.github.io/2015/04/04/%E6%8A%80%E6%9C%AF/2015-04-04-python3%E7%94%A8requests%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9/","excerpt":"","text":"代码123456789101112131415# -*- coding: utf-8 -*-import requestsfrom lxml import etreeimport osimport codecsr = requests.get('http://axss.gitee.io/')r.encoding=\"utf-8\" #解决中文乱码问题html = r.textselector = etree.HTML(html)main = selector.xpath(\"/html/body/main/div[@class='content article-list']\")[0]for item in main: txt = item.xpath(\"./div/h1/a/text()\")[0] print(txt) 总结 xpath 可以直接在谷歌浏览器f12 选择html标签复制 html文本需要先 etree 解析 解决获取到的文本中文乱码问题,给requert对象加上 r.encoding=”utf-8”","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"在使用pip list时出现DEPRECATION 的解决方法","slug":"技术/2015-04-03-在使用pip list时出现DEPRECATION 的解决方法","date":"2015-04-03T00:00:00.000Z","updated":"2020-06-09T10:00:01.611Z","comments":true,"path":"2015/04/03/技术/2015-04-03-在使用pip list时出现DEPRECATION 的解决方法/","link":"","permalink":"https://ax-codes.github.io/2015/04/03/%E6%8A%80%E6%9C%AF/2015-04-03-%E5%9C%A8%E4%BD%BF%E7%94%A8pip%20list%E6%97%B6%E5%87%BA%E7%8E%B0DEPRECATION%20%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"在使用pip list时出现DEPRECATION 的解决方法windows在C:\\Users\\Administrator下建立pip文件夹,在pip下新建pip.ini,添加内容:12[list]format=columns linux在 ~/pip/pip.conf 配置文件中加入下面的语句12[list]format=columns","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"windows安装绿色版mysql的方法","slug":"技术/2015-03-30-windows安装绿色版mysql的方法","date":"2015-03-30T00:00:00.000Z","updated":"2020-06-09T10:00:01.606Z","comments":true,"path":"2015/03/30/技术/2015-03-30-windows安装绿色版mysql的方法/","link":"","permalink":"https://ax-codes.github.io/2015/03/30/%E6%8A%80%E6%9C%AF/2015-03-30-windows%E5%AE%89%E8%A3%85%E7%BB%BF%E8%89%B2%E7%89%88mysql%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"下载 下载地址:https://dev.mysql.com/downloads/mysql/ 配置 新增环境变量:将解压后的文件的bin路径新增到环境变量 新增my.ini配置文件:解压后在文件根目录新建my.ini文件,并新增内容: 12345678910111213141516171819202122232425262728[client] port=3306 # socket = /data/3306/mysql.sock #客户端编码方式，最好和服务端保存一致 loose-default-character-set=utf8 [mysqld] skip-grant-tables #user=mysql port=3306 # socket = /data/3306/mysql.sock # basedir = /usr/local/mysql # datadir = /data/3306/data #mysql根目录 basedir=F:\\mysql-5.7.21-winx64#数据文件存放目录 datadir=F:\\mysql-5.7.21-winx64\\data open_files_limit=10240 #服务端的编码方式 character-set-server=utf8 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [WinMySQLadmin] Server=F:\\mysql-5.7.21-winx64\\bin\\mysqld.exe “F:\\mysql-5.7.21-winx64”是我mysql的路径,你需要改成自己的 注意:在win7中时my.ini需要放到bin目录下,然后注册表的内容为1\"C:\\Program Files\\MySQL\\bin\\mysqld\" MYSQL 安装mysql用管理员权限启动cmd后执行:1mysqld install mysql 开启服务用管理员权限启动cmd后执行:1net start mysql或者直接在windows服务管理界面直接找到mysql服务器右键启动即可 注意:报错一:在这一步开启服务的时候可能会报这一个系统找不到指定文件的错原因和解决方法:解压版没有像安装版 那样指定目录，所以需要更改注册表：HKEY_LOCAL_MACHINE-SYSTEM-CurrentControlSet-services-mysql(服务名)-ImagePath 更改为：”C:\\Program Files\\MySQL\\bin\\mysqld” –defaults-file=”C:\\Program Files\\MySQL\\my.ini” MYSQL然后重新启动mysql 应该就可以了 报错二:在win7启动服务的时候如果报这个错我们需要123mysqld --remove mysqlmysqld --install mysqlmysqld --initialize:这一步如果报错,需要删除mysql根目录下的data文件夹 查找mysql默认密码mysq在5.7版本以上为root用户默认生成了一个临时登录密码，该密码是生成在数据目录下的后缀名为.err的文件里;在my.ini配置文件里我写的数据目录是:1datadir=F:\\mysql-5.7.21-winx64\\data进该文件夹搜索.err的文件然后进文件里搜索”password”找到:2JZv&lt;uC&amp;jwtX 即是mysql默认的密码,使用这个密码我们即可登录mysql 修改初始密码首先用默认初始密码登录root1mysql -uroot -p&lt;br&gt;输入默认密码然后修改12mysql&gt; set password for 用户名@localhost = password('新密码'); mysql&gt; set password for root@localhost = password('123');显示Ok标识修改成功,这样我们就可以新增用户和修改用户密码了 破解Navicar for mysql方法使用 PatchNavicat.exe,打开后选择Navicar for mysql安装的路径的navicat.exe即可PatchNavicat下载","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"},{"name":"数据库","slug":"数据库","permalink":"https://ax-codes.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"pip的安装","slug":"技术/2015-03-24-pip的安装","date":"2015-03-24T00:00:00.000Z","updated":"2020-06-09T10:00:01.605Z","comments":true,"path":"2015/03/24/技术/2015-03-24-pip的安装/","link":"","permalink":"https://ax-codes.github.io/2015/03/24/%E6%8A%80%E6%9C%AF/2015-03-24-pip%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"","text":"windows 安装 pip 在 https://pypi.python.org/pypi/pip#downloads下载源文件 将文件解压后在解压后的文件的根目录执行 python setup.py install,等生成 测试 执行 1pip list 如果没有提示 command not found 则成功 如果提示则需要将python安装跟目录的Scripts配置到环境变量，然后再测试应该就可以了 OS X/Linux 电脑 安装 pip1:python2.7 pip是python的包管理工具，在Python2.7的安装包中，easy_install.py是默认安装的，而pip需要我们手动安装,终端执行:1sudo easy_install pip 2:python3","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"csharp .net面试宝典","slug":"技术/2015-03-19-csharp.net面试宝典","date":"2015-03-19T00:00:00.000Z","updated":"2020-06-09T10:00:01.597Z","comments":true,"path":"2015/03/19/技术/2015-03-19-csharp.net面试宝典/","link":"","permalink":"https://ax-codes.github.io/2015/03/19/%E6%8A%80%E6%9C%AF/2015-03-19-csharp.net%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/","excerpt":"","text":"前言技术类面试、笔试题汇总（整理者：杨中科，部分内容从互联网中整理而来）注：标明*的问题属于选择性掌握的内容，能掌握更好，没掌握也没关系。 下面的参考解答只是帮助大家理解，不用背，面试题、笔试题千变万化，不要梦想着把题覆盖了，下面的题是供大家查漏补缺用的，真正的把这些题搞懂了，才能“以不变应万变”。回答问题的时候能联系做过项目的例子是最好的，有的问题后面我已经补充联系到项目中的对应的案例了。 附件(原文件)点击下载原文件 正文1、简述 private、 protected、 public、 internal 修饰符的访问权限。private : 私有成员, 在类的内部才可以访问。protected : 保护成员，该类内部和继承类中可以访问。public : 公共成员，完全公开，没有访问限制。internal: 当前程序集内可以访问。 2、ADO.NET中的五个主要对象Connection：主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据库中取得数据的。Close和Dispose的区别，Close以后还可以Open，Dispose以后则不能再用。Command：主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在Connection 对象上，也就是Command 对象是透过连接到数据源。DataAdapter：主要是在数据源以及DataSet 之间执行数据传输的工作，它可以透过Command 对象下达命令后，并将取得的数据放入DataSet 对象中。这个对象是架构在Command对象上，并提供了许多配合DataSet 使用的功能。[ ]DataSet：这个对象可以视为一个暂存区（Cache），可以把从数据库中所查询到的数据保留起来，甚至可以将整个数据库显示出来，DataSet是放在内存中的。DataSet 的能力不只是可以储存多个Table 而已，还可以透过DataAdapter对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。DataSet 对象可以说是ADO.NET 中重量级的对象，这个对象架构在DataAdapter对象上，本身不具备和数据源沟通的能力；也就是说我们是将DataAdapter对象当做DataSet 对象以及数据源间传输数据的桥梁。DataSet包含若干DataTable、DataTableTable包含若干DataRow。DataReader：当我们只需要循序的读取数据而不需要其它操作时，可以使用DataReader 对象。DataReader对象只是一次一笔向下循序的读取数据源中的数据，这些数据是存在数据库服务器中的，而不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据，而且这些数据是只读的，并不允许作其它的操作。因为DataReader 在读取数据的时候限制了每次只读取一笔，而且只能只读，所以使用起来不但节省资源而且效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全部传回，故可以降低网络的负载。ADO.NET 使用Connection 对象来连接数据库，使用Command 或DataAdapter对象来执行SQL语句，并将执行的结果返回给DataReader 或 DataAdapter ,然后再使用取得的DataReader 或DataAdapter 对象操作数据结果。 3、列举ASP.NET 页面之间传递值的几种方式。1.使用QueryString, 如….?id=1; response. Redirect()….2.使用Session变量3.使用Server.Transfer4.Cookie传值5.Application传值6.PreviosPage Server.Transfer和Response.Redirect的区别：Server.Transfer是服务器内部的转接，浏览器不知晓；Response.Redirect是有浏览器参与的，所以在地址栏中可以看到地址的变化。 4、C#中的委托是什么？事件是不是一种委托？事件和委托的关系。委托可以把一个方法作为参数代入另一个方法。委托可以理解为指向一个函数的指针。委托和事件没有可比性，因为委托是类型，事件是对象，下面说的是委托的对象（用委托方式实现的事件）和（标准的event方式实现）事件的区别。事件的内部是用委托实现的。因为对于事件来讲，外部只能“注册自己+=、注销自己-=”，外界不可以注销其他的注册者，外界不可以主动触发事件，因此如果用Delegate就没法进行上面的控制，因此诞生了事件这种语法。事件是用来阉割委托实例的，类比用一个自定义类阉割List。事件只能add、remove自己，不能赋值。事件只能+=、-=，不能= 。加分的补充回答：事件内部就是一个private的委托和add、remove两个方法。 面试聊：用Reflector查看.Net的类的内部实现，解决问题。 5、override与重载（overload）的区别重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要。重载（overload）是面向过程的概念。Override 是进行基类中函数的重写。Override是面向对象的概念 6、C#中索引器是否只能根据数字进行索引？是否允许多个索引器参数？参数的个数和类型都是任意的。加分的补充回答：用reflector反编译可以看出，索引器的内部本质上就是set_item、get_item方法。加分的补充回答：回答传智播客.net培训中讲解设计模式中开发的SettingsProvider就是用的string类型的参数名做索引器参数。 7、属性和public字段的区别是什么？调用set方法为一个属性设值，然后用get方法读取出来的值一定是set进去的值吗？属性可以对设值、取值的过程进行非法值控制，比如年龄禁止设值负数，而字段则不能进行这样的设置。虽然一般情况下get读取的值就是set设置的值，但是可以让get读取的值不是set设置的值的，极端的例子。Public Age{get{return 100;}set{}}。加分的补充回答：用reflector反编译可以看出，属性内部本质上就是set_、get_方法，详细参考传智播客.net培训视频中串讲.net基础的部分。123456789101112131415161718class Person&#123; public int Age &#123; get &#123; return 3; &#125; set &#123; &#125; &#125;&#125;Person p1 &#x3D; new Person();p1.Age &#x3D; 30;p1.Age++;Console.Write(p1.Age);&#x2F;&#x2F;输出3 8、三层架构通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。表现层（UI）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候的所见所得。业务逻辑层（BLL）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。数据访问层（DAL）：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等每层之间是一种垂直的关系。三层结构是N层结构的一种，一般来说，层次之间是向下依赖的，下层代码未确定其接口（契约）前，上层代码是无法开发的，下层代码接口（契约）的变化将使上层的代码一起变化。优点： 分工明确，条理清晰，易于调试，而且具有可扩展性。缺点： 增加成本。 9、MVC模式 （*）还是一个UI层的技术MVC(Model View Controller)模型－视图－控制器aspx就是View，视图；Model：DataSet、Reader、对象；Controller：cs代码。 MVC是典型的平行关系，没有说谁在上谁在下的关系，模型负责业务领域的事情，视图负责显示的事情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证什么的应该是在模型里处理了。它强制性的使应用程序的输入、处理和输出分开。MVC最大的好处是将逻辑和页面分离。 10、什么是装箱(boxing)和拆箱(unboxing)？ （*）装箱：从值类型接口转换到引用类型。拆箱：从引用类型转换到值类型。 object obj = null;//引用类型 obj = 1;//装箱，boxing。把值类型包装为引用类型。 int i1 = (int)obj;//拆箱。unboxing 11、什么叫应用程序域(AppDomain) （*） 进程中的小进程一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立（即，从应用程序入口点开始，沿着对象激活的序列的任何位置）。应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行为可以预知。在一个单独的进程中可以存在多个应用程序域。应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。 12、CTS、CLS、CLR分别作何解释（*）CTS：Common Type System 通用系统类型。Int32、Int16→int、String→string、Boolean→boolCLS：Common Language Specification 通用语言规范。不同语言语法的不同。CLR：Common Language Runtime 公共语言运行时，就是.Net提供的那些 类。 13、在.net中类(class)与结构(struct)的异同？Class可以被实例化,属于引用类型,是分配在内存的堆上的。类是引用传递的。Struct属于值类型,是分配在内存的栈上的。结构体是复制传递的。加分的回答：Int32、Boolean等都属于结构体。 14、堆和栈的区别？栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；局部值类型变量、值类型参数等都在栈内存中。堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。 15、能用foreach遍历访问的对象的要求需要实现IEnumerable接口或声明GetEnumerator方法的类型。 16、GC是什么? 为什么要有GC?GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。GC只能处理托管内存资源的释放，对于非托管资源则不能使用GC进行回收，必须由程序员手工回收，一个例子就是FileStream或者SqlConnection需要程序员调用Dispose进行资源的回收。要请求垃圾收集，可以调用下面的方法：GC.Collection()一般不需要手动调用GC.Collection()。加分的回答：有一次用OLEAutomation的方式操作Excel的时候，Excel经常不能正常退出，在MSDN网站上找到官方解答说要调用一下GC.Collection()，至于为什么这样就可以也没找到答案。 17、String s = new String(“xyz”);创建了几个String Object?两个对象，一个是“xyx”,一个是指向“xyx”的引用对象。String s1=”d” string s2=”d” 是一个string对象，因为字符串拘留池，（因为字符串不可变，可以共享）18、值类型和引用类型的区别？1.将一个值类型变量赋给另一个值类型变量时，将复制包含的值。引用类型变量的赋值只复制对对象的引用，而不复制对象本身。2.值类型不可能派生出新的类型：所有的值类型均隐式派生自 System.ValueType。但与引用类型相同的是，结构也可以实现接口。3.值类型不可能包含 null 值：然而，可空类型功能允许将 null 赋给值类型。4.每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值。 19、C#中的接口和类有什么异同。 不同点：不能直接实例化接口。接口不包含方法的实现。接口可以多继承，类只能单继承。类定义可在不同的源文件之间进行拆分。相同点：接口、类和结构都可以从多个接口继承。接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。接口和类都可以包含事件、索引器、方法和属性。 20、abstract class和interface有什么区别? 相同点：都不能被直接实例化，都可以通过继承实现其抽象方法。不同点：接口支持多继承；抽象类不能实现多继承。接口只能定义行为；抽象类既可以定义行为，还可能提供实现。接口可以用于支持回调（CallBack）；抽象类不能实现回调，因为继承不支持。接口只包含方法(Method)、属性(Property)、索引器(Index)、事件(Event)的签名，但不能定义字段和包含实现的方法；抽象类可以定义字段、属性、包含有实现的方法。接口可以作用于值类型(Struct)和引用类型(Class)；抽象类只能作用于引用类型。例如，Struct就可以继承接口，而不能继承类。加分的补充回答：讲设计模式的时候SettingsProvider的例子。 21、是否可以继承String类?String类是sealed类故不可以继承。 22、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行?会执行，在return前执行。加分的补充回答（也助记）：读取数据库中数据的条数的程序123456789101112public int QueryCount()&#123; ….. try &#123; return cmd.ExecuteScalar(); &#125; finally &#123; cmd.Dispose(); &#125;&#125; 如果C#设计的是先执行cmd.Dispose()再执行return就会出现return执行失败了，因为cmd已经Dispose了。 23、new 关键字用法（*）new 运算符 用于创建对象和调用构造函数。new 修饰符 用于向基类成员隐藏继承成员。看视频例子 ，子类继承父类 但是没有 重写父类而是new了一个新的只是名字相同 ，属于引藏了基类成员new 约束 用于在泛型声明中约束可能用作类型参数的参数的类型。 24、如何把一个Array复制到ArrayList里（）12实现1 string[] s &#x3D;&#123; &quot;111&quot;, &quot;22222&quot; &#125;; ArrayList list &#x3D; new ArrayList(); list.AddRange(s);实现2 string[] s &#x3D;&#123; &quot;111&quot;, &quot;22222&quot; &#125;; ArrayList list &#x3D; new ArrayList(s);25、描述线程与进程的区别？（）1.线程(Thread)与进程（Process）二者都定义了某种边界，不同的是进程定义的是应用程序与应用程序之间的边界，不同的进程之间不能共享代码和数据空间，而线程定义的是代码执行堆栈和执行上下文的边界。2.一个进程可以包括若干个线程，同时创建多个线程来完成某项任务，便是多线程。而同一进程中的不同线程共享代码和数据空间。用一个比喻来说，如果一个家庭代表一个进程，在家庭内部，各个成员就是线程，家庭中的每个成员都有义务对家庭的财富进行积累，同时也有权利对家庭财富进行消费，当面对一个任务的时候，家庭也可以派出几个成员来协同完成，而家庭之外的人则没有办法直接消费不属于自己家庭的财产。加分的回答：举例，传智播客的.Net培训中用多线程（ThreadPool）实现网站蜘蛛的案例。 26、什么是强类型，什么是弱类型？哪种更好些？为什么?12345678C#中int i&#x3D;3;i&#x3D;&quot;a&quot;;不可以JavaScript中var i&#x3D;3;i&#x3D;&quot;a&quot;;可以强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。弱类型更灵活，但是效率低，而且出错概率高一般用于编译型编程语言，如c++,java,c#,pascal等,弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，多用于解释型编程语言，如javascript,vb等加分的补充回答：引用传智播客.net培训呼叫中心项目中用强类型DataSet的例子，侃一通用强类型DataSet是多么方便。 27、什么是反射?程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能够动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类型的字段属性。它是在运行时创建和使用类型实例 反射通常具有以下用途。 （1）使用Assembly定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例。（2）使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。（3）使用ConstructorInfo了解构造函数的名称、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。使用Type的GetConstructors或GetConstructor方法来调用特定的构造函数。（4）使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。使用Type的GetMethods或GetMethod方法来调用特定的方法。（5）使用FiedInfo了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值。（6）使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。（7）使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。（8）使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。 加分的补充回答：聊用反射实现编辑器动态插件和如鹏网项目中插件体系实现第三方支付和定时任务的案例。 28、int、DateTime、string是否可以为null?int、DateTime不能，因为其为Struct类型，而结构属于值类型，值类型不能为null,只有引用类型才能被赋值null。string可以为null。 29、using关键字有什么用？什么是IDisposable？using可以声明namespace的引入，还可以实现非托管资源的释放，实现了IDisposiable的类在using中创建，using结束后会自动调用该对象的Dispose方法，释放资源。加分的补充回答：using其实等价于try……finally，用起来更方便。int?→Nullable 30、Assembly.Load(“foo.dll”); 这句话是否正确？（*）错误，正确的应该是Assembly.Load(“foo”); 或者Assembly.LoadFrom(“foo.dll”); 31、XML 与 HTML 的主要区别 XML是区分大小写字母的，HTML不区分。 在HTML中，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略或者之类的结束 标记。在XML中，绝对不能省略掉结束标记。 12HTML：&lt;img src=\"1.jpg\"&gt;&lt;br&gt;&lt;br&gt;XML：&lt;img src=\"1.jpg\"&gt;&lt;/img&gt;&lt;br/&gt;&lt;br/&gt; 在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个 / 字符作为结尾。这样分析器就知道不用 查找结束标记了。 在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。 在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。 XML是用来存储和传输数据的HTML是用来显示数据的 32、string str = null 与 string str = “”说明其中的区别。答：string str = null 是不给他分配内存空间,而string str = \\”\\” 给它分配长度为空字符串的内存空间。 string str = null没有string对象，string str = “”有一个字符串对象。 33.写出一条Sql语句：取出表A中第31到第40记录（SQLServer,以自动增长的ID作为主键,注意：ID可能不是连续的。12345答：解1: select top 10 * from A where id not in (select top 30 id from A) 解2: select top 10 * from A where id &gt; (select max(id) from (select top 30 id from A )as A) 解答3：ROW_NUMBER（推荐）Select * from(select row_number() over(order by id desc) as rows * from A order by id desc)Where rows between 31 and 4034.面向对象的语言具有____性、_性、____性答：封装、继承、多态。不要背，脑子中要有联想。 35.在.Net中所有可序列化的类都被标记为_?答：[serializable]36.在.Net托管代码中我们不用担心内存漏洞，这是因为有了__?答：GC。 37、什么叫应用程序域？什么是受管制的代码？什么是托管代码？什么是强类型系统？什么是装箱和拆箱？什么是重载？CTS、CLS和CLR分别作何解释？应用程序域为安全性、可靠性、版本控制以及卸载程序集提供了隔离边界。应用程序域通常由运行库宿主创建，运行库宿主负责在运行应用程序之前引导公共语言运行库。应用程序域提供了一个更安全、用途更广的处理单元，公共语言运行库可使用该单元提供应用程序之间的隔离。受管制的代码：在.Net环境中运行的任何代码都是受管制的代码（managed code），.Net外部的代码也运行在windows上，这些代码称为未受管制的代码（unmanaged code）。使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。强类型语言是能够禁止任何违反类型系统的代码的语言，或者说是能够捕获所有违反类型系统的错误的语言。我们说C++相对于C是强类型的，是因为C++禁止了一些C中的隐式转换，比如将void*转换为任意的指针类型。装箱和拆箱使值类型能够被视为对象。对值类型装箱将把该值类型打包到 Object 引用类型的一个实例中。这使得值类型可以存储于垃圾回收堆中。拆箱将从对象中提取值类型。每个类型成员都有一个唯一的签名。方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。只要签名不同，就可以在一种类型内定义具有相同名称的多种方法。当定义两种或多种具有相同名称的方法时，就称作重载。CTS通用类型系统 (common type system)一种确定公共语言运行库如何定义、使用和管理类型的规范。CLR公共语言运行库.NET Framework 提供了一个称为公共语言运行库的运行时环境，它运行代码并提供使开发过程更轻松的服务。CLS公共语言规范要和其他对象完全交互，而不管这些对象是以何种语言实现的，对象必须只向调用方公开那些它们必须与之互用的所有语言的通用功能。为此定义了公共语言规范 (CLS)，它是许多应用程序所需的一套基本语言功能。 38、什么是code-Behind技术。就是代码隐藏，在ASP.NET中通过ASPX页面指向CS文件的方法实现显示逻辑和处理逻辑的分离，这样有助于web应用程序的创建。比如分工，美工和编程的可以个干各的，不用再像以前asp那样都代码和html代码混在一起，难以维护。 39、接口是一种引用类型，在接口中可以声明（ a），但不可以声明公有的域或私有的成员变量。 a) 方法、属性、索引器和事件； c) 索引器和字段； d) 事件和字段； 在ADO.NET中，对于Command对象的ExecuteNonQuery()方法和ExecuteReader()方法，下面叙述错误的是（c）。a) insert、update、delete等操作的Sql语句主要用ExecuteNonQuery()方法来执行；b) ExecuteNonQuery()方法返回执行Sql语句所影响的行数。c) Select操作的Sql语句只能由ExecuteReader()方法来执行；d) ExecuteReader()方法返回一个DataReder对象； 解答：ExecuteScalar→select getdate()。 下列关于C#中索引器理解正确的是(c )a) 索引器的参数必须是两个或两个以上b) 索引器的参数类型必须是整数型c) 索引器没有名字d) 以上皆非 要创建多文档应用程序，需要将窗体的(d )属性设为true。a) DrawGrid；b) ShowInTaskbar；c) Enabled；d) IsMdiContainer； 如果设treeView1=new TreeView()，则treeView1.Nodes.Add(“根节点”)返回的是一个 (a)类型的值。a) TreeNode；b) int；c) string；d) TreeView； 下面关于XML的描述错误的是（d）。a) XML提供一种描述结构化数据的方法；b) XML 是一种简单、与平台无关并被广泛采用的标准；c) XML文档可承载各种信息；d) XML只是为了生成结构化文档； 45、以下的C#代码，试图用来定义一个接口：123456789 public interface IFile &#123; int A; int delFile() &#123; A &#x3D; 3; &#125; void disFile(); &#125; 关于以上的代码，以下描述错误的是(d )。 a) 以上的代码中存在的错误包括：不能在接口中定义变量，所以int A代码行将出现错误； b) 以上的代码中存在的错误包括：接口方法delFile是不允许实现的，所以不能编写具体的实现函数； c) 代码void disFile();声明无错误，接口可以没有返回值； d) 代码void disFile();应该编写为void disFile(){}； 空和null不一样。 46 在ASP.NET中有Button控件myButton，要是单击控件时，导航到其他页面http://www.abc.com, 正确的代码为( c)。 a) private void myButton_Click(object sender, System.EventArgs e){Redirect(“http://www.abc.com”);} b) private void myButton_Click(object sender, System.EventArgs e){Request.Redirect(“http://www.abc.com”);} c) private void myButton_Click(object sender, System.EventArgs e){Reponse.Redirect(“http://www.abc.com”);} d) private void myButton_Click(object sender, System.EventArgs e){Request.Redirect(“http://www.abc.com”);return true;} 声明一个委托public delegate int myCallBack(int x); 则用该委托产生的回调方法的原型应该是（b ）。a) void myCallBack(int x) ；b) int receive(int num) ；c) string receive(int x) ；d) 不确定的； 48.StringBuilder 和 String 的区别？答：String 在进行运算时（如赋值、拼接等）会产生一个新的实例，而 StringBuilder 则不会。所以在大量字符串拼接或频繁对某一字符串进行操作时最好使用 StringBuilder，不要使用 String 如果要操作一个不断增长的字符串，尽量不用String类,改用StringBuilder类。两个类的工作原理不同:String类是一种传统的修改字符串的方式，它确实可以完成把一个字符串添加到另一个字符串上的工作没错,但是在.NET框架下，这个操作实在是划不来。因为系统先是把两个字符串写入内存，接着删除原来的String对象，然后创建一个String对象，并读取内存中的数据赋给该对象。这一来二去的，耗了不少时间。而使用System.Text命名空间下面的StringBuilder类就不是这样了，它提供的Append方法，能够在已有对象的原地进行字符串的修改，简单而且直接。当然，一般情况下觉察不到这二者效率的差异，但如果你要对某个字符串进行大量的添加操作，那么StringBuilder类所耗费的时间和String类简直不是一个数量级的。 49、.请叙述属性与索引器的区别。 （*）没啥意义属性 索引器 通过名称标识。 通过签名标识。 通过简单名称或成员访问来访问。 通过元素访问来访问。 可以为静态成员或实例成员。 必须为实例成员。 属性的 get 访问器没有参数。 索引器的 get 访问器具有与索引器相同的形参表。 属性的 set 访问器包含隐式 value 参数。 除了 value 参数外，索引器的 set 访问器还具有与索引器相同的形参表。 50.请叙述const与readonly的区别。（*） const 关键字用于修改字段或局部变量的声明。它指定字段或局部变量的值不能被修改。常数声明引入给定类型的一个或多个常数。（常量不能是算出来的）readonly可以 const数据成员的声明式必须包含初值，且初值必须是一个常量表达式。因为它是在编译时就需要完全评估。 const成员可以使用另一个const成员来初始化，前提是两者之间没有循环依赖。 readonly在运行期评估赋值，使我们得以在确保“只读访问”的前提下，把object的初始化动作推迟到运行期进行。 readonly 关键字与 const 关键字不同： const 字段只能在该字段的声明中初始化。readonly 字段可以在声明或构造函数中初始化。因此，根据所使用的构造函数，readonly 字段可能具有不同的值。另外，const 字段是编译时常数，而 readonly 字段可用于运行时常数。readonly 只能在声明时或者构造函数里面初始化，并且不能在 static 修饰的构造函数里面。 （不三不四的例子 ） 参考资料：http://www.cnblogs.com/royenhome/archive/2010/05/22/1741592.htmlhttp://www.cnblogs.com/jams742003/archive/2010/03/23/1692913.htmlhttp://www.cnblogs.com/wayfarer/archive/2006/04/27/386658.html 51． 请解释ASP。NET中的web页面与其隐藏类之间的关系？一个ASP.NET页面一般都对应一个隐藏类,一般都在ASP.NET页面的声明中指定了隐藏类例如一个页面Tst1.aspx的页面声明如下&lt;%@ Page language=”c#” Codebehind=”Tst1.aspx.cs” AutoEventWireup=”false” Inherits=”T1.Tst1” %&gt;Codebehind=”Tst1.aspx.cs” 表明经编译此页面时使用哪一个代码文件Inherits=”T1.Tst1” 表用运行时使用哪一个隐藏类 52． 什么是viewstate，能否禁用？是否所用控件都可以禁用?Viewstate是保存状态的一种机制，EnableViewState属性设置为false即可禁用。最有力的举例子：Label、TextBox在禁用ViewState后不同的表现来说明。 53、你对web service的体会？答：如果自己写的一些程序也希望别人可以通过Web服务来使用，也可以把自己编写的方法贴上标签[WebMethed]来实现Web 服务。[是当编写程序时，希望实现一些别的网站已经实现过的，也用Web服务可视成XML语言的编码。可以使用别人的编码生成的XML找到自己需要的信息，来实现自己编写的程序的一些功能。把传智播客.net培训的如鹏网项目中用WebService实现管理客户端的例子说出来。SOAP、WSDL。 54您在什么情况下会用到虚方法？它与接口有什么不同？答案：子类重新定义父类的某一个方法时，必须把父类的方法定义为virtual在定义接口中不能有方法体，虚方法可以。实现时,子类可以不重新定义虚方法，但如果一个类继承接口，那必须实现这个接口。 讲到这里了 不定项选择：(1) 以下叙述正确的是： B CA. 接口中可以有虚方法。B. 一个类可以实现多个接口。 C. 接口不能被实例化。 D. 接口中可以包含已实现的方法。(2) 从数据库读取记录，你可能用到的方法有：B C D A. ExecuteNonQuery B. ExecuteScalar C. Fill D. ExecuteReader（3）.对于一个实现了IDisposable接口的类，以下哪些项可以执行与释放或重置非托管资源相关的应用程序定义的任务？(多选) ( ABC )A.Close B.Dispose C.FinalizeD.using E.Quit（4）以下关于ref和out的描述哪些项是正确的？(多选) ( ACD )A.使用ref参数，传递到ref参数的参数必须最先初始化。B.使用out参数，传递到out参数的参数必须最先初始化。C.使用ref参数，必须将参数作为ref参数显式传递到方法。D.使用out参数，必须将参数作为out参数显式传递到方法。讲到这里 单项选择：（1）下列选项中，（C）是引用类型。a)enum类型 b)struct类型 c)string类型 d)int类型 （2）.关于ASP.NET中的代码隐藏文件的描述正确的是（C）a)Web窗体页的程序的逻辑由代码组成，这些代码的创建用于与窗体交互。编程逻辑唯一与用户界面不同的文件中。该文件称作为“代码隐藏”文件，如果用C＃创建，该文件将具有“.ascx.cs”扩展名。b)项目中所有Web窗体页的代码隐藏文件都被编译成.EXE文件。c)项目中所有的Web窗体页的代码隐藏文件都被编译成项目动态链接库（.dll）文件。d)以上都不正确。 （3）.下列描述错误的是（D）a)类不可以多重继承而接口可以；b)抽象类自身可以定义成员而接口不可以；c)抽象类和接口都不能被实例化；d)一个类可以有多个基类和多个基接口； 57、DataReader和DataSet的异同？DataReader使用时始终占用SqlConnection,在线操作数据库每次只在内存中加载一条数据,所以占用的内存是很小的是只进的、 只读的DataSet则是将数据一次性加载在内存中.抛弃数据库连接..读取完毕即放弃数据库连接(非连接模式)DataSet将数据全部加载在内存中.所以比较消耗内存…但是确比DataReader要灵活..可以动态的添加行,列,数据.对数据库进行 回传更新操作(动态操作读入到内存的数据) 58、public static const; int A = 1;这段代码有错误么？错误：const不能被修饰为static ；因为定义为常量 （const ）后就是静态的（static ）。 59传入某个属性的set方法的隐含参数的名称是什么？value，它的类型和属性所声名的类型相同。 60、C#支持多重继承么？类之间不支持，接口之间支持。类对接口叫做实现，不叫继承。 61、C#中所有对象共同的基类是什么？System.Object 62、通过超链接怎样传递中文参数？答：用URL编码，通过QueryString传递，用urlencode编码 用urldecode解码 63、string、String；int、Int32；Boolean、bool的区别String、Int32、Boolean等都属于.Net中定义的类，而string、int、bool相当于C#中对这些类定义的别名。CTS。 64、Server.Transfer和Response.Redirect的区别是什么？（常考）答: Server.Transfer仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；Response.Redirect则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。Server.Transfer是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 这个过程中浏览器和Web服务器之间经过了一次交互。 Response.Redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求。这个过程中浏览器和Web服务器之间经过了两次交互。 65、不是说字符串是不可变的吗？string s=”abc”;s=”123”不就是变了吗？（传智播客.Net培训班原创模拟题）String是不可变的在这段代码中，s原先指向一个String对象，内容是 “abc”，然后我们将s指向”123”，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”123”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。 66、是否可以从一个static方法内部发出对非static方法的调用？不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不能发出对非static方法的调用。 67、.Net中会存在内存泄漏吗，请简单描述。 (*)所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。.Net中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。虽然.Net可以回收无用的对象，但是.Net仍然存在由于使用不当导致的内存泄露问题。.Net中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是.Net中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是.Net中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局Dictionary对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。formManager{ public static IList forms = new …..;}扩展：使用弱引用那么及时被引用也可以被回收。 68说出一些常用的类、接口，请各举5个要让人家感觉你对.Net开发很熟，所以，不能仅仅只列谁都能想到的那些东西，要多列你在做项目中涉及的那些东西。就写你最近写的那些程序中涉及的那些类。常用的类：StreamReader、WebClient、Dictionary&lt;K,V&gt;、StringBuilder、SqlConnection、FileStream、File、Regex、List string常用的接口：IDisposable、IEnumerable、IDbConnection、IComparable、ICollection、IList、IDictionary要出乎意料！不要仅仅完成任务！ 69、BS与CS的联系与区别。C/S是Client/Server的缩写。客户端需要安装专用的客户端软件。B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。C/S 与 B/S 区别：１）．硬件环境不同: C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务. B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行２)．对安全要求不同 C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息. B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。3)．处理问题不同 C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统。C/S的客户端由于是本地程序，因此和本地硬件、程序的交互性很强，比如可以控制本机的其他程序、可以读写本地磁盘文件、可以与硬件交互。 B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小，正应为如此B/S很难和本地硬件、程序、文件进行交互，比如很难控制本机的其他程序、很难读写本地磁盘文件、很难与硬件交互，当然可以用ActiveX技术解决，比如网银等就是这么解决的，这样做的问题就是可能会被客户拒绝，而且只局限于Windows操作系统。 C/S也分为两层架构和三层架构。两层架构：客户端程序程序直连数据库；三层架构：客户端访问服务端的服务，主要逻辑代码写在服务端的服务中，然后服务端服务再去访问数据库，Oracle版分布式呼叫中心，WCF。 70、编写一个单例（Singleton）类。参考复习ppt。把构造函数设置为private，设置一个public、static的对象实例12345public FileManager&#123; private FileManager()&#123;&#125; public static FileManager Instance &#x3D; new FileManager();&#125; 扩展：搜“C# Singleton” 71、什么是sql注入？如何避免sql注入？用户根据系统的程序构造非法的参数从而导致程序执行不是程序员期望的恶意SQL语句。使用参数化的SQL就可以避免SQL注入。详细参考复习ppt。举例子，摆事实！1’ or 1=1 72、数据库三范式是什么?传智播客风格的非严谨却一下子明了的解答方式：第二范式：表必须有主键。第三范式：表引用其他的表必须通过主键引用。 73、说出一些数据库优化方面的经验?索引内部原理：想象成Dictionary，插入、删除、更新的速度慢了，加上索引也多占用了空间，查询的速度快了。加上索引以后速度提升非常明显。（1）在经常检索的字段上（select from Person where Name=@Name）使用索引提高查询速度。（2）select中只列出必要的字段，而不是。（3）避免隐式类型转换造成的全表扫描，在索引上使用函数也会造成全表扫描（因为索引只是为字段建立的，一旦使用表达式或者函数，那么索引就是失效了，当然也可以使用“函数索引”、“表达式索引”解决这个问题），使用索引不一定能提高查询速度。（4）避免在索引列上使用计算（where Name+‘A‘=@MyName）加分的回答：不进行无意义优化，根据性能查看器的报表，对最耗时的SQL进行优化。 74、什么是数据库事务？事务三个特性：一致性、原子性、隔离性。几个SQL语句，要么全部执行成功，要么全部执行失败。举例就用最经典的银行转账的例子就行，然后再举一个项目中用的例子：传智播客.net培训中批量导入客户数据的时候要么全部导入成功，要么全部导入失败。事务的三个操作：Begin、Commit、RollBack。取刚插入数据的id值，就要用事务来隔离：Insert 和select top 1 id from …. 75、谈谈你对设计模式的理解（传智播客.Net培训班原创模拟题）世界上本没有模式，用的人多了，也就有了模式。不用刻意记每种模式的名字，手中无模式，心中有模式。大部分设计模式就是接口、抽象类的一个组合。ADO.Net基于接口编程，SafeDbCommand、SafeConnection。SettingsProvider。没必要记模式的名字。举例：传智播客.net培训时SettingsProvider、第三方支付的例子。 76、谈谈ViewState。谈谈对ASP.Net原理的理解。谈谈ASP.Net生命周期。Label、Textbox在禁用ViewState的时候自增的不同表现Http是无状态的，WebForm为了实现基于http的“有状态”从而简化开发，ViewState用来在两次请求间保持状态。页面返回前将界面的状态序列化到ViewState中，这样就将状态保存在了浏览器中，下次页面提交的时候会顺便再将ViewState提交到服务器，这样服务器就根据ViewState还原了状态，这样WebForm开发就像有状态一样了。谈谈自定义AutoInc控件。 77、post、get的区别get的参数会显示在浏览器地址栏中，而post的参数不会显示在浏览器地址栏中；使用post提交的页面在点击【刷新】按钮的时候浏览器一般会提示“是否重新提交”，而get则不会；用get的页面可以被搜索引擎抓取，而用post的则不可以；用post可以提交的数据量非常大，而用get可以提交的数据量则非常小(2k)，受限于网页地址的长度。用post可以进行文件的提交，而用get则不可以。 参考阅读：http://www.cnblogs.com/skynet/archive/2010/05/18/1738301.html 78、下面的程序执行结果是什么？（传智播客.Net培训班原创模拟题）1234567891011121314class Person&#123; public int Age &#123; get; set; &#125;&#125;int i1 &#x3D; 20;int i2 &#x3D; i1;i1++;Console.WriteLine(i2);Person p1 &#x3D; new Person();p1.Age &#x3D; 20;Person p2 &#x3D; p1;p1.Age++;Console.WriteLine(p2.Age);答案：2021 解释：引用类型和值类型的区别。 79、Http默认的端口号是（80）、Ftp默认的端口号是（21）、SQLServer的默认端口号是（1433）（传智播客.Net培训班原创模拟题）80、运算符++a表示（先将a加1，然后表达式的值为a加1后的值），i++表示（表达式的值为a，然后a加1）。81、下面程序的执行结果是什么？（传智播客.Net培训班原创模拟题）1234int i &#x3D; 10;Console.WriteLine(i++);Console.WriteLine(++i);Console.WriteLine(i&#x3D;20);答案：101220解答：前两个参考第80题，i++表达式的值为i自增之前的值，所以打印10，执行完成后i变成11，执行++i的时候表达式的值为自增以后的值12。C#中赋值表达式的值为变量被赋值的值，因此最后一个就输出i赋值后的值20while((line=reader.ReadLine())!=null){} 82、如果不用VisualStudio，用哪个命令行编译C#程序？（*）（传智播客.Net培训班原创模拟题）答：csc.exe。 83、下列哪个名词和WebService不直接相关？（B）（传智播客.Net培训班原创模拟题）A、UDDIB、GUIDC、WSDLD、SOAP SOAP和HTTP的关系：SOAP基于Http协议的，和普通网页不同的是网页返回HTML，SOAP则是符合SOAP协议的XML数据。 84、.Net Framework中的类是专门供C#调用的是吗？（传智播客.Net培训班原创模拟题）答：错。VB.Net等语言都可以调用.Net Framework中的类。CTS、CLS。 85、开放性问题：说出尽可能多的基于.Net Framework的语言。（*）（传智播客.Net培训班原创模拟题）参考解答：C#、VB.Net、F#、PowerShell、IronPython、J#、Ruby.Net 86、.Net、ASP.Net、C#、VisualStudio之间的关系是什么？（传智播客.Net培训班原创模拟题）答：.Net一般指的是.Net Framework，提供了基础的.Net类，这些类可以被任何一种.Net编程语言调用，.Net Framework还提供了CLR、JIT、GC等基础功能。ASP.Net是.Net中用来进行Web开发的一种技术，ASP.Net的页面部分写在aspx 文件中，逻辑代码通常通过Code-behind的方式用C#、VB.Net等支持.Net的语言编写。C#是使用最广泛的支持.Net的编程语言。除了C#还有VB.Net、IronPython等。VisualStudio是微软提供的用来进行.Net开发的集成开发环境（IDE），使用VisualStudio可以简化很多工作，不用程序员直接调用csc.exe等命令行进行程序的编译，而且VisualStudio提供了代码自动完成、代码高亮等功能方便开发。除了VisualStudio，还有SharpDevelop、MonoDevelop等免费、开源的IDE，VisualStudio Express版这个免费版本。 87、AJAX解决什么问题？如何使用AJAX？AJAX有什么问题需要注意？项目中哪里用到了AJAX？（传智播客.Net培训班原创模拟题）答：AJAX解决的问题就是“无刷新更新页面”，用传统的HTML表单方式进行页面的更新时，每次都要将请求提交到服务器，服务器返回后再重绘界面，这样界面就会经历：提交→变白→重新显示这样一个过程，用户体验非常差，使用AJAX则不会导致页面重新提交、刷新。AJAX最本质的实现是在Javascript中使用XMLHttpRequest进行Http的请求，开发中通常使用UpdatePanel、JQuery等方式简化AJAX的开发，UpdatePanel的方式实现AJAX最简单，但是数据通讯量比较大，因为要来回传整个ViewState，而且不灵活，对于复杂的需求则可以使用JQuery提供的ajax功能。UpdatePanel的内部原理。AJAX最重要的问题是无法跨域请求(www.rupeng.com →so.rupeng.com)，也就是无法在页面中向和当前域名不同的页面发送请求，可以使用在当前页面所在的域的服务端做代理页面的方式解决。在如鹏网项目中发帖的时候显示相关帖的功能、站内搜索项目中显示搜索Suggestion、数据采集项目中都用到了AJAX。88、NET通过对各语言先编译成（ IL），然后再执行时用（ JIT）将其编译成本地平台代码，来实现异构平台下对象的互操作。（*）89、编写正则表达式验证一个字符串是否为Email。复习正则表达式部分的知识。90、Application 、Cookie和 Session 两种会话有什么不同？答：Application是用来存取整个网站全局的信息，而Session是用来存取与具体某个访问者关联的信息。 91、开放式问题：你经常访问的技术类的网站是什么？博客园（www.cnblogs.com）、csdn、codeplex、codeproject、msdn文档、msdn论坛（遇到问题先到网上搜解决方案，还不行就问同事，同事也解决不了就去MSDN论坛提问，一定能得到解决） 92、你对.net的GC的理解GC是.Net的垃圾收集器，可以进行内存资源的回收，程序员无需关心资源的回收，当一个对象没有任何引用的时候就可以被回收了。一个对象可以被回收并不意味着一定会被立即回收，GC会选择时机进行回收。可以调用GC.Collect()让GC立即回收。GC不能回收非托管资源，对于非托管资源一般都实现了IDisposable接口，然后使用using关键字进行资源的回收。 93、请写一个SQL语句：从user表中取出name列中的起始字符是“北京”的全部记录select * from [user] wherer name like’北京%’ 94、请你简单的说明数据库建立索引的优缺点使用索引可以加快数据的查询速度，不过由于数据插入过程中会建索引，所以会降低数据的插入、更新速度，索引还会占磁盘空间。 95、什么是WEB服务控件？使用WEB服务控件有那些优势、劣势？web服务控件就是可以在服务器执行的控件，优势在于可以回传数据（ViewState），带有事件驱动（doPostBack），简化了Html标签的使用，使得开发ASP.net程序可以像开发Winform程序一样简单。Web服务控件最终还是被渲染（Render）为Html标签。使用WEB服务控件的劣势是会生成一些无用的属性、ViewState等，不利于SEO，一般在内网系统或者互联网系统的后台中使用WEB服务控件。如果没有复杂的服务器交互动作，就不用Web服务器控件。runat=server的HTML控件有什么特点：路径不用程序员解析，可以使用“~”来虚拟路径。 96、下面程序的执行结果是什么？（传智播客.Net培训班原创模拟题）1234int i &#x3D; 10;if (i &lt;&#x3D;0) ; Console.WriteLine(&quot;i必须大于0&quot;);Console.WriteLine(&quot;ok&quot;);答案：i必须大于0ok 解答：注意if (i &lt;=0)后面的“;”，由于有了“;”，所以Console.WriteLine(“i必须大于0”)不再是和if一起的一部分，而是独立的语句。for循环也是如此。 97、下面程序的执行结果是什么？（传智播客.Net培训班原创模拟题）（*）1234567891011121314151617181920static void Main(string[] args)&#123; Console.WriteLine(Calc()); Console.ReadKey();&#125;static int Calc()&#123; int i &#x3D; 0; try &#123; return i; &#125; finally &#123; Console.WriteLine(&quot;finally&quot;); i++; &#125;&#125;答案：finally0 解释：参考第22题的值，return先执行，finally后执行，所以return的值是没有i++之前的0。注意并不是return的时候函数真的就“返回、执行结束”了，return只是标记函数的返回值是0，标记完了还会执行finally中的代码，只有finally中的代码执行完成后函数才真正的返回。 98、开放式问题：工作中遇到不懂的问题是怎样去解决的？（传智播客.Net培训班原创模拟题）参考解答：首先到百度上搜索中文的资料，一般都可以找到解决方案，如果还找不到解决方案就到google上搜索英文的资料，如果还没有解决方案就请教同事，如果同事也没有解决方案，就将问题提交到MSDN论坛。 99、开放性问题：能说出尽可能多的数据库管理系统？（传智播客.Net培训班原创模拟题）参考解答：MSSQLServer、Oracle、Access、DB2、Sybase 100、开放性问题：你能说出尽可能多的你听说过的编程语言？（传智播客.Net培训班原创模拟题）（*）参考解答：C#、VB.Net、Ada、Cobol、C、C++、Delphi、Erlang、F#、Fortran、Java、JavaScript、Pascal、Python、PowerShell、Ruby、Smalltalk。 101、请翻译下面的文章（*）The BaseDataBoundControl is the root of all data-bound control classes. It defines the DataSource and DataSourceID properties and validates their assigned content. DataSource accepts enumerable objects obtained and assigned the ASP.NET 1.x way. Mycontrol1.DataSource = dataSet; Mycontrol1.DataBind(); DataSourceID is a string and refers to the ID of a bound data source component. Once a control is bound to a data source, any further interaction between the two (in both reading and writing) is handled out of your control and hidden from view. This is both good and bad news at the same time. It is good (rather, great) news because you can eliminate a large quantity of code. The ASP.NET framework guarantees that correct code executes and is written according to recognized best practices. You’re more productive because you author pages faster with the inherent certainty of having no subtle bugs in the middle. If you don’t like this situation—look, the same situation that many ASP.NET 1.x developers complained about—you can stick to the old-style programming that passes through the DataSource property and DataBind method. Also in this case, the base class saves you from common practices even though the saving on the code is less remarkable. 参考翻译（自我感觉翻译的很烂，仅供参考。）：BaseDataBoundControl是所有的数据绑定控件类的根类。它定义了DataSource、DataSourceID两个属性，并且对为它们赋值的内容进行验证。DataSource属性接受读取、设置ASP.Net 1.x方式的IEnumerable 对象。Mycontrol1.DataSource = dataSet;Mycontrol1.DataBind();DataSourceID 是一个字符串，引用绑定的数据源控件的ID。一旦一个控件绑定到了数据源，这两者之间的任何交互（读和写）都会在你的控件之外被处理，并且被隐藏起来。这既是好消息也是坏消息。ASP.Net框架保证代码按照最佳实践进行代码的执行、编写。你会更加高效，因为你编写了更快的、没有任何错误的分页代码。如果你不喜欢这样的行为（看，就和ASP.Net 1.x开发人员抱怨的一样），你仍然可以使用老的编程风格，也就是将对象传递给DataSource属性，然后调用DataBind方法。另外在这种情况下，基类可以帮你避免常规的做法，即使看起来改进不明显。 102、在下述选项时,没有构成死循环的程序是 (C)A.int i=100;while (1) { i=i%100+1; if (i&gt;100) break; }B.for (;;);C.int k=1000; do { ++k; }while(k&gt;=10000);D.int s=36; while (s);–s; 103、下列哪个是和数据库访问技术关系不大的技术（C）A、SQLHelperB、EnterPrise LibraryC、AppDomainD、Linq 104、下列哪些说法是错误的（传智播客.Net培训班原创模拟题）A、将bmp格式的文件修改为jpg是修改图片格式最简单的方法B、将QQ动态表情显示在网页上用gif格式比较好C、将bmp格式的图片放到网页中可以优化网站速度D、png格式用在网页中可以实现透明的效果。 答案：A、C。A错误是因为修改文件的后缀并没有真的修改文件的格式，要使用Photoshop、mspaint等图片处理工具进行转换才可以。C错误是因为在网页中不能使用bmp图片。 105、从以下简写中任选一个简单描述OA\\MIS\\HRM\\CRM\\KM 参考答案：OA(Office Automation)：办公自动化MIS(Managment Information system)：管理信息系统HRM(Human Resource Managment)：人力资源管理，包括员工管理、薪资管理、入职管理、离职管理、报销管理、请假管理等CRM(Customer Relation Managment)：客户关系管理系统，包括客户管理、客户关怀、客户回访、投诉管理、咨询管理、报修管理等KM(Knowledge Managment)：知识管理 106、请在数据库中设计表来保存一个树状结构的公司组织结构参考呼叫中心项目的代码和板书。 107、下面程序的执行结果是什么？1234567891011121314public struct Point&#123; public int x; public int y; public Point(int x, int y) &#123; this.x &#x3D; x; this.y &#x3D; y; &#125;&#125;Point p1 &#x3D; new Point(100, 100);Point p2 &#x3D; p1;p1.x &#x3D; 200;Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, p1.x, p2.x);答案：200,100 解答：结构体是复制传递的。 108、在Windows命令行中敲入下面的指令各有什么反应（传智播客.Net培训班原创模拟题）：cd .. notepadcmdipconfigdir 答案：cd ..：进入上一级目录notepad：打开记事本cmd：启动另外一个命令行ipconfig：打印网络设置信息dir：显示当前目录下的文件 109、下列这些软件用过哪些？他们是用来做什么的？（传智播客.Net培训班原创模拟题）TypeAndRun、FoxMail、Reflector、UltraEdit、VSS、VirtualPC、VMWare参考答案：TypeAndRun：快速通过敲命令的方式启动其他程序的工具。FoxMail：邮件收发客户端Reflector：.net程序反编译工具UltraEdit：高级文本编辑器VSS：源代码管理工具VirtualPC：在一台计算机中虚拟出另外一个计算机的软件，是微软的产品VMWare：和VirtualPC一样，也是一种虚拟机软件 110、开放式问题：如果程序连不上SQLServer数据库服务器服务器，你会怎么排除这个故障？（传智播客.Net培训班原创模拟题）参考解答：首先ping一下服务器IP，看是否能够ping通，如果不能ping通，则看是否网络有问题；如果能ping通，再telnet一下服务器的1433端口，看是否能够连通；如果不能连通则可能是SQLServer服务停掉了或者是服务器上的防火墙封掉了1433端口；如果能连通再检查是不是本地程序的问题、驱动的问题。 111、下面的IP地址有什么含义？（传智播客.Net培训班原创模拟题）127.0.0.1：本地回环地址（LoopBack），localhost0.0.0.0：监听所有的网卡。AnyIP。255.255.255.0 112、不用JQuery等框架实现AJAX无刷新登录。提示：用纯XMLHttpRequest实现。113、单点登录。114、Http状态码各是什么意思。301 ：重定向404 ：页面不错在500：服务器内部错误115、 对html文本框进行赋值的JQuery语句，对html文本框进行取值的JQuery语句，对TextBox服务端控件进行取值的语句JQuery。116、IE和FireFox的不同，IE6和IE8的不同。JQueryXMLHttpRequest。不同浏览器实现AJAX的代码是不一样的。InnerHTML。CSS、Javascript、dom。有的浏览器不支持InnerHTML我们项目开发中为了避免这些跨浏览器兼容的问题，就是用JQuery框架，他帮我们屏蔽了浏览器的差异。 117、Session有什么重大BUG，微软提出了什么方法加以解决？网上的标准答案：按照网上的标准答案是：iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以用Sate server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件。但是（一定要写上，这样才够拽）我认为这不是Bug，只能说是In-Proc方式存储Session的缺陷，缺陷是和Bug不一样的，In-Proc方式存储Session会由服务武器来决定什么时候释放Session，这是By Design，In-Proc方式不满足要求的话完全可以用StateServer和数据库的方式。 传智播客补充：由于Session是依赖于Cookie的（SessionId保存在Cookie中，可以把课上讲到的Session的原理讲一下），而Cookie是在网络上明文传输的，所以如果有人通过偷听网络报文获得网络内其他人的SessionId的话就可以冒充访问者，2010年年底ASP.net就爆出过一个攻击者可以假冒Cookie访问网站的漏洞。解决方案：1）在服务器端记录“用户的IP地址+UserAgent”（因为内网用户的对外IP是一样的，但是两个用户的UserAgent完全一样的可能性比较小，cnzz浏览统计的“IP”和“独立访客”的区别就在这里）和SessionId在服务器端建立对应关系。在服务器端检查每次请求的SessionId和“用户的IP地址+UserAgent”是否一致，如果不一致说明有假冒。但是由于UserAgent也是可以假冒的，所以并不是完全安全。（2）在一些涉及敏感信息的功能中(比如在线支付/资金转账等)，建议必须再次由用户输入密码后，才能继续，理由很简单：偷得到cookie，不代表你知道用户的密码。这也是很多第三方支付系统，在付款前必须再次输入密码验证的原因。（3）安全性要求更好的场合使用https协议。 118、asp.net中&lt;%%&gt;、&lt;%=%&gt;、&lt;%#%&gt;的区别是什么&lt;%%&gt;是执行&lt;%%&gt;中的C#代码，&lt;%=%&gt;是将=后表达式的值输出到Response中，&lt;%#%&gt;是数据绑定，一般用在ListView、GridView、Repeater等控件的绑定中。 119、去掉“aaa bb cc afsdf”中的多个空格只保留一个空格。 说说在软件设计中你遇到的以空间换时间的例子？Cache、索引、简繁转换用Dictionary。 asp.net错误机制。ＥｒｒｏｒＰａｇｅ，Ｐａｇｅ_Error，Application_Error 面试题：1、自己写AJAX。写XMLHttpRequest实现AJAX例子。2、不用中间变量交换两个变量123456789101112int i &#x3D; 500;int j &#x3D; int.MaxValue - 10;&#x2F;&#x2F;int i &#x3D; 10;&#x2F;&#x2F;int j &#x3D; 20;Console.WriteLine(&quot;i&#x3D;&#123;0&#125;,j&#x3D;&#123;1&#125;&quot;, i, j);i &#x3D; i + j;&#x2F;&#x2F;i&#x3D;30j &#x3D; i - j;&#x2F;&#x2F;j&#x3D;10;i &#x3D; i - j;&#x2F;&#x2F;i&#x3D;20;Console.WriteLine(&quot;i&#x3D;&#123;0&#125;,j&#x3D;&#123;1&#125;&quot;,i,j);另外一个解决方案：位运算。 3、横表转纵表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182男 女 未知2 2 1SELECT 1 AS Expr1, 2 AS Expr2, 3 AS Expr3UNION ALLSELECT 4 AS Expr1, 5 AS Expr2, 6 AS Expr3UNION将结果集拼到一起UNION ALL将结果集拼到一起，并且自动去除重复行横表变纵表：增加合计行姓名 成绩tom 50jerry 60........平均 ....select Name as 姓名 ,Credit as 成绩from PersonsUnion allselect '平均' as 姓名,AVG(Credit)from Persons增加一个总分“列”SELECT Name, Credit, Credit2, Credit + Credit2 AS Expr1FROM PersonsSELECT Name, Credit, Credit2, Credit + Credit2 AS Expr1FROM PersonsUNION ALLSELECT '总分' AS Expr1, SUM(Credit) AS Expr2, SUM(Credit2) AS Expr3, SUM(Credit + Credit2) AS Expr4FROM Persons AS Persons_14、删除姓名、年龄重复的记录去除重复的数据：SELECT DISTINCT NameFROM PersonsDistinct只能去除结果集中一模一样的数据SELECT Name, GenderFROM PersonsGROUP BY Name, GenderSELECT MAX(Id) AS Expr1, Name, GenderFROM PersonsGROUP BY Name, Gender//取得不重复的数据select * from Personswhere Id in(SELECT MAX(Id) AS Expr1FROM PersonsGROUP BY Name, Gender)删除重复的数据：delete from Personswhere Id not in(SELECT MAX(Id) AS Expr1FROM PersonsGROUP BY Name, Gender)题：表的关联书名 所有者名C# tomIronPython lucySELECT b.Name,p.NameFROM Books as bleft join Persons as p on b.PersonId=p.Id 介绍一个开源的项目Lucene.net、NPOI、JQuery、ASP.Net AJAX toolkit。在CodePlex、SourceForge等网站上有更多的开源项目。 说出五个数据结构：List、Dictionary、Set、Stack（先入后出）、Queue、SiteMap、Tree等。 有一个10个数的数组，计算其中不重复数字的个数。{3,5,9,8,10,5,3}用HashSet1234567891011int[] values &#x3D; &#123; 3, 5, 9, 8, 10, 5, 3 &#125;;HashSet&lt;int&gt; set &#x3D; new HashSet&lt;int&gt;();foreach (int i in values)&#123; set.Add(i);&#125;foreach (int i in set)&#123; Console.WriteLine(i);&#125; 现有1~100共一百个自然数，已随机放入一个有98个元素的数组a[98]。要求写出一个尽量简单的方案，找出没有被放入数组的那2个数，并在屏幕上打印这2个数。注意：程序不用实现自然数随机放入数组的过程。参考：http://www.rupeng.com/forum/thread-1363-1-1.html OOP是什么 类是什么break 与Continue的作用 for(int i=1;1&lt;N;1++)for(int j=N;j&gt;1;J++)算法复杂度：时间复杂度(计算的步骤)、空间复杂度（计算所需要的内容） for(int i=0;i&lt;values.Length;i++){ Console.WriteLine(i);}时间复杂度O(n)、空间复杂度O(1)。for(int i=0;i&lt;values.Length/2;i++){ Console.WriteLine(i);}时间复杂度O(n)、空间复杂度O(1)。不要常数、N*N&gt;N。 for(int i=0;i&lt;values.Lenght;i++){ for(int i=0;i&lt;values.Lenght;i++);}时间复杂度O(n*n)、空间复杂度O(1)。计算时间复杂度、空间复杂度永远都考虑最差的情况。 1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F;相传有一群猴子要选出大王，它们采用的方式为：所有猴子站成一个圈，然后从1开始报数，每当数到&quot;.&#x2F;&#x2F;&quot;N的那一只猴子就出列，然后继续从下一个猴子开始又从1开始数，数到N的猴子继续出列，一直到最后&quot;.&#x2F;&#x2F;&quot;剩的猴子就是大王了。假如现在有M只猴子，报数数为N，请问第几只猴子是大王？列出选大王的过程。int M &#x3D; 10;int N &#x3D; 3;List&lt;int&gt; monkeys &#x3D; new List&lt;int&gt;();for (int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123; monkeys.Add(i);&#125;int currentIndex &#x3D; 0;while (true)&#123; for (int i &#x3D; 1; i &lt;&#x3D; N; i++) &#123; if (i &#x3D;&#x3D; N) &#123; monkeys.RemoveAt(currentIndex); if (monkeys.Count &#x3D;&#x3D; 1) &#123; Console.WriteLine(monkeys[0]); return; &#125; &#125; currentIndex++; if (currentIndex &gt;&#x3D; monkeys.Count) &#123; currentIndex &#x3D; 0; &#125; &#125;&#125; 使用缓存缓存经常访问的页面（整页面保存）五个数同时交换首尾颠倒，不用中间变量 机试题：1、下面是一个由*号组成的4行倒三角形图案。要求：1、输入倒三角形的行数，行数的取值3-21之间，对于非法的行数，要求抛出提示“非法行数！”；2、在屏幕上打印这个指定了行数的倒三角形。 * 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859namespace 倒三角输出&#123; class Program &#123; static void Main(string[] args) &#123; &#x2F;&#x2F;1、下面是一个由*号组成的4行倒三角形图案。 &#x2F;&#x2F;要求：1、输入倒三角形的行数，行数的取值3-21之间， &#x2F;&#x2F;对于非法的行数，要求抛出提示“非法行数！”； &#x2F;&#x2F;2、在屏幕上打印这个指定了行数的倒三角形。 &#x2F;&#x2F; ******* &#x2F;&#x2F; ***** &#x2F;&#x2F; *** &#x2F;&#x2F; * Console.WriteLine(&quot;输入倒三角的行数:&quot;); string num &#x3D; Console.ReadLine(); int num1 &#x3D; Convert.ToInt32(num); if (num1 &gt;&#x3D; 3 &amp;&amp; num1 &lt;&#x3D; 21) &#123; for (int i &#x3D; num1; i &gt;&#x3D; 1; i--)&#x2F;&#x2F;行数控制 &#123; for (int j &#x3D; num1 - i - 1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;空格控制 &#123; Console.Write(&quot; &quot;); &#125; for (int k &#x3D; 1; k &lt;&#x3D; 2 * i - 1; k++)&#x2F;&#x2F;*号控制 &#123; Console.Write(&quot;*&quot;); &#125; Console.WriteLine(); &#125; &#125; else &#123; Console.WriteLine(&quot;非法行数！&quot;); &#125; &#x2F;&#x2F;for (int i&#x3D;5; i &gt;&#x3D; 1; i--)&#x2F;&#x2F;行数控制 &#x2F;&#x2F; &#123; &#x2F;&#x2F; for (int j &#x3D; 5 - i - 1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;空格控制 &#x2F;&#x2F; &#123; &#x2F;&#x2F; Console.Write(&quot; &quot;); &#x2F;&#x2F; &#125; &#x2F;&#x2F; for (int k &#x3D; 1; k &lt;&#x3D; 2 * i - 1; k++)&#x2F;&#x2F;*号控制 &#x2F;&#x2F; &#123; &#x2F;&#x2F; Console.Write(&quot;*&quot;); &#x2F;&#x2F; &#125; &#x2F;&#x2F; Console.WriteLine(); &#x2F;&#x2F; &#125; Console.ReadKey(); &#125; &#125;&#125; 2、现有1~100共一百个自然数，已随机放入一个有98个元素的数组a[98]。要求写出一个尽量简单的方案，找出没有被放入数组的那2个数，并在屏幕上打印这2个数。注意：程序不用实现自然数随机放入数组的过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697int[] b &#x3D; new int[]&#123;....存入98个随机的1~100的整数&#125;;int[] a &#x3D; new int[100];for(int t : b) a[t-1]&#x3D;t;for(int t&#x3D;0; t &lt; a.length; t++) if(a[t]&#x3D;&#x3D;0) System.out.println(t+1);using System;class test&#123; public static void Main() &#123; test t&#x3D;new test(); t.Deal(); &#125; public void Deal() &#123; int[] ary&#x3D;new int[99]; &#x2F;&#x2F;声明一个数组 int sum&#x3D;0; &#x2F;&#x2F;随机数组总和 int num&#x3D;0; &#x2F;&#x2F;余下的两个数总和 int flag&#x3D;0; &#x2F;&#x2F;余下两个数中的一个数的值 for(int i&#x3D;1;i&lt;99;i++) &#x2F;&#x2F;给数组赋值 &#123; ary&#x3D;i; &#125; ary[98]&#x3D;100; &#x2F;&#x2F;为了测试，打乱一下 for(int i&#x3D;1;i&lt;99;i++) &#123; sum+&#x3D;ary; &#125; num&#x3D;5050-sum; if(0&#x3D;&#x3D;(num&amp;1)) &#x2F;&#x2F;判断奇偶 &#123; int _num&#x3D;num&#x2F;2; for(int i&#x3D;1;i&lt;_num;i++) &#123; if(ary!&#x3D;_num) &#123; flag&#x3D;_num; &#125; &#125; &#125; else &#123; int _num&#x3D;(num-1)&#x2F;2; for(int i&#x3D;0;i&lt;_num;i++) &#123; if(ary!&#x3D;_num) &#123; flag&#x3D;_num; &#125; &#125; &#125; Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;,flag,num-flag); &#125;&#125;int main()&#123; int i; int nature[98]; &#x2F;&#x2F;98个自然数我就这个顺序输入了 for(i&#x3D;1;i&lt;&#x3D;97;i++) &#123; nature&#x3D;i; &#125; nature[0]&#x3D;98; &#x2F;&#x2F;--------------- int number[101]&#x3D;&#123;0&#125;; &#x2F;&#x2F;用作标记 for(i&#x3D;0;i&lt;98;i++) &#123; number[nature]&#x3D;1; &#x2F;&#x2F;用数字1标记 &#125; printf(&quot;the numbers you want find are: \\n&quot;); for(i&#x3D;1;i&lt;101;i++) &#123; if(1&#x3D;&#x3D;number) &#123; continue; &#125; else printf(&quot;%d &quot;,i); &#125; return 0;&#125; 3、一个文本文件含有如下内容：4580616022644994|3000|赵涛4580616022645017|6000|张屹4580616022645090|3200|郑欣夏上述文件每行为一个转账记录，第一列表示帐号，第二列表示金额，第三列表示开户人姓名。创建一张数据库表（MS SQLServer数据库，表名和字段名自拟），请将上述文件逐条插入此表中。4、一个文本文件含有如下内容，分别表示姓名和成绩：张三 90李四 96王五 78赵六 82 提供用户一个控制台界面，允许用户输入要查询的姓名，输入姓名并且按回车以后，打印出此人的成绩，如果不输入姓名直接按回车则显示所有人的姓名以及成绩。（注意：不能使用数据库）Equls和==的区别123456789101112131415161718&#x2F;&#x2F;数组连接 int[] nums &#x3D; &#123; 5,3,8&#125;; int[] nums2 &#x3D; &#123; 5,8,99,333&#125;; int[] nums3 &#x3D; new int[nums.Length+nums2.Length]; for (int i &#x3D; 0; i &lt; nums.Length; i++) &#123; nums3[i] &#x3D; nums[i]; &#125; for (int i &#x3D; 0; i &lt;nums2.Length; i++) &#123; nums3[nums.Length+i] &#x3D; nums2[i]; &#125; for (int i &#x3D; 0; i &lt;nums3.Length; i++) &#123; Console.WriteLine(nums3[i]); &#125; Console.ReadKey(); equals和==的区别==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。解释一下==号，他比较的是一个对象在内存中的地址值，比如2个字符串对象String s1 = new String(“str”);String s2 = new String(“str”);如果用==号比较，会返回false，因为创建了两个对象，他们在内存中地址的位置是不一样的。 equals的情况比较复杂，它是java.lang.Object类中的一个方法。因为java中所有的类都默认继承于Object，所以所有的类都有这个方法。 String里的方法，如果==号比较不相等，还会进行一下值的比较。所以equals方法具体的作用要看当前的那个类是如何实现重写父类中该方法的。如果没有重写该方法，那么他和==号等价。、请编程实现一个冒泡排序算法？答：1234567891011121314151617int[] array &#x3D; &#123; 2, 65, 5, 3, 7, 12, 565 &#125;;int temp &#x3D; 0;for (int i &#x3D; 0; i &lt; array.Length; i++)&#123; for (int j &#x3D; 0; j &lt;array.Length-1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; temp &#x3D; array[j]; array[j] &#x3D; array[j+1]; array[j+1] &#x3D; temp; &#125; &#125; Console.WriteLine(array[i]);&#125;Console.ReadKey(); 第二种12345678910111213141516int[] array &#x3D; &#123; 2, 65, 5, 3, 7, 12, 565 &#125;;int temp &#x3D; 0;for (int i &#x3D; 0; i &lt; array.Length; i++)&#123; for (int j &#x3D; i + 1; j &lt; array.Length; j++) &#123; if (array[j] &lt; array[i]) &#123; temp &#x3D; array[i]; array[i] &#x3D; array[j]; array[j] &#x3D; temp; &#125; &#125; Console.WriteLine(array[i]);&#125; 先序遍历的基本思想是：首先访问根结点，然后先序遍历其左子树，最后先序遍历其右子树。先序遍历的递归算法实现如下，注意：这里的访问根结点是把根结点的值输出到控制台上。当然，也可以对根结点作其它处理。1234567891011public void PreOrder(Node&lt;T&gt; root) &#123; &#x2F;&#x2F;根结点为空 if (root &#x3D;&#x3D; null) &#123; return; &#125; &#x2F;&#x2F;处理根结点 Console.WriteLine(&quot;&#123;0&#125;&quot;, root.Data); &#x2F;&#x2F;先序遍历左子树 PreOrder(root.LChild); &#x2F;&#x2F;先序遍历右子树 PreOrder(root.RChild); &#125; 层序遍历（Level Order）层序遍历的基本思想是：由于层序遍历结点的顺序是先遇到的结点先访问，与队列操作的顺序相同。所以，在进行层序遍历时，设置一个队列,将根结点引用入队，当队列非空时，循环执行以下三步：（1） 从队列中取出一个结点引用，并访问该结点；（2） 若该结点的左子树非空，将该结点的左子树引用入队；（3） 若该结点的右子树非空，将该结点的右子树引用入队；层序遍历的算法实现如下：12345678910111213141516171819202122public void LevelOrder(Node&lt;T&gt; root) &#123; &#x2F;&#x2F;根结点为空 if (root &#x3D;&#x3D; null) &#123; return; &#125; &#x2F;&#x2F;设置一个队列保存层序遍历的结点 CSeqQueue&lt;Node&lt;T&gt;&gt; sq &#x3D; new CSeqQueue&lt;Node&lt;T&gt;&gt;(50); &#x2F;&#x2F;根结点入队 sq.In(root); &#x2F;&#x2F;队列非空，结点没有处理完 while (!sq.IsEmpty()) &#123; &#x2F;&#x2F;结点出队 Node&lt;T&gt; tmp &#x3D; sq.Out(); &#x2F;&#x2F;处理当前结点 Console.WriteLine(&quot;&#123;o&#125;&quot;, tmp); &#x2F;&#x2F;将当前结点的左孩子结点入队 if (tmp.LChild !&#x3D; null) &#123; sq.In(tmp.LChild); &#125; &#x2F;&#x2F;将当前结点的右孩子结点入队 &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"csharp .net的IO操作","slug":"技术/2015-03-14-csharp.net的IO操作","date":"2015-03-14T00:00:00.000Z","updated":"2020-06-09T10:00:01.595Z","comments":true,"path":"2015/03/14/技术/2015-03-14-csharp.net的IO操作/","link":"","permalink":"https://ax-codes.github.io/2015/03/14/%E6%8A%80%E6%9C%AF/2015-03-14-csharp.net%E7%9A%84IO%E6%93%8D%E4%BD%9C/","excerpt":"","text":"I/O 操作执行需要将数据读取到内存 input写入需要将数据写入到物理文件 output//—————————————————————//————————————————————— 1.将需要读取的数据转换为二进制数据2.将二进制数据再转换回原始的文件或者数据 文件流：实现文件的 读和写 读：将数据读取到数组写：将数组的数据写到文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&#x2F;&#x2F;1.0 选择需要读取的文件路径private void txtReadPath_Click(object sender, EventArgs e)&#123; &#x2F;&#x2F;1.1 创建一个打开文件对话框对象 OpenFileDialog dia &#x3D; new OpenFileDialog(); &#x2F;&#x2F;1.2 用户确定选择 if (dia.ShowDialog() &#x3D;&#x3D; DialogResult.OK) &#123; txtReadPath.Text &#x3D; dia.FileName;&#x2F;&#x2F;全路劲，包含文件夹和文件名 &#125;&#125;&#x2F;&#x2F;2.0 拷贝文件private void btnCopy_Click(object sender, EventArgs e)&#123; &#x2F;&#x2F;2.1 将需要复制的数据写入到byte数组中 &#x2F;&#x2F;2.2 将byte数组中的数据写入到指定的文件 &#x2F;&#x2F; 创建一个读取流 using (FileStream fs &#x3D; new FileStream(txtReadPath.Text, FileMode.Open)) &#123; &#x2F;&#x2F; 声明一个存储读取数据的byte数组 byte[] bytes &#x3D; new byte[fs.Length]; &#x2F;&#x2F; 让流将指定的数据读取到数组中 fs.Read(bytes, 0, bytes.Length); &#x2F;&#x2F; 将数组的数据写入到指定的文件 &#x2F;&#x2F; @&quot;F:\\008.txt&quot;,FileMode.Create &#x2F;&#x2F; 这样是修改文件名，拷贝内容 using (FileStream fsWrite &#x3D; new FileStream(@&quot;F:\\&quot; + Path.GetFileName(txtReadPath.Text), FileMode.Create)) &#123; &#x2F;&#x2F; 将指定数组的数据写入到指定文件 fsWrite.Write(bytes, 0, bytes.Length); &#125; MessageBox.Show(&quot;Ok&quot;); &#125;&#125;&#x2F;&#x2F;3.0 文件读取private void btnRead_Click(object sender, EventArgs e)&#123; &#x2F;&#x2F;&#x2F;&#x2F; 复杂点的 &#x2F;&#x2F;using(FileStream fsRead&#x3D;new FileStream(txtReadPath.Text,FileMode.Open)) &#x2F;&#x2F;&#123; &#x2F;&#x2F; byte[] bytes&#x3D;new byte[fsRead.Length]; &#x2F;&#x2F; fsRead.Read(bytes,0,bytes.Length); &#x2F;&#x2F; txtContent.Text &#x3D; Encoding.Default.GetString(bytes); &#x2F;&#x2F;&#125; &#x2F;&#x2F; 简单点的使用 File.ReadAllText(); txtContent.Text &#x3D; File.ReadAllText(txtReadPath.Text, Encoding.Default);&#125;&#x2F;&#x2F;4.0 保存文件 路径 对话框 —— 用于写入private void txtWritePath_Click(object sender, EventArgs e)&#123; SaveFileDialog dia &#x3D; new SaveFileDialog(); if (dia.ShowDialog() &#x3D;&#x3D; DialogResult.OK) &#123; txtWritePath.Text &#x3D; dia.FileName; &#125;&#125;&#x2F;&#x2F;5.0 往4.0创建的路径写入文件private void btnWrite_Click(object sender, EventArgs e)&#123; &#x2F;&#x2F;&#x2F;&#x2F; 复杂点的 &#x2F;&#x2F;byte[] bytes &#x3D; Encoding.Default.GetBytes(txtContent.Text); &#x2F;&#x2F;using (FileStream fsWrite &#x3D; new FileStream(txtWritePath.Text, FileMode.Create)) &#x2F;&#x2F;&#123; &#x2F;&#x2F; fsWrite.Write(bytes,0,bytes.Length); &#x2F;&#x2F;&#125; &#x2F;&#x2F; 简单点的 File.WriteAllText(txtWritePath.Text, txtContent.Text); MessageBox.Show(&quot;Ok&quot;);&#125; 其他123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F;1.0 选择目录private void txtPath_Click(object sender, EventArgs e)&#123; FolderBrowserDialog dir &#x3D; new FolderBrowserDialog(); if (dir.ShowDialog() &#x3D;&#x3D; DialogResult.OK) &#123; txtPath.Text &#x3D; dir.SelectedPath; &#125;&#125;&#x2F;&#x2F;2.0 获取子目录和子文件private void btnGet_Click(object sender, EventArgs e)&#123; string[] dirs &#x3D; Directory.GetDirectories(txtPath.Text); &#x2F;&#x2F; 遍历目录数组 将数组中每一个目录生成一个树节点添加到树控件中 foreach (string item in dirs) &#123; &#x2F;&#x2F; 每一个目录对应一个节点 TreeNode node &#x3D; new TreeNode(); &#x2F;&#x2F; 为节点设置显示的文本值 node.Text &#x3D; Path.GetFileName(item); &#x2F;&#x2F; 将节点添加到树控件中 tvDirectories.Nodes.Add(node); &#125; &#x2F;&#x2F; 创建目录对象 DirectoryInfo dir &#x3D; new DirectoryInfo(txtPath.Text); FileInfo[] files &#x3D; dir.GetFiles(); &#x2F;&#x2F; 循环遍历文件对象数组 foreach (FileInfo item in files) &#123; &#x2F;&#x2F; 每一个文件对象对应着ListView控件中的每一项 Name文件名 &#x2F;&#x2F; 创建控件主项 ListViewItem lv &#x3D; new ListViewItem(item.Name); &#x2F;&#x2F; 为主项添加它的子项 lv.SubItems.Add(item.LastWriteTime.ToString()); lv.SubItems.AddRange(new string[] &#123; item.Extension, item.Length.ToString() &#125;); &#x2F;&#x2F; 将创建的项添加到控件的items集合中 lvFiles.Items.Add(lv); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"ajax调用webservice报错","slug":"技术/2015-03-08-ajax调用webservice报错","date":"2015-03-08T00:00:00.000Z","updated":"2020-06-09T10:00:01.595Z","comments":true,"path":"2015/03/08/技术/2015-03-08-ajax调用webservice报错/","link":"","permalink":"https://ax-codes.github.io/2015/03/08/%E6%8A%80%E6%9C%AF/2015-03-08-ajax%E8%B0%83%E7%94%A8webservice%E6%8A%A5%E9%94%99/","excerpt":"","text":"ajax调用webservice报错异常报告1XMLHttpRequest cannot load http://localhost:8098/webApi.asmx/stockData. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:26883' is therefore not allowed access. 解决在web服务器的config的configuration节点加上下面的配置就行12345678&lt;system.webServer&gt; &lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name=\"Access-Control-Allow-Origin\" value=\"*\" /&gt; &lt;add name=\"Access-Control-Allow-Headers\" value=\"Content-Type\" /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt;&lt;/system.webServer&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"std map自定义排序","slug":"技术/2015-02-26-std map自定义排序","date":"2015-02-26T00:00:00.000Z","updated":"2020-06-09T10:00:01.594Z","comments":true,"path":"2015/02/26/技术/2015-02-26-std map自定义排序/","link":"","permalink":"https://ax-codes.github.io/2015/02/26/%E6%8A%80%E6%9C%AF/2015-02-26-std%20map%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/","excerpt":"","text":"std map自定义排序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include \"stdafx.h\"#include &lt;process.h&gt;#include &lt;map&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int _tmain(int argc, _TCHAR* argv[])&#123; std::map&lt;int, int&gt; m; m[1] = 20; m[2] = 3; m[3] = 12; m[4] = 1; m[5] = 9; m[6] = 111; m[7] = 90; m[8] = 2; m[9] = 43; cout &lt;&lt; \"1:初始数据\" &lt;&lt; endl; for each (auto it in m) &#123; cout &lt;&lt; \"\" &lt;&lt; it.first &lt;&lt; \":\" &lt;&lt; it.second &lt;&lt; endl; &#125; std::vector&lt;std::pair&lt;int, int&gt;&gt; v1; for each (auto it in m) &#123; v1.push_back(std::make_pair(it.first, it.second)); &#125; sort(v1.begin(), v1.end(), [](const std::pair&lt;int, int&gt; &amp;x, const std::pair&lt;int, int&gt; &amp;y) -&gt; int &#123; return x.second &lt; y.second; &#125;); cout &lt;&lt; \"2:排序\" &lt;&lt; endl; for each (auto it in v1) &#123; cout &lt;&lt; \"\" &lt;&lt; it.first &lt;&lt; \":\" &lt;&lt; it.second &lt;&lt; endl; &#125; cout &lt;&lt; \"3:删除数据\" &lt;&lt; endl; v1.resize(3); for each (auto it in v1) &#123; cout &lt;&lt; \"\" &lt;&lt; it.first &lt;&lt; \":\" &lt;&lt; it.second &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"设计模式-订阅模式","slug":"技术/2015-02-18-设计模式-订阅模式","date":"2015-02-18T00:00:00.000Z","updated":"2020-06-09T10:00:01.594Z","comments":true,"path":"2015/02/18/技术/2015-02-18-设计模式-订阅模式/","link":"","permalink":"https://ax-codes.github.io/2015/02/18/%E6%8A%80%E6%9C%AF/2015-02-18-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"前言 语言:c# 理解:一个集合管理起消息,然后一直监听这个消息管理器,当收到消息时,推送订阅数据 代码123456789101112internal interface ISubject&#123; IEnumerable&lt;IObserver&gt; Observers &#123; get; &#125; void Notify(); void AddObserver(IObserver observer); void RemoveObserver(IObserver observer);&#125;internal interface IObserver&#123; void ReceiveSubject(ISubject subject);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142internal class AritcleObserver : IObserver&#123; public void ReceiveSubject(ISubject subject) &#123; &#x2F;&#x2F; receive the subject &#125;&#125;class WeChatArticle : ISubject&#123; private ICollection&lt;IObserver&gt; _observers; private string _name; public WeChatArticle(string name) &#123; this._name &#x3D; name; this._observers &#x3D; new List&lt;IObserver&gt;(); &#125; public IEnumerable&lt;IObserver&gt; Observers &#123; get &#123; return this._observers; &#125; &#125; public void Notify() &#123; foreach (IObserver observer in this._observers) &#123; observer.ReceiveSubject(this); &#125; &#125; public void AddObserver(IObserver observer) &#123; this._observers.Add(observer); &#125; public void RemoveObserver(IObserver observer) &#123; this._observers.Remove(observer); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术随笔","slug":"技术随笔","permalink":"https://ax-codes.github.io/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"},{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"},{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"},{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"VS插件VASSISTX(小番茄)创建注释模板","slug":"技术/2015-02-09-VS插件VASSISTX(小番茄)创建注释模板","date":"2015-02-09T00:00:00.000Z","updated":"2020-06-09T10:00:01.591Z","comments":true,"path":"2015/02/09/技术/2015-02-09-VS插件VASSISTX(小番茄)创建注释模板/","link":"","permalink":"https://ax-codes.github.io/2015/02/09/%E6%8A%80%E6%9C%AF/2015-02-09-VS%E6%8F%92%E4%BB%B6VASSISTX(%E5%B0%8F%E7%95%AA%E8%8C%84)%E5%88%9B%E5%BB%BA%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"前言VASSISTX是vs的一款插件,可以大大提高程序的开发效率,VASSISTX的安装和破解可以自己百度,这里主要讲的是使用它的快速生成模板的功能 步骤安装好VASSISTX后选择操作栏上的VASSISTX然后打开Visual Assist Options 选择Suggestions 再选择Edit VA Snippets 就能看到下图界面我们需要new一个然后可以选择一个下方现有的模板复制到我们新增的模板里,可以按照自己的要求修改最后输入Title和Shortcut，这个Shortcut是我们在启动命令(在vs界面输入的时候VASSISTX自动会检测,检测到我们只需选择后按tab或者enter建即可显示我们需要追加的模板) 常用注释格式12345678910111213141516171819202122232425262728293031323334353637//1、生成文件头注释 /************************************************************************** * @Copyright (c) $YEAR$, AX, All rights reserved. * @file : $FILE_BASE$.$FILE_EXT$ * @version : ver 1.0 * @author : AX * @date : $YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ * @brief : $brief$ **************************************************************************/ //2、生成函数功能注释 /******************************************************** * @function : * @brief : $brief$ * @input : * @output : * @return : 成功返回0，失败返回非0 * @author : AX $YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ ********************************************************/ //3、生成类//2、生成函数功能注释 /******************************************************** * @class : * @brief : $brief$ * @author : AX $YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ ********************************************************/ //4、生成单行标记 //-------By_AX_$YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$ //5、生成多行标记 /*-----------------By_AX_$YEAR$/$MONTH_02$/$DAY_02$ $HOUR_02$:$MINUTE$-----------------*/ /*------------------------------------------------------------*/","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"},{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"},{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"},{"name":".net/.net core","slug":"net-net-core","permalink":"https://ax-codes.github.io/tags/net-net-core/"}]},{"title":"vscode配置c,c++环境","slug":"技术/2015-02-01-vscode配置c,c++环境","date":"2015-02-01T00:00:00.000Z","updated":"2020-06-09T10:00:01.591Z","comments":true,"path":"2015/02/01/技术/2015-02-01-vscode配置c,c++环境/","link":"","permalink":"https://ax-codes.github.io/2015/02/01/%E6%8A%80%E6%9C%AF/2015-02-01-vscode%E9%85%8D%E7%BD%AEc,c++%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言 官网教程: C/C++ for VS Code (Preview) 参考教程: Visual Studio Code如何编写运行C、C++ 安装ide和编译器,调试器的安装vscode官网Clang下载,选Pre-Built Binaries中的Clang for Windows (64-bit),不需要下.sig文件MinGW-w64下载,直接Download Clang 下载好了以后安装。添加环境变量时：选Add LLVM to the system PATH for all users（即第二项，不过第三项也差不多）。Clang的安装路径（Destination folder）我推荐填C:\\LLVM，不装那里也行，下面的配置里路径就自己改。安装完了以后可能会弹出cmd说MSVC integration install failed。这个是因为Clang默认使用的是msvc的工具链，而我们选择的工具链是MinGW，所以就不用管这个提示。如果你想用别的工具链，参考第九点。 MinGW随便装哪，Architecture选x86_64，装好以后把东西全部复制到Clang的文件夹里去，他们会无冲突合并，效果图见下。同样，不做这一步也行，下面的配置里路径就自己改，还要手动把MinGW的bin文件夹加到path中，因为MinGW不会自己加。至于为什么既要装Clang又要装MinGW，是因为Clang没有头文件。然后就可以把MinGW删了（Uninstall.exe）。不建议安装多个MinGW；可以把其他轻量IDE的编译器设为Clang，并把其他的MinGW从环境变量中去掉。 插件安装C/C++（就是有些教程里的cpptools）C/C++ Clang Command Adapter：提供静态检测（Lint）Code RunnerInclude Autocomplete：提供头文件补全C/C++ Snippets：Snippets即重用代码块 可选插件Bracket Pair Colorizer：彩虹花括号One Dark Pro：大概是VS Code安装量最高的主题GBKtoUTF8：把GBK编码的文档转换成UTF8编码的 配置.vscode 的 四个json文件c_cpp_properties.json123456789101112131415161718192021222324252627282930313233343536373839&#123; \"configurations\": [ &#123; \"name\": \"Win32\", \"intelliSenseMode\": \"clang-x64\", \"includePath\": [ \"$&#123;workspaceFolder&#125;\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/x86_64-w64-mingw32\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/backward\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include\", \"D:/Program Files/llvm/include\", \"D:/Program Files/llvm/x86_64-w64-mingw32/include\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include-fixed\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"__GNUC__=7\", \"__cdecl=__attribute__((__cdecl__))\" ], \"browse\": &#123; \"path\": [ \"$&#123;workspaceFolder&#125;\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/x86_64-w64-mingw32\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include/c++/backward\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include\", \"D:/Program Files/llvm/include\", \"D:/Program Files/llvm/x86_64-w64-mingw32/include\", \"D:/Program Files/llvm/lib/gcc/x86_64-w64-mingw32/7.2.0/include-fixed\" ], \"limitSymbolsToIncludedHeaders\": true, \"databaseFilename\": \"\" &#125; &#125; ], \"version\": 3&#125; 具体路径改成自己的clang的安装路径 launch.json12345678910111213141516171819202122232425262728// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(gdb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", // 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\", // 将要进行调试的程序的路径 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": true, // 设为true时程序将暂停在程序入口处，我一般设置为true \"cwd\": \"$&#123;workspaceFolder&#125;\", // 调试程序时的工作目录 \"environment\": [], // （环境变量？） \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"internalConsoleOptions\": \"neverOpen\", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？ \"MIMode\": \"gdb\", // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。 \"miDebuggerPath\": \"gdb.exe\", // 调试器路径。 \"setupCommands\": [ &#123; \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false &#125; ], \"preLaunchTask\": \"Compile\" // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &#125; ]&#125; tasks.json12345678910111213141516171819202122232425262728// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(gdb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", // 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\", // 将要进行调试的程序的路径 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": true, // 设为true时程序将暂停在程序入口处，我一般设置为true \"cwd\": \"$&#123;workspaceFolder&#125;\", // 调试程序时的工作目录 \"environment\": [], // （环境变量？） \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"internalConsoleOptions\": \"neverOpen\", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？ \"MIMode\": \"gdb\", // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。 \"miDebuggerPath\": \"gdb.exe\", // 调试器路径。 \"setupCommands\": [ &#123; \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": false &#125; ], \"preLaunchTask\": \"Compile\" // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &#125; ]&#125; 其他设置 seting12345678910\"editor.fontFamily\": \"Consolas, 微软雅黑\", // 控制编辑器字体\"workbench.colorTheme\": \"One Dark Pro\", // 主题\"files.trimTrailingWhitespace\": true, // 保存时，删除每一行末尾的空格\"workbench.colorCustomizations\": &#123; \"activityBar.foreground\": \"#33ff66\" // 自定义颜色 &#125;,\"git.enabled\": false, // 如果你不用git，我建议你关闭它\"editor.minimap.enabled\": false, // 我个人不用minimap，就是右边那个东西\"editor.dragAndDrop\": false, // 选中文字后，可以拖动它们调整位置。我是不需要\"files.autoGuessEncoding\": true // 启用后，会在打开文件时尝试猜测字符集编码 详情请参考 https://www.zhihu.com/question/30315894","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"最全的前端资源教程","slug":"技术/2015-01-24-最全的前端资源教程","date":"2015-01-24T00:00:00.000Z","updated":"2020-06-09T10:00:01.590Z","comments":true,"path":"2015/01/24/技术/2015-01-24-最全的前端资源教程/","link":"","permalink":"https://ax-codes.github.io/2015/01/24/%E6%8A%80%E6%9C%AF/2015-01-24-%E6%9C%80%E5%85%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%95%99%E7%A8%8B/","excerpt":"","text":"Javascript Article Article Javascript深浅拷贝 Javascript中的apply和call继承 Javascript的jsonp原理 Javascript监听触摸事件 Javascript中的var self = this Javascript面向对象编程 Javascript滑屏切换场景 Javascript获取经纬度，关于调用百度API的问题 妙用Javascript运算符 深入理解Javascript函数编程 Javascript的setTimeout详细用例 sessionstorage，localstorage和cookie JS日期对比 JSONP参考文章 Javascript的createElement Javascript的createDocumentFragment sessionStorage和localStorage 像素帧动画 Reference Reference 收集最全前端学习资料 最全前端教程-猫的回忆录 JavaScript中的this陷阱的最全收集–没有之一 JS函数式编程指南 JavaScript Promise迷你书（中文版） 阮一峰 Javascript 前端 TOP 100 小白的零基础JavaScript全栈教程 UI Reference Reference WeUI Bootstrap MUI-最接近原生APP体验的高性能前端框架 Amaze UI中国首个开源HTML5跨屏前端框架 Frozen UI Foundation SUI ZUI 淘宝HTML5前端框架 KISSY - 阿里前端JavaScript库 网易Nej - Nice Easy Javascript Kendo UI MVVM Demo Smart UI 雅虎UI - CSS UI CSS Article Article CSS Flex布局 移动前端开发CSS3 响应式布局 媒体查询 CSS图片响应式布局 lessDemo的less文件 Reference Reference CSS 语法参考 CSS3动画手册 腾讯css3动画制作工具 animate.css Animated Books with CSS 3D Transforms Browserhacks HTML Article Article HTML5有哪些让你惊艳的demo|Wallpaperbetter| Angular Article Angular文档 Angular源码解读publishExternalAPI函数 Angular源码解读setupModuleLoader函数 Angular的ng-style用法 Angular判断在那个浏览器下打开的服务 Angular文字折叠展开组件的原理分析 Angular服务Request异步请求的详细分析 Angular自定义service服务详解 Angular自定义判断上一页是否存在的服务 Angular操作cookies方法 Angular打印错误的minErr函数 Angular的fromJson与toJson方法 Angular用ng-repeat生成表单并绑定ng-click时的一个细节 Angular的run方法巧妙运用 Angular处理Html转义问题 ng-repeat绑定事件和嵌套 Angular的post请求后台接受不了数据的解决方法 ionic总结 ui-route和ng-route ng-options&amp;&amp;ng-switch directive组件作用域 表单认证 $broadcast,$emit and $on 自定义过滤器 自定义手势指令ng-touch ng-animate 单页面应用的技术点 Guess you like AppDemo Angular商城Demo Angular的Cnode社区 AngularStovepipe Angular的新闻客户端 Angular商城Demo Angular的Cnode社区 Angular内联编辑器 Angular即时搜索 Angular导航菜单 Angular订单表单 Angular切换网格 Angular新闻＋WEUI DEMO 源码 Controller 控制器 Angular控制器demo SPA DEMO 单页面应用 Angular+Weui单页面应用DEMO-每日笑话 Service 服务 Angular自定义服务的常用方法 Angular部分服务demo Angular自定义Canvas画图服务 Angular自定义http服务 面向对象封装 Directive 组件与指令 Angular自定义手势指令 Angular自定义轮播图组件 Angular自定义下拉刷新组件1 Angular自定义下拉刷新组件2 Router 路由 Angular路由嵌套 Angular路由单页多个ui-view Filter 过滤器 Angular自带过滤器 Angular自定义关键词检索过滤器 Animate 动画 Angular ng-animate动画1 Angular ng-animate动画2 Other 其他 Angular中使用iframe Angular三级联动(1) Angular中使用ng-switch 百度定位DEMO Angular三级联动(2) Angular事件监听 jQuery模拟ng-repeat lessDemo Angular自定义cookie服务和ngCookie的使用 图灵机器人 Angular利用angular.module()实现模块化 Angular的form表单验证 Angular的ng-repeat嵌套 Angular利用angular.module()实现模块化2 PHP PHP PHP CURL请求的小细节 Reference Reference 最流行的PHP 代码规范 最流行的PHP 代码规范 Angular.js的一些学习资源 Angularjs中文社区 一些扩展Angular UI组件 Angular UI AngularJS在线教程 Angular学习笔记 React React Reference React教程 菜鸟教程 React Router 使用教程 React开发中文手册-极客学院 React教程-汇智网 React.js快速开始 Reactjs 2016最佳实践 React 入门教程 汇智网 React教程 轻松入门React和Webpack React中文索引 Redux 中文文档 React Router官方文档中文翻译 React入门教程 React介绍及实践教程 React.js 官方网址 React.js 官方文档 React.js material UI React.js TouchstoneJS UI React.js amazeui UI React 入门实例教程 - 阮一峰 React Native 中文版 Webpack 和 React 小书 - gitbook Vue Vue AppDemo Demo NewsDemo vue计算属性 vue生命周期 Article Vue文档 Vue-cli脚手架 Vue组件 vue自定义指令 Vue过渡动画 Vue指令 Vue api文档 Vue执行ajax请求 vue实现类似angular服务的方法 Vue源码参考文档 Router 路由 路由demo 路由demo2 Directive 指令 指令demo 自定义指令demo 滑动手势demo Filter 过滤器 过滤器demo 过滤器实现分页demo 过滤器读写数据 Transition 过渡 过渡demo 过渡demo2 Form 表单 获取表单值 Computed 计算 计算属性 Component 组件 组件demo Reference Reference Reference Vue官网 Vue论坛 Awesome-vue Node Node Article node技巧 NodeJs静态服务器 Reference Reference Node.js 包教不包会 七天学会NodeJS 从零开始nodejs系列文章 Node入门 Node初学者入门，一本全面的NodeJS教程 Gulp Gulp Article Gulp Demo Gulp Reference Gulp官网 Gulp中文网 Gulp资料收集 Gulp：任务自动管理工具 - ruanyifeng Gulp插件 Gulp不完全入门教程 Gulp 入门指南 其他 Other Article 关于Pornographic website的一些前端分析 微信公众号开发 Atom技巧总结 Mac小技巧 CSDN页面内JS跳转脚本 CSDN博客隐藏配置 百度设置小度机器人出现 前端冷知识，妙用浏览器地址栏 Vim笔记 Cordova配置&amp;&amp;Ionic配置（WebApp混合开发环境） IE8及以下按钮超链接无法跳转的问题 分享功能 Share Reference 百度分享(PC) JiaThis(PC) 社会化分享组件(Mobile) ShareSDK轻松实现社会化功能(Mobile) 友盟分享(Mobile) 在线演示 Reference Reference js 在线编辑 - runjs js 在线编辑 - jsbin js 在线编辑 - codepen js 在线编辑 - jsfiddle java 在线编辑 - runjs js 在线编辑 - hcharts js 在线编辑 - jsdm sql 在线编辑 - sqlfiddle mozilla 在线编辑器 富文本编辑器 Reference Reference 百度ueditor ckeditor tinymce kindeditor wysiwyg BachEditor simditor summernote Squire wangEditor Chrome Reference Reference Chrome - 基础 Chrome - 进阶 Chrome - 性能 Chrome - 性能进阶 Chrome - 移动 Chrome - 使用技巧 Chrome - Console控制台不完全指南 chrome开发工具快捷键 Chrome 开发工具 Workspace 使用 Chrome神器Vimium快捷键学习记录 Sass调试-w3cplus 如何更专业的使用Chrome开发者工具-w3cplus Chrome调试canvas 神器——Chrome开发者工具(一) 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍 Chrome 开发者工具的 15 个小技巧 Chrome开发者工具不完全指南 Chrome 开发者工具使用技巧 性能优化 Reference Reference Javascript高性能动画与页面渲染 移动H5前端性能优化指南 给网页设计师和前端开发者看的前端性能优化 张鑫旭——前端性能 web前端性能优化进阶路 Hey——前端性能 YSLOW中文介绍 Yahoo!团队实践分享：网站性能 加载，不只是少一点点 由12306谈谈网站前端性能和后端性能优化 【高性能前端1】高性能HTML 【高性能前端2】高性能CSS 前端工程与性能优化（上）：静态资源版本更新与缓存 前端工程与性能优化（下）：静态资源管理与模板框架 HTTPS连接的前几毫秒发生了什么 Yslow 阿里无线前端性能优化指南(Pt.1 加载期优化) 毫秒必争，前端网页性能最佳实践 CDN Reference Reference Jquery&amp;Bootstrap中文网开源项目免费 CDN 服务 Bootstrap中文网开源项目免费 CDN 服务 新浪CDN 百度静态资源公共库 开放静态文件 CDN - 七牛 CDN加速 - jq22 微软CDN Angular CDN 360网站卫士常用前端公共库CDN服务 Git Article Article Git操作 Git CSDN Blog Reference Reference Git-scm Git-for-windows 廖雪峰-Git教程 Gogithub Git常规命令练习 Git的资料整理 我所记录的git命令（非常实用） GitHub 漫游指南 GitHub秘籍 动画方式练习git Sass&amp;Less Article Article Less教程 Reference Reference Sass Sass中文文档 Less Markdown Reference Reference Markdown 语法说明 (简体中文版) Markdown入门参考 Mdeditor(一款国内的在线markdown编辑器) Stackedit(国外的在线markdown编辑器，功能强大，同步云盘) Mditor一款轻量级的markdown编辑器 lepture-editor Markdown-editor 前端文档 Reference Reference 前端知识结构 Web前端开发大系概览 免费的编程中文书籍索 前端书籍 前端免费书籍大全 重新介绍JavaScript（JS教程） Gitbook Front-End-Develop-Guide 前端开发指南 前端开发笔记本 大前端工具集 前端开发者手册 结合个人经历总结的前端入门方法 2016最新前端学习计划 前端规范 Reference Reference 通过分析github代码库总结出来的工程师代码书写习惯 HTML&amp;CSS编码规范 by @mdo 前端编码规范之js - by yuwenhui 前端编码规范之js - by 李靖 Airbnb JavaScript 编码规范（简体中文版） AMD与CMD规范的区别 AMD与CMD规范的区别 KISSY 源码规范 前端代码规范及最佳实践 百度前端规范 JavaScript风格指南/编码规范（Airbnb公司版） 网易前端开发规范 前端规范资源列表 Web 前端开发规范文档 前端面试 Reference Reference 2016校招内推 – 阿里巴巴前端 – 四面面试经历 那几个月在找工作（百度，网易游戏，华为） 前端开发面试题 Front-end-Interview-questions 5个经典的前端面试问题 Front-end-Developer-Interview-Questions BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 前端开发面试题大收集 收集的前端面试题和答案 前端开发面试题 前端面试大全 关于前端面试 前端网站 Reference Reference 掘金 百度FEX 阿里UED 菜鸟教程 QDFuns 幕课网 Codepen Sentsin CTOLib CTOLib/Node JS练习 Reference Reference Codewars Javascript-puzzlers Freecodecamp中文版 ES6katas Now Coder牛客网 Leetcode Nodeschool Hackerrank 算法 Reference Reference 数据结构与算法 JavaScript 描述. 章节练习 常见排序算法（JS版） 经典排序 常见排序算法-js版本 ES Reference Reference Exploring-ES6翻译 阮一峰 ES6 ECMA-262，第 5 版 ES5 本文引用自：https://github.com/GuoXingGitHub/Front-end-tutorial","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"web前端","slug":"web前端","permalink":"https://ax-codes.github.io/tags/web%E5%89%8D%E7%AB%AF/"}]},{"title":"C#控件属性事件大全","slug":"技术/2015-01-22-csharp控件属性事件大全","date":"2015-01-22T00:00:00.000Z","updated":"2020-06-09T10:00:01.586Z","comments":true,"path":"2015/01/22/技术/2015-01-22-csharp控件属性事件大全/","link":"","permalink":"https://ax-codes.github.io/2015/01/22/%E6%8A%80%E6%9C%AF/2015-01-22-csharp%E6%8E%A7%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%BA%8B%E4%BB%B6%E5%A4%A7%E5%85%A8/","excerpt":"","text":"点击下载 C#控件属性事件大全","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"}]},{"title":"C#学习笔记.exe下载","slug":"技术/2015-01-21-csharp学习笔记","date":"2015-01-21T00:00:00.000Z","updated":"2020-06-09T10:00:01.574Z","comments":true,"path":"2015/01/21/技术/2015-01-21-csharp学习笔记/","link":"","permalink":"https://ax-codes.github.io/2015/01/21/%E6%8A%80%E6%9C%AF/2015-01-21-csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"点击下载 C#学习笔记.exe","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"}]},{"title":"C#代码的编译过程","slug":"技术/2015-01-16-csharp代码的编译过程","date":"2015-01-16T00:00:00.000Z","updated":"2020-06-09T10:00:01.565Z","comments":true,"path":"2015/01/16/技术/2015-01-16-csharp代码的编译过程/","link":"","permalink":"https://ax-codes.github.io/2015/01/16/%E6%8A%80%E6%9C%AF/2015-01-16-csharp%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"}]},{"title":"virtualbox中ubuntu和windows共享文件夹设置","slug":"技术/2015-01-15-virtualbox中ubuntu和windows共享文件夹设置","date":"2015-01-15T00:00:00.000Z","updated":"2020-06-09T10:00:01.559Z","comments":true,"path":"2015/01/15/技术/2015-01-15-virtualbox中ubuntu和windows共享文件夹设置/","link":"","permalink":"https://ax-codes.github.io/2015/01/15/%E6%8A%80%E6%9C%AF/2015-01-15-virtualbox%E4%B8%ADubuntu%E5%92%8Cwindows%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"系统平台系统平台：win8.1、virtualbox4.3.8、ubuntu12.04安装VBoxGuestAdditions_4.3.8.iso增强工具，安装完毕后根据提示重启Ubuntu，具体操作如下： Step 1 Step 2.安装virtualbox增强包123456789101112131415linjiqin@ubuntu:~$ cd ~linjiqin@ubuntu:~$ su -密码： root@ubuntu:~# cd /media/root@ubuntu:/media# lssf_share VBOXADDITIONS_4.3.8_92456root@ubuntu:/media# cd VBOXADDITIONS_4.3.8_92456/root@ubuntu:/media/VBOXADDITIONS_4.3.8_92456# ls32Bit cert VBoxSolarisAdditions.pkg64Bit OS2 VBoxWindowsAdditions-amd64.exeAUTORUN.INF runasroot.sh VBoxWindowsAdditions.exeautorun.sh VBoxLinuxAdditions.run VBoxWindowsAdditions-x86.exeroot@ubuntu:/media/VBOXADDITIONS_4.3.8_92456# sudo ./VBoxLinuxAdditions.run #安装virtualbox增强包....root@ubuntu:/media/VBOXADDITIONS_4.3.8_92456# Step 3先关闭ubuntu，在virtualbox“设置”中找到“共享文件夹”，点击进入，点击右边添加目录按钮，添加windows中要共享的目录，取一个名。比如我在D盘建一个名为share的文件夹，如下图： Step 4重启ubuntu，在ubuntu系统最上端“设备”中找到“共享文件夹”，点击进入，点击右边添加目录按钮，添加第二步操作的共享目录，如下图： Step 5进入虚拟Ubuntu，在命令行终端下输入：sudo mkdir /mnt/sharedsudo mount -t vboxsf share /mnt/shared其中”share”是之前创建的共享文件夹的名字。OK，现在Ubuntu和主机可以互传文件了。要想自动挂载的话，可以在/etc/fstab中添加一项share /mnt/shared vboxsf rw,gid=100,uid=1000,auto 0 0 卸载的话使用下面的命令:sudo umount -f /mnt/shared 注意共享文件夹的名称千万不要和挂载点的名称相同。比如，上面的挂载点是/mnt/shared，如果共享文件夹的名字也是shared的话，在挂载的时候就会出现如下的错误信息：/sbin/mount.vboxsf: mounting failed with the error: Protocol error","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"},{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"https://ax-codes.github.io/tags/windows/"}]},{"title":"SBC大数据导入(代码)","slug":"技术/2015-01-09-SBC大数据导入(代码)","date":"2015-01-09T00:00:00.000Z","updated":"2020-06-09T10:00:01.558Z","comments":true,"path":"2015/01/09/技术/2015-01-09-SBC大数据导入(代码)/","link":"","permalink":"https://ax-codes.github.io/2015/01/09/%E6%8A%80%E6%9C%AF/2015-01-09-SBC%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5(%E4%BB%A3%E7%A0%81)/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381using System;using System.Collections.Generic;using System.Text;using System.Data;using System.IO;using System.Threading;using System.Web;using System.Xml;using System.Configuration;using System.Data.SqlClient;using WXMP.WinService.Data;namespace Utility.DataImport&#123; public class TxtImport &#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 导入数据 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;fileName&quot;&gt;文件名&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;columnCount&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;xmlTableName&quot;&gt;xml配置名&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;RealTableName&quot;&gt;数据库表名称&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;defaultValue&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;ConnectionKeyName&quot;&gt;数据库连接配置&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;heardRowCount&quot;&gt;文件头定义行数&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;footRowCount&quot;&gt;文件尾定义行数&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static int ImportData(string fileName, string xmlTableName, Dictionary&lt;string, object&gt; defaultValue, string ConnectionKeyName &#x3D; &quot;default&quot;, int heardRowCount &#x3D; 0, int footRowCount &#x3D; 0) &#123; if (fileName &#x3D;&#x3D; &quot;&quot;) return 0; return Insert(fileName, xmlTableName, defaultValue, ConnectionKeyName, heardRowCount, footRowCount); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 导入文本文件 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;fileFullName&quot;&gt;文本全路径&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;columnCount&quot;&gt;文本里需要导入的列的数目&lt;&#x2F;param&gt; public static int Insert(string fileFullName, string xmlTableName, Dictionary&lt;string, object&gt; defaultValue, string ConnectionKeyName, int heardRowCount &#x3D; 0, int footRowCount &#x3D; 0) &#123; string exesql &#x3D; string.Empty; string tablename &#x3D; string.Empty; DataTable dt &#x3D; XmlToDataTable(xmlTableName, out tablename, out exesql); if (dt !&#x3D; null) &#123; LoadAdpaterDataAndImport(fileFullName, dt.Columns.Count, dt, defaultValue, ConnectionKeyName, tablename, heardRowCount, footRowCount); DbHelper.ExecuteNonQuery(exesql, ConnectionKeyName); return dt.Rows.Count; &#125; return 0; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;fileFullName&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;columnCount&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pDTScheme&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;defaultValue&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;connectionName&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;realTableName&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;heardRowCount&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;footRowCount&quot;&gt;&lt;&#x2F;param&gt; public static void LoadAdpaterDataAndImport(string fileFullName, int columnCount, DataTable pDTScheme, Dictionary&lt;string, object&gt; defaultValue, string connectionName, string realTableName, int heardRowCount &#x3D; 0, int footRowCount &#x3D; 0) &#123; try &#123; using (StreamReader sr &#x3D; new StreamReader(fileFullName, Encoding.Default, true)) &#123; string strTmp; DataRow dr; int i &#x3D; 0; while (!sr.EndOfStream) &#123; strTmp &#x3D; sr.ReadLine(); if (string.IsNullOrEmpty(strTmp)) continue; i++; if (i &lt;&#x3D; heardRowCount) continue; heardRowCount &#x3D; 0; dr &#x3D; GetDataRow(strTmp, columnCount, pDTScheme, defaultValue); if (dr !&#x3D; null) pDTScheme.Rows.Add(dr); if (i % 100000 &#x3D;&#x3D; 0) &#123; UseSBCInsertDB(connectionName, pDTScheme, realTableName, 9000, true); pDTScheme.Rows.Clear(); i &#x3D; 0; Thread.Sleep(1000); &#125; &#125; if (pDTScheme.Rows.Count &gt; 0) UseSBCInsertDB(connectionName, pDTScheme, realTableName, 9000, true); DbHelper.ExecuteNonQuery(@&quot;INSERT INTO dbo.T_R01_FileLoadInfo(ImpName,LoadTime,RecordCount,LoadStatus)VALUES(&#39;&quot; + fileFullName.Substring(fileFullName.LastIndexOf(&quot;\\\\&quot;) + 1) + &quot;&#39;,&#39;&quot; + DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;) + &quot;&#39;,&#39;&quot; + (i - heardRowCount - footRowCount).ToString() + &quot;&#39;,&#39;0&#39;);&quot;, connectionName); &#125; &#125; catch (Exception ex) &#123; DbHelper.ExecuteNonQuery(@&quot;INSERT INTO dbo.T_R01_FileLoadInfo(ImpName,LoadTime,RecordCount,LoadStatus)VALUES(&#39;&quot; + fileFullName.Substring(fileFullName.LastIndexOf(&quot;\\\\&quot;) + 1) + &quot;&#39;,&#39;&quot; + DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;) + &quot;&#39;,&#39;&#39;,&#39;3&#39;);&quot;, connectionName); Utility.Logging.Log.Instance.Write(&quot;读取文件发生异常&quot; + ex.Message, Logging.MessageType.Error); &#125; &#125; protected static DataRow GetDataRow(string strTmp, int columnCount, DataTable pDTScheme, Dictionary&lt;string, object&gt; defaultValue) &#123; string[] result &#x3D; strTmp.Split(new string[] &#123; &quot;&amp;&amp;&quot; &#125;, StringSplitOptions.None); DataRow dr &#x3D; null; if (result.Length &gt;&#x3D; columnCount) &#123; dr &#x3D; pDTScheme.NewRow(); for (int n &#x3D; 0; n &lt; columnCount; n++) &#123; try &#123; if (pDTScheme.Columns[n].DataType &#x3D;&#x3D; typeof(System.Decimal) &amp;&amp; result[n] &#x3D;&#x3D; &quot;&quot;) &#123; dr[n] &#x3D; 0; &#125; else if (pDTScheme.Columns[n].DataType &#x3D;&#x3D; typeof(System.Int32) &amp;&amp; result[n] &#x3D;&#x3D; &quot;&quot;) &#123; dr[n] &#x3D; 0; &#125; else if (pDTScheme.Columns[n].DataType !&#x3D; typeof(System.String) &amp;&amp; result[n] &#x3D;&#x3D; &quot;&quot;) &#123; dr[n] &#x3D; DBNull.Value; &#125; else if (pDTScheme.Columns[n].DataType !&#x3D; typeof(System.DateTime) &amp;&amp; result[n] &#x3D;&#x3D; &quot;&quot;) &#123; dr[n] &#x3D; DBNull.Value; &#125; else dr[n] &#x3D; result[n]; &#125; catch &#123; dr[n] &#x3D; DBNull.Value; &#125; &#125; Type t &#x3D; null; DataColumn dc &#x3D; null; object obj &#x3D; null; for (int n &#x3D; columnCount; n &lt; pDTScheme.Columns.Count; n++) &#123; dc &#x3D; pDTScheme.Columns[n]; if (defaultValue !&#x3D; null) &#123; if (defaultValue.TryGetValue(dc.ColumnName, out obj)) &#123; dr[n] &#x3D; obj; &#125; else &#123; if (dc.DefaultValue &#x3D;&#x3D; DBNull.Value) &#123; t &#x3D; pDTScheme.Columns[n].DataType; if (t &#x3D;&#x3D; typeof(String)) dr[n] &#x3D; &quot;&quot;; else if (t &#x3D;&#x3D; typeof(Guid)) dr[n] &#x3D; Guid.NewGuid(); else if (t &#x3D;&#x3D; typeof(DateTime)) dr[n] &#x3D; DateTime.Now; else if (t &#x3D;&#x3D; typeof(int)) dr[n] &#x3D; 0; else if (t &#x3D;&#x3D; typeof(decimal)) dr[n] &#x3D; 0.00; &#125; else &#123; dr[n] &#x3D; pDTScheme.Columns[n].DefaultValue; &#125; &#125; &#125; else &#123; if (dc.DefaultValue &#x3D;&#x3D; DBNull.Value) &#123; t &#x3D; pDTScheme.Columns[n].DataType; if (t &#x3D;&#x3D; typeof(String)) dr[n] &#x3D; &quot;&quot;; else if (t &#x3D;&#x3D; typeof(Guid)) dr[n] &#x3D; Guid.NewGuid(); else if (t &#x3D;&#x3D; typeof(DateTime)) dr[n] &#x3D; DateTime.Now; else if (t &#x3D;&#x3D; typeof(int)) dr[n] &#x3D; 0; else if (t &#x3D;&#x3D; typeof(decimal)) dr[n] &#x3D; 0.00; &#125; else &#123; dr[n] &#x3D; pDTScheme.Columns[n].DefaultValue; &#125; &#125; &#125; &#125; return dr; &#125; #region【封装的业务逻辑方法，配合InsertBossDetail进行使用】 public static DataTable XmlToDataTable(string dataName, out string tablename, out string exesql) &#123; tablename &#x3D; string.Empty; exesql &#x3D; string.Empty; string path &#x3D; System.AppDomain.CurrentDomain.BaseDirectory + &quot;&#x2F;Config&#x2F;Imps.config&quot;; XmlDocument doc &#x3D; new XmlDocument(); doc.Load(path); XmlNode tableRoot &#x3D; doc.SelectSingleNode(&quot;&#x2F;imps&#x2F;imp[@name&#x3D;&#39;&quot; + dataName + &quot;&#39;]&quot;); if (tableRoot !&#x3D; null) &#123; DataTable dt &#x3D; new DataTable(); DataColumn dc &#x3D; null; string defualtValue; tablename &#x3D; tableRoot.SelectSingleNode(&quot;table&quot;).Attributes[&quot;name&quot;].Value; exesql &#x3D; tableRoot.SelectSingleNode(&quot;sql&quot;).InnerText; foreach (XmlNode node in tableRoot.SelectSingleNode(&quot;table&quot;).ChildNodes) &#123; dc &#x3D; new DataColumn(node.Attributes[&quot;name&quot;].Value.Trim(), Type.GetType(node.Attributes[&quot;type&quot;].Value.Trim())); if (!string.IsNullOrEmpty(defualtValue &#x3D; node.Attributes[&quot;default&quot;] !&#x3D; null ? node.Attributes[&quot;default&quot;].Value.Trim() : null)) dc.DefaultValue &#x3D; defualtValue; dt.Columns.Add(dc); &#125; return dt; &#125; return null; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 用SBC方法插入数据库 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;ConnectionStringKey&quot;&gt;要插入的数据库&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pDataTable&quot;&gt;要插入的DATATABLE&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pTableName&quot;&gt;对应的数据库表名&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pBulkCopyTimeout&quot;&gt;数据库连接过期时间,单位：秒&lt;&#x2F;param&gt; public static void UseSBCInsertDB(string ConnectionStringKey, DataTable pDataTable, string pTableName, int pBulkCopyTimeout &#x3D; -1, bool appingFlag &#x3D; false) &#123; string connectionString &#x3D; ConfigurationManager.ConnectionStrings[ConnectionStringKey].ConnectionString; using (SqlBulkCopy sqlBulkCopy &#x3D; new SqlBulkCopy(connectionString)) &#123; sqlBulkCopy.DestinationTableName &#x3D; pTableName; sqlBulkCopy.BatchSize &#x3D; pDataTable.Rows.Count; if (pBulkCopyTimeout &gt; 0) sqlBulkCopy.BulkCopyTimeout &#x3D; pBulkCopyTimeout; if (appingFlag) &#123; foreach (DataColumn dc in pDataTable.Columns) sqlBulkCopy.ColumnMappings.Add(dc.ColumnName, dc.ColumnName); &#125; using (SqlConnection sqlConnection &#x3D; new SqlConnection(connectionString)) &#123; sqlConnection.Open(); if (pDataTable !&#x3D; null &amp;&amp; pDataTable.Rows.Count !&#x3D; 0) &#123; sqlBulkCopy.WriteToServer(pDataTable); &#125; &#125; &#125; &#125; #endregion #region【转换文件】 public static string TransferFile(string fileFullName, bool isDelOriFile &#x3D; true) &#123; string path &#x3D; Path.GetDirectoryName(fileFullName); &#x2F;&#x2F;fileFullName.Substring(0, fileFullName.LastIndexOf(&#39;\\\\&#39;)); string newFileName &#x3D; string.Format(&quot;&#123;0&#125;&#123;1&#125;.txt&quot;, path, DateTime.Now.ToString(&quot;yyyyMMddHHmmss&quot;)); Encoding en &#x3D; GetEncoding(fileFullName, Encoding.Default); using (StreamReader sr &#x3D; new StreamReader(fileFullName, en, true)) &#123; using (StreamWriter sw &#x3D; new StreamWriter(newFileName, true, Encoding.UTF8)) &#123; string strTmp; while (!sr.EndOfStream) &#123; strTmp &#x3D; sr.ReadLine(); if (!string.IsNullOrEmpty(strTmp)) &#123; sw.WriteLine(strTmp); &#125; &#125; sw.Flush(); sw.Close(); &#125; &#125; if (isDelOriFile &amp;&amp; File.Exists(fileFullName)) File.Delete(fileFullName); return newFileName; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 取得一个文本文件的编码方式。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;fileName&quot;&gt;文件名。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;defaultEncoding&quot;&gt;默认编码方式。当该方法无法从文件的头部取得有效的前导符时，将返回该编码方式。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static Encoding GetEncoding(string fileName, Encoding defaultEncoding) &#123; using (FileStream fs &#x3D; new FileStream(fileName, FileMode.Open)) &#123; Encoding targetEncoding &#x3D; GetEncoding(fs, defaultEncoding); fs.Close(); return targetEncoding; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 取得一个文本文件流的编码方式。 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;stream&quot;&gt;文本文件流。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;defaultEncoding&quot;&gt;默认编码方式。当该方法无法从文件的头部取得有效的前导符时，将返回该编码方式。&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static Encoding GetEncoding(FileStream stream, Encoding defaultEncoding) &#123; Encoding targetEncoding &#x3D; defaultEncoding; if (stream !&#x3D; null &amp;&amp; stream.Length &gt;&#x3D; 2) &#123; &#x2F;&#x2F;保存文件流的前4个字节 byte byte1 &#x3D; 0; byte byte2 &#x3D; 0; byte byte3 &#x3D; 0; byte byte4 &#x3D; 0; &#x2F;&#x2F;保存当前Seek位置 long origPos &#x3D; stream.Seek(0, SeekOrigin.Begin); stream.Seek(0, SeekOrigin.Begin); int nByte &#x3D; stream.ReadByte(); byte1 &#x3D; Convert.ToByte(nByte); byte2 &#x3D; Convert.ToByte(stream.ReadByte()); if (stream.Length &gt;&#x3D; 3) &#123; byte3 &#x3D; Convert.ToByte(stream.ReadByte()); &#125; if (stream.Length &gt;&#x3D; 4) &#123; byte4 &#x3D; Convert.ToByte(stream.ReadByte()); &#125; &#x2F;&#x2F;根据文件流的前4个字节判断Encoding &#x2F;&#x2F;Unicode &#123;0xFF, 0xFE&#125;; &#x2F;&#x2F;BE-Unicode &#123;0xFE, 0xFF&#125;; &#x2F;&#x2F;UTF8 &#x3D; &#123;0xEF, 0xBB, 0xBF&#125;; if (byte1 &#x3D;&#x3D; 0xFE &amp;&amp; byte2 &#x3D;&#x3D; 0xFF)&#x2F;&#x2F;UnicodeBe &#123; targetEncoding &#x3D; Encoding.BigEndianUnicode; &#125; if (byte1 &#x3D;&#x3D; 0xFF &amp;&amp; byte2 &#x3D;&#x3D; 0xFE &amp;&amp; byte3 !&#x3D; 0xFF)&#x2F;&#x2F;Unicode &#123; targetEncoding &#x3D; Encoding.Unicode; &#125; if (byte1 &#x3D;&#x3D; 0xEF &amp;&amp; byte2 &#x3D;&#x3D; 0xBB &amp;&amp; byte3 &#x3D;&#x3D; 0xBF)&#x2F;&#x2F;UTF8 &#123; targetEncoding &#x3D; Encoding.UTF8; &#125; &#x2F;&#x2F;恢复Seek位置 stream.Seek(origPos, SeekOrigin.Begin); &#125; return targetEncoding; &#125; #endregion &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"csharp","slug":"csharp","permalink":"https://ax-codes.github.io/tags/csharp/"}]},{"title":"python编写规范pep8的问题笔记","slug":"技术/2015-01-01-python编写规范pep8的问题笔记","date":"2015-01-01T00:00:00.000Z","updated":"2020-06-09T10:00:01.557Z","comments":true,"path":"2015/01/01/技术/2015-01-01-python编写规范pep8的问题笔记/","link":"","permalink":"https://ax-codes.github.io/2015/01/01/%E6%8A%80%E6%9C%AF/2015-01-01-python%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83pep8%E7%9A%84%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"字数,函数限制一行列数: PEP 8 规定为 79 列，这个太苛刻了，如果要拼接url一般都会超。一个函数: 不要超过 30 行代码, 即可显示在一个屏幕类，可以不使用垂直游标即可看到整个函数。一个类: 不要超过 200 行代码，不要有超过 10 个方法。一个模块: 不要超过 500 行。 不要在一句import中多个库不推荐:import os, sys推荐:import osimport sys 错误记录错误记录: W292 no newline at end of file处理:打个回车有新的一空行即可（新行不要有空格 错误记录:E302 expected 2 blank lines, found 1处理:上面只有一行空白，但是需要两个空白行 错误记录:E231 missing whitespace after ‘,’翻译:“，”后要有空格举例:错误 print(“%s %s %s %s %s %s” % (A,B,D,E,K,L))正确 print(“%s %s %s %s %s %s” % (A, B, D, E, K, L)) 错误记录:E225 missing whitespace around operator翻译:举例:错误 print(“%s %s %s %s %s %s”%(A, B, D, E, K, L))正确 rint(“%s %s %s %s %s %s”% (A, B, D, E, K, L)) 错误记录:E225 missing whitespace around operator举例:错误 f=open(“D:\\test.txt”, “ab”)正确 f = open(“D:\\test.txt”, “ab”) 本文引用自：http://www.simonzhang.net/?p=1072","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ax-codes.github.io/tags/python/"}]},{"title":"Hexo-theme-pure主题books默认选择想读","slug":"技术/2014-12-31-Hexo-theme-pure主题books默认选择想读","date":"2014-12-31T00:00:00.000Z","updated":"2020-06-09T10:00:01.557Z","comments":true,"path":"2014/12/31/技术/2014-12-31-Hexo-theme-pure主题books默认选择想读/","link":"","permalink":"https://ax-codes.github.io/2014/12/31/%E6%8A%80%E6%9C%AF/2014-12-31-Hexo-theme-pure%E4%B8%BB%E9%A2%98books%E9%BB%98%E8%AE%A4%E9%80%89%E6%8B%A9%E6%83%B3%E8%AF%BB/","excerpt":"","text":"Hexo-theme-pure主题books默认是选择在读的，现在我们需要将想读移动到前面 步骤Step 1.修改样式 在主题的layout-&gt;_partial的 archive-book.ejs调换想读和在读的顺序 Step 2.修改js 在主题的layout-&gt;_script的 douban.ejs 将show(reading)改成show(‘wish’)，然后刷新就有效果了","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"c语言提高1-进程空间,一维数组","slug":"技术/2014-12-28-c语言提高1-进程空间,一维数组","date":"2014-12-28T00:00:00.000Z","updated":"2020-06-09T10:00:01.554Z","comments":true,"path":"2014/12/28/技术/2014-12-28-c语言提高1-进程空间,一维数组/","link":"","permalink":"https://ax-codes.github.io/2014/12/28/%E6%8A%80%E6%9C%AF/2014-12-28-c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%981-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4,%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/","excerpt":"","text":"数据类型数据类型的作用在线性的内存中添加一种逻辑操作 补码的特点正数的补码是他本身负数的补码：该负数对应的正数的补码取反加一一个8位的有符号的数据范围为什么是-128到127：因为补码编码的格式不同导致 数据在内存中的意义数据本身是没有意义的，只是要看我们怎样来解释他 类型转化小类型遇到大类型需要转化为大类型，位数不够的话会根据原类型的符号位来补位（是0补0，是1补1）整形遇到浮点型需要转化为浮点型有符号和无符号的运算结果是有符号的转化都是低位对低位进行取值（低位对齐） 进程空间虚拟空间虚拟内存不是我们生活上指的内存条，而是我们通过他来映射到物理内存的一套机制；虚拟内存的好处：早先的电脑是直接将我们运行的程序加载到物理内存中，所以会造成不同的程序直接可以相互调用的后果（很不安全），但是有了这套机制之后，就没有这个缺点了 变量的存放区域总结只要是未初始化的全局或者是静态变量全部储存在data段的未初始化数据段(bss)，默认初始化为0auto的局部变量名无论初始化或者未初始化都储存在栈空间所有的常量都是存储在data区域的只读区域text是储存二进制文件（运行程序）(.exe/.out)的地方 图示 数组以及练习点击查看代码 注意:地址的加减其实是加减地址所指向空间的数量，只有&amp;+数组名才是操作数组的整体","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言12-共同体,枚举","slug":"技术/2014-12-18-c语言12-共同体,枚举","date":"2014-12-18T00:00:00.000Z","updated":"2020-06-09T10:00:01.554Z","comments":true,"path":"2014/12/18/技术/2014-12-18-c语言12-共同体,枚举/","link":"","permalink":"https://ax-codes.github.io/2014/12/18/%E6%8A%80%E6%9C%AF/2014-12-18-c%E8%AF%AD%E8%A8%8012-%E5%85%B1%E5%90%8C%E4%BD%93,%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"公用体(union) 共用体的申明和结构体一样， 公用体可以嵌套到结构体中，达到一列可以表示不同类型的结果 公用体的大小，由最大的成员空间构成 公用体每一个成员都共同拥有一个首地址，只是因为寻址能力的不同而取到的数据不同，小类型都从低位开始获取数据小端序.就是（栈空间）低位存的是后申请的数据，我们的电脑一般都是小端序大端序.则是低位存的是先申请的数据验证大小端序方法. 验证大小端序的两种方法12345678910111213141516union utest &#123; int num; char num2; &#125;; int main(void) &#123; union utest; t.num = 0x12345678;//储存在栈空间因为栈空间是先申请的在高位（自上向下） //printf(\"%x\\n\",t.num2);//系统帮忙省略了0x if (t.num2 == 0x78) printf(\"小端序！\\n\"); else printf(\"大端序！\\n\"); return0; &#125; 12345int data=0x12345678;if((char)data==0x78)//if(*(char*)(&amp;data))//先获取到data的地址，然后将int*转换成char*，所以取到最后一个字节的空间地址，再取出* printf(\"小端序\");else printf(\"大端序\"); 枚举枚举是一个整形的常量集合，给前面的一个变量赋值一个数值，后面的变量会逐一加一","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"C++引用的理解","slug":"技术/2014-12-09-C++引用的理解","date":"2014-12-09T00:00:00.000Z","updated":"2020-06-09T10:00:01.553Z","comments":true,"path":"2014/12/09/技术/2014-12-09-C++引用的理解/","link":"","permalink":"https://ax-codes.github.io/2014/12/09/%E6%8A%80%E6%9C%AF/2014-12-09-C++%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"定义引用引入了对象的一个同义词.定义引用的表示方法与定义指针相似,只是用&amp;代替了*.引用（reference）是c++对c语言的重要扩充.引用就是某一变量（目标）的一个别名,对引用的操作与对变量直接操作完全一样.其格式为:类型 &amp;引用变量名 = 已定义过的变量名. 特点一个变量可取多个别名. 引用必须初始化. 引用只能在初始化的时候引用一次 ,不能更改为转而引用其他变量. code基础引用12345678910111213void TestReference1 () &#123; int a = 1; int&amp; b = a; cout&lt;&lt;\"a:address-&gt;\" &lt;&lt;&amp;a&lt;&lt; endl; cout&lt;&lt;\"b:address-&gt;\" &lt;&lt;&amp;b&lt;&lt; endl; a = 2; b = 3; int&amp; c = b;// 引用一个引用变量,别名的别名 c = 4; &#125; const引用1234567891011121314151617void TestReference2 () &#123; int d1 = 4; const int &amp; d2 = d1; d1 = 5;//d1改变,d2的值也会改变. //d2 = 6;//不能给常量（不能被修改的量）赋值. const int d3 = 1; const int &amp; d4 = d3; //int&amp;d5 = d3; const int &amp; d6 = 5;//常量具有常性,只有常引用可以引用常量 double d7 = 1.1; //int&amp; d8 = d7;//d7是double类型,d8是int,d7赋值给 d8时要生成一个临时变量 //也就是说d8引用的是这个带有常性的临时变量,所以不能赋值. const int&amp; d9 = d7; &#125; 引用作参数123456789101112131415161718192021221.【值传递】如果形参为非引用的传值方式,则生成局部临时变量接收实参的值 void Swap (int left, int right) //值传递的方式无法实现交换,因为传参时对于参数left和right拷贝一临时副本,交换的是副本值,因为其是临时变量函数退出,变量销 &#123; //毁,并不会影响外部left和right的值. int temp = left; left = right ; right = temp ; &#125; 2.【引用传递】如果形参为引用类型,则形参是实参的别名. void Swap (int&amp; left, int&amp; right)//使用引用的话,不做临时拷贝,&amp;的使用说明此处只是原参数的另一个名字而已,所以修改时直接在原参数的基础上修改变量值. &#123; int temp = left; right = left ; left = temp ; &#125; 3.【指针传递】 void Swap (int* pLeft, int* pRight)//传入的是地址,因为地址是唯一的,所以指针通过地址的访问进而可修改其内容. &#123; int temp = *pLeft; *pLeft = *pRight; *pRight = temp; &#125; 注意不要返回一个临时变量的引用.如果返回对象出了当前函数的作用域依旧存在,则最好使用引用返回,因为这样更高效. 引用和指针的区别和联系（笔试热点）引用必须指向有效的变量,指针可以为空.sizeof指针对象和引用对象的意义不一样.sizeof引用得到的是所指向的变量的大小,而sizeof指针是对象地址的大小.指针和引用自增(++)自减(–)意义不一样.相对而言,引用比指针更安全. 引用和指针的区别和联系不同点指针是一个实体,而引用仅是个别名;引用使用时无需解引用(*),指针需要解引用;引用只能在定义时被初始化一次,之后不可变;指针可变;引用没有 const,指针有 const;const修饰的指针不可变;引用不能为空,指针可以为空;“sizeof 引用”得到的是所指向的变量(对象)的大小,而”sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小;指针和引用的自增(++)运算意义不一样;从内存分配上看:程序为指针变量分配内存区域,而引用不需要分配内存区域. 相同点两者都是地址的概念,指针指向一块儿内存,其内容为所指内存的地址;引用是某块儿内存的别名 const在C和C++中的含义(笔试热点)C中的const,功能比较单一,较容易理解作用:被修饰的内容不可更改.使用场合:修饰变量,函数参数,返回值等.（c++中应用场合要丰富的多）特点: 是运行时const,因此不能取代#define用于成为数组长度等需要编译时常量的情况.同时因为是运行时const,可以只定义而不初始化,而在运行时初始化.如 const int iConst;. 另外,在c中,const变量默认是外部链接,因此在不同的编译单元中如果有同名const变量,会引发命名冲突,编译时报错. c++中的const非类成员constconst变量默认是内部连接的,因此在不同的编译单元中可以有同名的const 变量定义.编译时常量,因此可以像#define一样使用,而且因为上面一点,可以在头文件中定义const变量,包含的不同的cpp文件（编译单元）中使用而不引起命名冲突.编译器默认不为const变量分配内存,除非:1. 使用 extern 申明, 2:程序中有引用const 变量的地址.c++中临时对象/内置变量默认具有const属性. 类中的const与c语言中的const一样,只是运行时常量,不能作为数组维数使用,即不能取代#define.在类中使用下面两种方式取代#define: 1:static const…enum{….}//enum 不占存储空间.类中的const 变量占用存储空间.类中的const成员变量需要在构造函数初始化列表中初始化.const 对象:在该对象生命周期内,必须保证没有任何成员变量被改变.const对象只能调用const成员函数.const成员函数: void fun() const … 不仅能被const对象调用,也能被非const对象调用,因此,如果确认一个任何成员函数不改变任何成员变量,应该习惯性将该函数定义成const类型.如果一个对象被定义成const,那么该const对象”可能”会被放入到ROM当中,这在嵌入式开发当中有时非常重要. 本文引用自：http://blog.csdn.net/Xiao__Tian__/article/details/51814617","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://ax-codes.github.io/tags/c/"}]},{"title":"HEXO文档中带文件","slug":"技术/2014-12-04-HEXO文档中带文件","date":"2014-12-04T00:00:00.000Z","updated":"2020-06-09T10:00:01.551Z","comments":true,"path":"2014/12/04/技术/2014-12-04-HEXO文档中带文件/","link":"","permalink":"https://ax-codes.github.io/2014/12/04/%E6%8A%80%E6%9C%AF/2014-12-04-HEXO%E6%96%87%E6%A1%A3%E4%B8%AD%E5%B8%A6%E6%96%87%E4%BB%B6/","excerpt":"","text":"图片：","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"c语言提高6-数据结构,双向循环链表,动态库和静态库","slug":"技术/2014-11-27-c语言提高6-数据结构-双向循环链表-动态库和静态库","date":"2014-11-27T00:00:00.000Z","updated":"2020-06-09T10:00:01.547Z","comments":true,"path":"2014/11/27/技术/2014-11-27-c语言提高6-数据结构-双向循环链表-动态库和静态库/","link":"","permalink":"https://ax-codes.github.io/2014/11/27/%E6%8A%80%E6%9C%AF/2014-11-27-c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%986-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/","excerpt":"","text":"双向链表双向循环链表和单向链表的区别:1: 双向链表比单向链表多了一个指向前一个节点的指针2: 单向链表的验证结束位置是判断是否为NULL，双向循环链表判断是否结束是判断节点是否跟head节点是否相同，所以我们处理双向链表的时候总是要先保存好头结点 双向链表所有代码事例双向链表所有代码 动态库和静态库动态库和静态库的加载是在链接阶段，因此在链接之前我们只需要提供申明就行，在最后链接上动态或者静态库动态库和静态库: 动态和静态库都是编译好的二进制文件动态库和静态库的标识:.o是静态库 .so是动态库动态库的特点和缺点:动态库在编译的时候没有加载进目标代码中，所以会使动态库所产生的可执行性文件比较小，但是每次程序运行都需要提供对应的动态库，并且同一时间供多个线程调用静态库的特点和缺点:静态库在编译的时候就被加载进了目标代码中，所以会显得产生的可执行性文件会比较大，但是后面运行程序的时候都不用再提供库了，并且同一时间点只能供一个线程用","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言提高5-字符串","slug":"技术/2014-11-19-c语言提高5-字符串","date":"2014-11-19T00:00:00.000Z","updated":"2020-06-09T10:00:01.546Z","comments":true,"path":"2014/11/19/技术/2014-11-19-c语言提高5-字符串/","link":"","permalink":"https://ax-codes.github.io/2014/11/19/%E6%8A%80%E6%9C%AF/2014-11-19-c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%985-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串和字符数组sizeof时候的区别在直接sizeof(“字符串”) 字符串的时候，我们此时不能把字符串当作指针来判断，需要将其做为字符数组来看，所以sizeof(“china”) 不等于4而是等于6 字符串字符串n系列函数跟非n函数比较:防止读写越界，所以里面提供了指定的参数来描述我们需要操作的字符数字符串的查询函数:strchr:在一串字符里面，匹配单个字符，存在返回匹配到的数据的地址，否则返回NULLstrstr:在一串字符串里面匹配一串字符，存在则返回匹配到的第一个字符串，否则返回NULL 字符串操作函数代码事例:字符串操作函数代码 内存操作函数特点：只关心读取内容的多少，不关心内容，所以可以过滤掉一些特殊字符12345void * memcpy (void * dst, void const * src, size_t length);void * memmove(void * dst, void const * src, size_t length);void * memcmp (void const * a, void const * b,size_t length);void * memchr (void const * a, int ch, size_t length);void * memset (void * a, int ch ,size_t length); 内存操作函数代码例子:内存操作函数代码 操作字符指针的思想定义两个指针，记录不同的状态值，再根据对应的状态来进行赋值或者其他操作","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言提高4-回调函数,再论指针与数组,基于数组的排序及优化,基于数组的查找及优化,字符串提高","slug":"技术/2014-11-10-c语言提高4-回调函数-再论指针与数组-基于数组的排序及优化-基于数组的查找及优化-字符串提高","date":"2014-11-10T00:00:00.000Z","updated":"2020-06-09T10:00:01.542Z","comments":true,"path":"2014/11/10/技术/2014-11-10-c语言提高4-回调函数-再论指针与数组-基于数组的排序及优化-基于数组的查找及优化-字符串提高/","link":"","permalink":"https://ax-codes.github.io/2014/11/10/%E6%8A%80%E6%9C%AF/2014-11-10-c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%984-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-%E5%86%8D%E8%AE%BA%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8F%8A%E4%BC%98%E5%8C%96-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8F%8A%E4%BC%98%E5%8C%96-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E9%AB%98/","excerpt":"","text":"回调函数理解:回调函数就是用与调用函数同级的函数作为参数从而来控制被调用方函数的逻辑 标准库函数qsort qsort代码例子qsort代码 再论指针与数组12345678910111213141516171819int array[8][8] 二维数组int *ptr 一级指针int * array[10] 指针数组int * p[3][4] 指针数组int (*p)[3][4] 数组指针 int (*p)[3][4]=&gt; int [3][4] * p：所以是个数组指针int (*p[3])[4] 最外层理解：数组指针char * func() 函数char (*func)() 函数指针char (* func[3])() 函数指针数组 int arr[4]; 等价传递 foo(arr,4) foo(int *p, int n)int arr[3][4]; 等价传递 foo(arr,3) foo(int(*p)[4],int n)char *argv[3]; 等价传递 foo(argv,3) foo(int ** argv,int n)//注意传过来的是char*类型char * p; 等价传递 foo(p) foo(char * p)char * p=NULL; 初始化传递 foo(&amp;p) foo(char **p)char **p 等价传递 foo(p) foo(char **p)char **p =NULL; 初始化传递 foo(&amp;p) foo(char *** p)int (*p)[4]; 等价传递 foo(p) foo(int (*p)[4]) //指针数组原先类型就是 int[4]* 所以接收的时候可以直接用void func(int,int); 回调传递 foo(func) foo(void (*p)(int,int)) 数组排序优化版数组排序优化版 qsotr实现二级排序(对结构体)qsotr实现二级排序(对结构体) 字符串字符串常量的本质是一个指针:字符串里面的内容是不能修改的，但是指向字符串的指针变量的是可以修改的例如:char * p=”china”; p是可以修改指向和内容的，但是p所指向的内容是不能修改的数组名的常量:数组名在本作用域内是不能修改的，但是如果将参数名传递到一个新的函数内是可以进行指针偏移的，只是在申明该数组的时候不能进行偏移","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言提高3-指针加强,const,函数指针,回调函数","slug":"技术/2014-11-03-c语言提高3-指针加强-const-函数指针-回调函数","date":"2014-11-03T00:00:00.000Z","updated":"2020-06-09T10:00:01.540Z","comments":true,"path":"2014/11/03/技术/2014-11-03-c语言提高3-指针加强-const-函数指针-回调函数/","link":"","permalink":"https://ax-codes.github.io/2014/11/03/%E6%8A%80%E6%9C%AF/2014-11-03-c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%983-%E6%8C%87%E9%92%88%E5%8A%A0%E5%BC%BA-const-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/","excerpt":"","text":"指针加强1：指针在内存中都是线性的，如果变成二维或者多维空间只是我们在上面强加了一层逻辑而已，所以无论几维的空间我们都可以以一维空间的方式来访问；2：二维数组是一种二维空间，但是二维空间不代表就只能是二维数组，只是二维空间具有二维数组的访问形式 堆上根据二级,三级指针做形参,做返回值来申请二维空间的代码堆上根据二级,三级指针做形参,做返回值来申请二维空间 序列加密的代码序列加密的代码 利用二级指针的方式读取文件到堆内存利用二级指针的方式读取文件到堆内存 const关键字修饰变量不能被修改在左边: 不能修改指向在右边: 不能修改数据*左右都被const修饰: 数据和指向都不能修改 const与defined的区别: const有类型的概念，但是defind没有 const变量定义前必须初始化 函数 函数名的本质: 指向函数体这段代码段的首地址 接收函数名的类型: 返回值 （变量名）（形参类型）；我们可以直接把函数声明拿过来然后把函数名替换成(变量名) 函数指针的申明: 如2直接在变量名加上“[个数]” 回调函数: 调用一个别的方法然后将自己的一个方法名当参数传过去，这样就能将自己的逻辑加在别人的代码里，从而增强灵活性","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言提高2-二维数组,隐式类型转化,数组指针,指针数组,二级指针","slug":"技术/2014-10-25-c语言提高2-二维数组-隐式类型转化-数组指针-指针数组-二级指针","date":"2014-10-25T00:00:00.000Z","updated":"2020-06-09T10:00:01.536Z","comments":true,"path":"2014/10/25/技术/2014-10-25-c语言提高2-二维数组-隐式类型转化-数组指针-指针数组-二级指针/","link":"","permalink":"https://ax-codes.github.io/2014/10/25/%E6%8A%80%E6%9C%AF/2014-10-25-c%E8%AF%AD%E8%A8%80%E6%8F%90%E9%AB%982-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/","excerpt":"","text":"备注备注1强转为int或者char类型则是单纯的数值上的加减，都是每个地址相隔的个数大小，然后每个地址相隔一强转为int*则是地址上的加减，相隔的是每个int的数量 备注2六进制和八进制在字符串中表现的效果： 8进制：”\\0数字数字”：格式是+0后面的八进制数据， 如果说中间出现截断行为（中间出现不是8进制的字符）的话，则后面的都算是单个字符了，注意八进制最多包含0后面两位 16进制：格式：+x+十六进制数表示一个字节：如果说中间出现截断行为（中间出现不是16进制的字符）的话，则后面的都算是单个字符了 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123; char str1[]=\"\\0373xei\";//037算一个字节 后面的依次每个字符算一个字节 //char str1[]=\"\\0383xei\";//03算一个字节 后面的依次每个字符算一个字节 //char str2[]=\"\\x2aet76543\";//x2ae 算一个字节 后面的依次每个字符算一个字节 char str2[]=\"\\x3456aeccaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";//这里只有一个字节因为全部都是十六进制的数据 printf(\"%d\\n\",strlen(str1)); printf(\"%d\\n\",strlen(str2)); return 0;&#125; 类型转化(隐式)小类型与大类型所运算或者逻辑时会默认转化为大类型，有符号的与无符号的会默认转化为无符号的作用：防止数据丢失的一种机制备注：数据本身是没有意义的，只要是要看我们是怎样去解释他1：小类型-&gt;大类型：低位对齐2：大类型-&gt;小类型：低位对齐，改变后注意两个类型的数据的符号是否相同，该过程一定会发生截断行为，但是数据是否丢失，不一定3：有符号-&gt;无符号：注意负数转化为对应的无符号数可能对应一个很大的数（该过程中一定要注意类型），比如int类型的-1例子：这里输出a&lt;b 因为无符号和有符号进行数据或者逻辑运算的时候都会转化为无符号数运算，然后-1的无符号数比a大，所以输出1234567unsigned int a=20;int b=-1;if(a&gt;b)//都会默认转化为无符号数-1的无符号数很大 printf(\"a&gt;b\");else printf(\"a&lt;b\");return 0; 二维数组 理解二维数组或者一维多维数组的地址加减的方法：全部将数组名理解为一维数组来解决，而加减的个数就是步长（类型）的位数 二维数组的在逻辑上理解是平面的，但是在内存上的物理存储是线性的，所以我们可以用线性的（一维）的方式来遍历二维数组，只是改变了类型（步长） 二维数组的传参：行可以少，列不能少 代码二维数组 数组指针指向数组的指针，本质是指针，所以专门用来接收数组的地址1：无论一维还是二维数组名，本质上都是数组指针，只不过是类型不同而已2：指针的运算1：地址的运算其实是计算相隔指定类型的个数2：转化为基本类型则是计算相隔的字节数3：数值指针传参：不管传递几维数组的数组名，我们都可以理解为将该数组的数组指针传递过去4：数组指针型参的推演：int [4] arr (编译不过)=&gt;int arr4=&gt;int (*arr)4 123456789101112#include &lt;stdio.h&gt;//数组指针：定义：本质上都是指针，只不过指向是指向数组//常见的数组指针：不管是几维数组，他们的数组名本质上都是数组指针：常见错误：一级数组取地址等同于数组指针，不是二级指针int main(void)&#123; int array[10]=&#123;1,2,3,4,5,5,6,6,4,5&#125;; int (*p)[10] =array; for(int i =0 ;i&lt;10;i++) printf(\"%d\\n\",array); return 0;&#125; 指针数组数组里面的值都是指针，本质是数组1：备注：我们遍历指针数组的时候常常在数组的末尾加上NULL，用该标识来表示结束2：指针数组的数组名都是二级指针 1234567891011121314151617181920#include &lt;stdio.h&gt;void traveseArray(char ** array,int n)//array就是一个实参的数据 实参是地址 所以该形参也是地址&#123; for(int i=0;i&lt;n;i++) printf(\"%s\\n\",*(array+i));&#125;//常见的处理指针数组的方法 在数组的末尾加上NULL作为结束标识void traveseArray2(char ** array,int n)//array就是一个实参的数据 实参是地址 所以该形参也是地址&#123; while(*array) printf(\"%s\\n\",*(array++));&#125;int main(void)&#123; char * pArray[] = &#123;\"apple\",\"pear\",\"banana\",\"orange\",\"pineApple\",NULL&#125;; traveseArray2(&amp;pArray,5);//指针数组 return 0;&#125; 二级指针指向指针的指针，常用于字符数组1：n级指针可以改变n-1下所有的指针指向和数据2：不管几维数组的指针步长都是4个字节 代码例子二级指针","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"HUGO博客","slug":"技术/2014-10-19-HUGO博客","date":"2014-10-19T00:00:00.000Z","updated":"2020-06-09T10:00:01.535Z","comments":true,"path":"2014/10/19/技术/2014-10-19-HUGO博客/","link":"","permalink":"https://ax-codes.github.io/2014/10/19/%E6%8A%80%E6%9C%AF/2014-10-19-HUGO%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Step 1.配置Hugo：在github下载hugo release版本 (点击进入下载页)将hugo.exe路径配置到环境变量有想法的朋友也可以下载源码编译 Step 2.生成站点：使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径： 1$ hugo new site &#x2F;path&#x2F;to&#x2F;site $ cd /path/to/site站点目录结构： ▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/config.toml Step 3.创建文章：创建一个 about 页面,使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径： 1$ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下： 12345+++date &#x3D; &quot;2015-10-25T08:36:54-07:00&quot;draft &#x3D; truetitle &#x3D; &quot;about&quot;+++ 正文内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 — 标记）或者 JSON 格式。 创建第一篇文章，放到 post 目录，方便之后生成聚合页面。 1$ hugo new post&#x2F;first.md 打开编辑 post/first.md ： 1234---date: &quot;2015-10-25T08:36:54-07:00&quot;title: &quot;first&quot;--- Step 4.创建 themes 目录：12$ cd themes$ git clone https:&#x2F;&#x2F;github.com&#x2F;aubm&#x2F;hugo-code-editor-theme.git 运行Hugo在你的站点根目录执行 Hugo 命令进行调试： 1$ hugo server --theme&#x3D;hugo-code-editor-theme --buildDrafts （注明：v0.15 版本之后，不再需要使用 –watchydeh 参数了） 浏览器里打开： http://localhost:1313 Step 5.部署：假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：GuoXingGitHub.github.io （GuoXingGitHub替换为你的github用户名）。 在站点根目录执行 Hugo 命令生成最终页面：1$ hugo --theme&#x3D;hugo-code-editor-theme --baseUrl&#x3D;&quot;https:&#x2F;&#x2F;GuoXingGitHub.github.io&quot; (注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 再重新生成) 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。 最后就能通过https://GuoXingGitHub.github.io/ 浏览了 Step 6.帮助： hugo中文文档: http://www.gohugo.org/ hugo官网: http://gohugo.io/","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"HEXO博客","slug":"技术/2014-10-10-HEXO博客","date":"2014-10-10T00:00:00.000Z","updated":"2020-06-09T10:00:01.535Z","comments":true,"path":"2014/10/10/技术/2014-10-10-HEXO博客/","link":"","permalink":"https://ax-codes.github.io/2014/10/10/%E6%8A%80%E6%9C%AF/2014-10-10-HEXO%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开发工具/插件","slug":"开发工具-插件","permalink":"https://ax-codes.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%8F%92%E4%BB%B6/"}]},{"title":"c语言9-变量作用域及修饰符","slug":"技术/2014-10-05-c语言9-变量作用域及修饰符","date":"2014-10-05T00:00:00.000Z","updated":"2020-06-09T10:00:01.534Z","comments":true,"path":"2014/10/05/技术/2014-10-05-c语言9-变量作用域及修饰符/","link":"","permalink":"https://ax-codes.github.io/2014/10/05/%E6%8A%80%E6%9C%AF/2014-10-05-c%E8%AF%AD%E8%A8%809-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"修饰符关键字auto修饰局部变量，所有的局部变量的默认修饰符，然后因为数据是存储在栈空间（系统随机分配），所以如果不初始化变量，会产生一段随机的内容 register修饰局部变量，被修饰的变量数据会存储在cpu的寄存器，从而达到提高处理效率的能力，但是注意cpu寄存器的数量有限，所以我们一般不使用，如果不初始化变量，会产生一段随机的内容，一般用于多文件编程，但是也容易造成命名污染，但是用static可以解决，因为被static修饰的变量只能作为该文件的全局变量 备注:一般被register修饰的变量在优化期间，可能会自动处理成auto extern修饰全局变量，被修饰的变量，可以在变得文件使用，作用发生在链接时期 static修饰全局或者静态变量，修改了变量的生命周期，使变量的生命周期变成从程序启动到程序结束，并且变量只能被初始化一次，如果未初始化，系统会默认将变量的数据设置为0，注意被static修饰的变量存储的区域和其他变量存储的区域不同，所以我们可以将被static修饰的变量当作缓存使用","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言8-函数","slug":"技术/2014-09-29-c语言8-函数","date":"2014-09-29T00:00:00.000Z","updated":"2020-06-09T10:00:01.532Z","comments":true,"path":"2014/09/29/技术/2014-09-29-c语言8-函数/","link":"","permalink":"https://ax-codes.github.io/2014/09/29/%E6%8A%80%E6%9C%AF/2014-09-29-c%E8%AF%AD%E8%A8%808-%E5%87%BD%E6%95%B0/","excerpt":"","text":"指针偏移法使用范围：只针对连续的空间，不然指针偏移没有任何意义！因为指针的加减其实就是获取到该指针对应的数组的步长的加减！一级指针：公式推到：arr[i]=i[arr]=(arr+i) arr的数组的步长为int二级指针：公式推到：arr[i][j]=(*(arr+i)+j) arr的数组的步长为int[j] arr[j]的数组的步长为int 函数的返回值c语言的返回值只有基本类型和指针类型，没有其他类型 将数组作为参数传递1.传递首元素指针和数组元素的数量2.*(arr+i)==arr[i]==i[arr] 递归理解:其实就是方法自己调用自己，到达某一时刻后return，返回数据公式结构和书写结构: 获取一个范围内的随机数的方法123456789101112131415161718192021int randomNum(intm,intn)&#123; srand(time(NULL)); intnum=rand(); intresult=num%(n-m)+m+1;//获取到m到n之间的随机数 printf(\"%d\\n\",result);&#125;//产生30个不重复的随机数放到指数组中去。intarr[10];srand(time(NULL));inti=0;while(i&lt;30)&#123; intnum=rand()%(50-30)+30+1; intresult=searchArr(arr,sizeof(arr)/sizeof(arr[0]),num); if(!result) continue; else arr[i++]=num; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"linux 测试端口方法","slug":"技术/2014-09-24-linux 测试端口方法","date":"2014-09-24T09:00:00.000Z","updated":"2020-06-09T10:00:01.531Z","comments":true,"path":"2014/09/24/技术/2014-09-24-linux 测试端口方法/","link":"","permalink":"https://ax-codes.github.io/2014/09/24/%E6%8A%80%E6%9C%AF/2014-09-24-linux%20%E6%B5%8B%E8%AF%95%E7%AB%AF%E5%8F%A3%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言linux 测试端口方法 ###123456789101.telnettelnet ip port2.nmap nmap ip -p port 基础用法：https://www.cnblogs.com/nmap/p/6232207.html 3.ncnc -v ip port 基础用法：http://www.runoob.com/linux/linux-comm-nc.html","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ax-codes.github.io/tags/linux/"}]},{"title":"c语言7-指针","slug":"技术/2014-09-24-c语言7-指针","date":"2014-09-24T00:00:00.000Z","updated":"2020-06-09T10:00:01.529Z","comments":true,"path":"2014/09/24/技术/2014-09-24-c语言7-指针/","link":"","permalink":"https://ax-codes.github.io/2014/09/24/%E6%8A%80%E6%9C%AF/2014-09-24-c%E8%AF%AD%E8%A8%807-%E6%8C%87%E9%92%88/","excerpt":"","text":"内存我们计算机的所有内存都是线性的，不管是一维数组还是二维数组在内存中都是线性的，内存线性是物理基础（不要问我） 机器的不同，导致指针类型的大小不同，32位机的指针类型是4个字节，64位机的指针大小是8个字节，而位数的多少又影响到地址总线的宽度，导致最大支持的内存大小（内存条），所以32位机支持的最大的内存条是4g，并且4g有一部分被其他硬件占用，所以剩3g多来给用户使用，地址总线越宽，同一时间传输的地址数据就越多，从而达到同一时间可以让跟多的软件来访问内存，起到同一时间可以运行更多的软件 十六进制的解释一个十六进制位数表示4个二进制位数，我们为一个变量赋一个16进制数和一个10进制数的表达方式是一样的，只不过打出的数据不同，十六进制的读操作：因为我们的电脑是4个二进制对应一位16进制的数，所以我们内存里的一个存储单元可以存储两位16进制的数，并且我们根据指针读数据都是从低位向高位读取，并且每个变量保存的都是首地址，所以:1234inta=0x0355;int*a1=(int*)&amp;a;//355char*a2=(char*)&amp;a;//55 拿到低位地址 根据类型（寻址能力）向上找到数据后用数据总线返回cpushort*a3=(short*)&amp;a;//3550会被忽略 从大类型转换为小类型数据截取的解释我们的数据在内存条中都是线性存储的并且占时的内存大小是从大到小的 但是我们此时的首地址是不变的，只是寻址能能力变化了 例如 int a=0x12345678 char p=(char)a printf(“p=%x”); p=78 指针和地址的区别指针是一个有类型的地址，所以我们可以根据地址来设置地址偏移来获取数据备注:我们变量保存的都是首地址（当前数据空间最小的地址），然后根据数据类型来去从首地址拿指定个数的空间数据（因为现在我首地址和类型（空间个数）和每个空间的大小（8位）都确定了 所以我们可以按照规律取出数据） *：根据地址取内容 前提要有地址&amp;：根据变量取地址，如果对象是数组的话我们根据他取到的是数组的整体 自定义地址(危险)直接为一个指针变量赋一个我们自己写的值的画很危险，因为我们随机写的地址可能是系统内核占用的，所以可能影响到系统，所以我们申请内存一般都是需要系统帮我申请，而不是自己随机写地址，一般4g的内存的话 0~3g为用户内存，3g~4g为系统内存，所以3g~4g的地址我们是不能申请的 同类型数据加减的问题同类型相减等于相隔空格数，基本类型除外 数组和指针的关系数组名是个常量 不能修改 不能进行加减计算*p++ 先算++ 再去值一级数组和指针的关系：a+1表示 数组的首地址和数组元素的首地址之间的关系“指针”加数值，加的是该对象对应的数组的步长数组的整体和元素性：对数组加上&amp;就是表述数组的整体性123456789101112131415intarr[3][4]=&#123;1,2,3,4,10,20,30,40,100,200,300,400&#125;; //T arr[3]printf(\"arr=%p\\n\",arr+1);//arr的数组的步长为int[4]所以加的是int[4]的字节大小printf(\"&amp;arr=%p\\n\",&amp;arr+1);//表示数组的整体，所以步长为整个数组，所以加的是整个数组的长度printf(\"&amp;arr[0]=%p\\n\",arr[0]+1);//arr[0]这里不是表示地址 而是取值 不考虑printf(\"&amp;arr[0]=%p\\n\",&amp;arr[0]+1);//&amp;arr的数组的步长为int[4]，所以加的是int[4]的字节大小intarr[5]=&#123;10,20,30,40,50&#125;; printf(\"arr[0]=%p\\n\",arr[0]);//这里是直接取值 不是指针 不考虑 直接加一printf(\"&amp;arr[0]=%p\\n\",&amp;arr[0]);//&amp;arr的数组的步长为int所以加上int类型大小printf(\"arr[0]+1=%p\\n\",arr[0]+1);//这里是直接取值 不是指针 不考虑 直接加一printf(\"&amp;arr[0]+1=%p\\n\",&amp;arr[0]+1);//&amp;arr的数组的步长为int所以加上int类型大小printf(\"&amp;arr+1=%p\\n\",&amp;arr+1);//&amp;考虑的是整体性 直接加上int[5]的类型大小printf(\"&amp;arr[0]=%p\\n\",&amp;arr[0]);//&amp;arr[0]的数组的步长为int 所以直接加intprintf(\"&amp;arr+1=%p\\n\",&amp;arr+1);//整体 直接加int[4] 指针类型变量的二义性1int * p1=&amp;a; //p1：表示的是a的地址；&amp;p1表示的是p1变量本身的地址 根据指针偏移遍历集合的方法12345678910111213int arr[5]=&#123;10,20,30,40,50&#125;;for(inti=0;i&lt;5;i++)printf(\"%d\\n\",arr[i]);printf(\"--------------\\n\");for(inti=0;i&lt;5;i++)printf(\"%d\\n\",i[arr]);printf(\"--------------\\n\");for(inti=0;i&lt;5;i++)printf(\"%d\\n\",*(arr+i));//arr+iarr的类型为int所以偏移int的i位printf(\"--------------\\n\");int*p=&amp;arr;for(inti=0;i&lt;5;i++)printf(\"%d\\n\",*p++);//先算p++结果为*p后++ a[i]=*(a+i) *也起到降级别的能力","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言5-数组的二义性","slug":"技术/2014-09-18-c语言5-数组的二义性","date":"2014-09-18T00:00:00.000Z","updated":"2020-06-09T10:00:01.528Z","comments":true,"path":"2014/09/18/技术/2014-09-18-c语言5-数组的二义性/","link":"","permalink":"https://ax-codes.github.io/2014/09/18/%E6%8A%80%E6%9C%AF/2014-09-18-c%E8%AF%AD%E8%A8%805-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7/","excerpt":"","text":"数组的二义性数组名的二义性数组名的二义性:整体性和个体性整体性用的很少情况 一般只有在我们求sizeof的时候才是当我们用数组名当作地址的时候都是体现数组的元素性 指针运算指针与数值：加减都是该指针指向空间的n的倍数（加减n）例子：int arr[3]={0}; arr：arr是数组第一个元素的首地址，表示数组的个体性，并且该指针指向的空间为int类型，所以加减为int的倍数 &amp;arr[0]：arr与&amp;arr[0]这两个指针相同，并且指向的空间也一样，都是int类型大小，所以&amp;arr[0]加减也是加减int的倍数 int arr[3][4]={}; 我们需要将该数组转换成一维数组来看 =int[4] arr[3] =T arr3 arr：arr是该数组的第一个元素的第一个指针，指向的空间大小为int[4] &amp;arr[0]：arr和&amp;arr[0]这两个的指针相同，并且都指向一个T（int[4]）的空间，所以加减都是int[4]的倍数 &amp;arr[0][0]：&amp;arr[0][0]是一个二维数组里面的一个一维数组里面的第一个指针，并且所指向的空间大小为int，所以加减int的倍数 我们将指针赋值给一个新的指针变量，新的指针变量的类型也就是该指针指向空间大小，然后加上，总结出，指针变量的类型（除掉）和指向空间的类型相同","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言4-程序的设计结构","slug":"技术/2014-09-17-c语言4-程序的设计结构","date":"2014-09-17T00:00:00.000Z","updated":"2020-06-09T10:00:01.527Z","comments":true,"path":"2014/09/17/技术/2014-09-17-c语言4-程序的设计结构/","link":"","permalink":"https://ax-codes.github.io/2014/09/17/%E6%8A%80%E6%9C%AF/2014-09-17-c%E8%AF%AD%E8%A8%804-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"程序的设计结构do while的特点：先做处理再判断，常用于登录的一系列验证for的特点：先加加索引在判断break：结束当前循环（相对break最里面的）continue：跳出当前循环的这次循环（相对于continue最里面的）return：结束所有循环，以及释放该方法所占的空间（表示所处的函数结束）","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言3-优先级","slug":"技术/2014-09-10-c语言3-优先级","date":"2014-09-10T00:00:00.000Z","updated":"2020-06-09T10:00:01.526Z","comments":true,"path":"2014/09/10/技术/2014-09-10-c语言3-优先级/","link":"","permalink":"https://ax-codes.github.io/2014/09/10/%E6%8A%80%E6%9C%AF/2014-09-10-c%E8%AF%AD%E8%A8%803-%E4%BC%98%E5%85%88%E7%BA%A7/","excerpt":"","text":"运算表达式常让人混淆的表达式： 所有的常量表达式都是可以做判断的 3==3==3；得到的是0 就是两个判断 无论在if的时候判断的表达式有多长，判断的都是最左边的变量是为0还是1 例题: 判断是否是回文数1234567891011121314151617long long var;printf(\"pls input num:\\n\");scanf(\"%lld\", &amp;var);long long sum = 0;long long m = var;//倒置var循环12321 1 1232 12 123 3while (m) &#123; sum = m%10 + sum*10; m /= 10; // 循环条件&#125;if(var == sum) // 判断输入var与倒置sum是否相等&#123; printf(\"%d是回文\\n\", var);&#125;else &#123; printf(\"%d不是回文\\n\", var);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言2-补码","slug":"技术/2014-09-08-c语言2-补码","date":"2014-09-08T00:00:00.000Z","updated":"2020-06-09T10:00:01.521Z","comments":true,"path":"2014/09/08/技术/2014-09-08-c语言2-补码/","link":"","permalink":"https://ax-codes.github.io/2014/09/08/%E6%8A%80%E6%9C%AF/2014-09-08-c%E8%AF%AD%E8%A8%802-%E8%A1%A5%E7%A0%81/","excerpt":"","text":"流程图简要椭圆：开始/结束平行四边行：输入陵行：判断矩行：操作 类型介绍备注：为什么正数数值范围都是2的多少次方减1：因为由于补码规则可知，同一个补码可能表示一个正数也可能表示一个负数，所以为了避免这种歧义，就规定了补码的最高位为符号位，这样以来一个补码就对应一个正数了，但是+0和-0都是0 比如：八位二进制的正数最大值是 1111 1111 = 2^8-1 (数列) 0111 1111 2^7-1 命名规范物理基础 cpu在运作时，读取内存数据，首先要指定存储单元的地址，就是要确定读写哪段数据。即要明确三件事a. 存储单元地址（地址信息）b. 器件的选择，读or写（控制信息）c. 读写的数据（数据信息） 地址总线：cpu通过地址总线告诉内存我们需要操作指定的空间 数据总线：cpu 通过数据总线实现与内存的数据交互 控制总线：cpu对其他硬件设备发出需要对其进行的操作（读/写）的命令 补码概念：在计算机系统中，数值一律用补码来表述或者存储，原因在于，可以将符号和数值域统一处理；同时加法和减法也可以统一处理此外，补码和原码的运算过程是相同的，不需要额外的硬件电路 备注： 补码都是二进制，以及计算机下面的所有储存地址还是数据都是补码，为什么我们看到的不同，是因为我们的ide或者cpu进行过特殊处理，因为如果全部用二进制显示会得到一串我们很难分析的字符 原码都是十进制，所以将补码转化为源码其实就是将二进制转化为十进制 正数的源码就是他本身，负数的源码是”求反加一“，负数的源码求反码也是如此 补码解决了三件事情：a. 解决了正负零的问题b. 解决了符号参加运算的问题c. 实现了减法，乘法，除法都变加法的问题 ASCII码ascii码的显示效果就是cpu操作显卡的结果例如:97是a的asscii码，转换成ascii码的时候需要先将97转换为补码(二进制) 16进制我们保存16进制数据时其实是直接将16进制的数据保存到了内存中，不像十进制会进行补码操作，%x因为输出的是16进制，所以每次输出都要满4个字节，如果前面的数据为0他是省略的，但是并不表示他是没有的，如果前面位数不够，会根据符号位来进行补位操作，如果符号位是0就把前面的都补0知道补满为止例子： short类型 0x8756 用%x输出是ffff8756理解：1：首先我们需要确认数据的类型，因为数据的类型是short，（如果是int就没必要补位了，因为肯定是正数，最高位（符号位）是第32位，是0，省略了） ，所以我们取到short的最高的符号位（第16位/2个字节），就是8的补码的最高位，1000，所以前面是1那么前面全部补1，知道补满32位 然后每四个1就是一个f（因为是16进制输出），所以就得到1111 1111 1111 1111 所以就得到ffff8756 总结根据十六进制来保存数据时，其实是直接将16进制保存到内存中，不像10进制会进行补码操作补位补位步骤: 确定类型 根据类型确定最高位（符号位） 根据符号位来进行补位，知道补满（根据我们是要输出16进制还是8进制还是10进制来判断）为止（如果是1则补1，如果是0则补0）","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言16-条件编译","slug":"技术/2014-08-30-c语言16-条件编译","date":"2014-08-30T00:00:00.000Z","updated":"2020-06-09T10:00:01.519Z","comments":true,"path":"2014/08/30/技术/2014-08-30-c语言16-条件编译/","link":"","permalink":"https://ax-codes.github.io/2014/08/30/%E6%8A%80%E6%9C%AF/2014-08-30-c%E8%AF%AD%E8%A8%8016-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/","excerpt":"","text":"编译过程预处理-&gt;预编译-&gt;汇编-&gt;链接 宏(define) 宏的后面不用”；”符号，宏只是起的替换的作用，在预处理阶段完成（typedef是在链接的时候完成的） 我们常用比较短并且比较常用的的删除进行宏化，这样嵌入到代码中，减少调用的开销，但是代价就是编译出来的文件会非常大（因为文件中出现了比较多的重复的代码） #: 利用宏来创建字符串（可以达到将其他类型数据嵌入到字符串中） ##: 预处理的粘合剂 预定义宏: 常用语打印日志DATE 进行预处理的日期（“MMmm dd yyyy”形式的字符串文字）FILE 代表当前源代码文件名的字符串文字LINE 代表当前源代码中的行号的整数常量TIME 源文件编译时间，格式“hh: mm: ss”func 当前所在函数名在打印调试信息时打印这两个宏 FILE LINE 可以给开发者非常有用的提示 条件编译单路: #if #endif双路: #if #else #endif多路: #if #elif #elif #endif 头文件包含1: 头文件的内容会被写入到包含该头文件的文件中2: &lt;&gt;（一般用于系统文件）: 系统路径下面找 whereis stdio.h3: “”（一般用于自定义头文件）: 现在当前路径下找 ，找不到再去系统路径下找4: 头文件自包含: 免去多余的前向申明5: 避免头文件被重复包含: #ifndef XX_H #define XX_H //数据类型声明 //函数声明#endif （假设文件名为xx.h）6: c语言是以文件单位进行编译的，编译期只需要函数申明即可，所以我们在给别人接口时候，先给.h（函数的申明文件即可），到时再把.o文件给他进行链接即可","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言15-位操作","slug":"技术/2014-08-28-c语言15-位操作","date":"2014-08-28T00:00:00.000Z","updated":"2020-06-09T10:00:01.518Z","comments":true,"path":"2014/08/28/技术/2014-08-28-c语言15-位操作/","link":"","permalink":"https://ax-codes.github.io/2014/08/28/%E6%8A%80%E6%9C%AF/2014-08-28-c%E8%AF%AD%E8%A8%8015-%E4%BD%8D%E6%93%8D%E4%BD%9C/","excerpt":"","text":"位操作&amp;（清零运算符）：结论：同1与数据不变，同0与清零|（置一运算符）：结论：跟0位或保持不变，与1位或置一^（异或运算符）：结论：对应位相同时清零，不同时置一 掩码(mask)掩码是位操作很重要的一部分，我们可以根据掩码来操作二进制字符里的每一位掩码的功能：1：打开位（置一：flag|mask）；2：关闭位（清零：flag&amp;(~mask)）；3：转置位（位转反：flag^=mask）;4：查看某一位的值 移位左移：低位补零，高位溢出右移：对于有符号和无符号的正整数来说，高位补零，低位溢出；但是对于有符号的负数来说，取决于系统，补零的为“逻辑右移动”，补一的为“算术右移” 二进制文件的加密和解密 特点: 不会溢出 步骤: 根据fread读取文件的每一个字符，然后对每位进行移位操作，然后fwrite写一个新的文件，解密也是如此代码事例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;void encrypt(char * ch1,int num)&#123; int i; for(i=0;i&lt;num;i++) &#123; unsigned char ch=ch1[i]; ch=ch&lt;&lt;1|ch&gt;&gt;7;//char 八位 ch1[i]=ch; &#125;&#125;void decode(char * ch1,int num)&#123; int i; for(i=0;i&lt;num;i++) &#123; unsigned char ch=ch1[i]; ch=ch&gt;&gt;1|ch&lt;&lt;7;//char 八位 ch1[i]=ch; &#125;&#125;//二进制加密文件int main(void)&#123; FILE * fpr=fopen(\"2.wmv\",\"rb+\"); if(NULL==fpr) return -1; FILE * fpw=fopen(\"3.wmv\",\"wb+\"); if(NULL==fpw) return -1; char buff[1024]; int num=0;//read 返回fread读取的数据的长度 while(num=fread((void*)buff,sizeof(char),1,fpr)&gt;0) &#123; decode(buff,num); fwrite((void*)buff,num,1,fpw); &#125; fclose(fpr); fclose(fpw); return 0;&#125; ###总结关于位操作的问题都是需要先求出掩码，然后再根据情况将数据对掩码进行位逻辑运算符操作 将十进制转化为二进制数的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void binDis(intnum)&#123;inti=32;while(i--)&#123; if(num&amp;1&lt;&lt;i) printf(\"1\");else printf(\"0\");if(i%8==0)&#123; printf(\"\");&#125;putchar('\\n');&#125;//例题：//循环移位void circulation(int*num,intn)&#123;//验证是整数还是负数int m=n&gt;0?n:-n;unsigned int mask=0;while(m--)&#123; mask|=(1&lt;&lt;m); if(n&gt;0) &#123; //做这类题目可以先拿移动一位和10000001来做测试 *num=(*num&lt;&lt;n)|((*num&gt;&gt;(sizeof(*num)*8-n))&amp;mask); &#125; else &#123; //首先右移根据掩码求出数据右移需要清零 *num=(*num&gt;&gt;(-n))&amp;(~(mask&lt;&lt;sizeof(*num)*8-(-n)))|(*num&lt;&lt;sizeof(*num)*8-(-n)); &#125;&#125;//题目： 从键盘上输入 1 个正整数给 int 变量 num， 输出由 3～ 6 位构成的数（ 从低 0 号开始编号）基本思路：1.截取 3~6 位的数， 位移到 0~3 位a)构建 3~6 位上为 1 其余为 0 的数b)位与输入数c)得到的结果右移 3 位2.先将 3~6 位移到 0~3 位， 截取 0~3 位a)输入数右移 3 位b)构建 0~3 位为 1 其余为 0 的数c)位与， 得到结果1： int data=0xaa55;//求出掩码 int mask=1&lt;&lt;7|1&lt;&lt;6|1&lt;&lt;5|1&lt;&lt;4;//让掩码跟数据进行位操作，需要保证我们需要的数据不变data &amp; =mask; //将数据移动到最低位，得到结果data&gt;&gt;=3; 2：int data=0xaa55;data&gt;&gt;=3;int mask=0xf; data&amp;=mask;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言14-文件操作","slug":"技术/2014-08-25-c语言14-文件操作","date":"2014-08-25T00:00:00.000Z","updated":"2020-06-09T10:00:01.506Z","comments":true,"path":"2014/08/25/技术/2014-08-25-c语言14-文件操作/","link":"","permalink":"https://ax-codes.github.io/2014/08/25/%E6%8A%80%E6%9C%AF/2014-08-25-c%E8%AF%AD%E8%A8%8014-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"文件操作文本文件操作储存在内存中的都是二进制文件（我们正常输入的数据都是以文本方式储存在内存中的）读取. 将内存中的二进制转化为ascii码，然后将ascii码转化为对应的字符显示写入. 首先将指定的字符转化为ascii码，然后将ascii码转化为2进制储存在内存中 文件字符读取的置位都是先读取完再置位的 feoffeof是先判断标志位是否置位，如果没有置位则继续读，而字符的置位需要先读取才能置位，所以我们使用feof就需要先读取再判断 二进制文件操作读取到的文件都是二进制，写入到内存的数据也是一二进制的方式存储在内存中，所以该效率最快 出现乱码的原因由于编码和解码的格式不同，比如如果我们一开始的文本文件以ascii码的编码格式存入到内存中，然后我们再以解析二进制的格式来解析，就会造成乱码 文件的操作流程硬盘-&gt;开辟一定大小内存的缓存区域-&gt;创建用来描述缓存区域的结构体-&gt;返回结构体指针（根据文件结构体体指针来对文件进行读写操作） 文件三种读取方法代码例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;void myfgetc()&#123; //单字符 /* 1:先赋值再读取 因为文件的置位是先读才会置位的（表示已经读取完了），而feof是根据标志位是否置位的，所以我们需要先读才能用feof来判断是否读取完成 */ FILE * fp=fopen(\"1.txt\",\"r+\"); if(!fp) return -1; char buff; //错误的读取方法 会造成多读一个的效果 // while(!feof(fp))//fgetc和fgets都是返回 // &#123; // buff=fgetc(fp); // printf(\"%c\",buff); // &#125; //1. 第一种验证结束的方法 // while((buff=fgetc(fp))&amp;&amp;!feof(fp))//fgetc和fgets都是返回 // &#123; // printf(\"%c\",buff); // &#125; //2:第二种验证结束的方法 // while((buff=fgetc(fp))!=EOF)//fgetc和fgets都是返回 // &#123; // printf(\"%c\",buff); // &#125; fclose(fp);&#125;void myfgets()&#123; FILE * fp=fopen(\"1.txt\",\"r+\"); if(!fp) return -1; char buff[1024]; while(fgets(buff,1024,fp)!=NULL) //判断结束条件是否为null 遇到'\\0' &#123; printf(\"%s\",buff); &#125; return 0;&#125;void myfread()&#123; FILE * fp=fopen(\"1.txt\",\"r+\"); if(!fp) return -1; char buff[1024]; while(fread((void*)buff,1,1,fp)&gt;0) //注意每次读取的字节数量必须是最小单元，不然如果某次读取的时候没有读满会返回0 也就说明会少打印 &#123; printf(\"%s\",buff); &#125;&#125;int main(void)&#123; return 0;&#125; 读取文件的判断 单字符. 读到文件尾时，返回EOF表示结束 ，也可以借用feof来验证 单行读. 遇到\\n结束一次读取 文本文件的读取和写入方法 rewind: 每次我们写入的时候都会将文件指针移动到写入的最后，但是当我们需要读取文件内容的时候需要重头开始读，所以需要重置文件指针 fputc: 单个字符写入 fgetc: 单个字符读取，根据eof进行判断是否结束 fputs: 多个字符写入 fgets: 多个字符读取，至多读取n-1个字符，最后一个会是’\\0’ feof: 是去读标志位判断文件是否结束的，每验证完一次标志位都会加加 二进制文件的读取和写入: 因为二进制的文件的读取和写入是完全操控二进制的，所以不受影响读取文本文件的字符的影响，所以我们常用该种方法来操作结构体的数据读取和写入 文件操作总结 我们确定是否是最后的最后的节点的时候需要先获取到才能判断，所以我们需要先读，再判断，跟链表相反，链表是直接判断当前节点，而文件是先获取到数据再判断 linux总是会给我们创建的文本文件默认在末尾加上\\n 切记每次操作完文件后，都要释放缓存 清除缓存的方法 fclose \\n fflush(跨平台性不好) fgets和scanf的比较，fgets的安全性比scanf好 fgets的三个参数 stdin stdout stdeorr，fgets遇到’\\n’才结束，所以如果最后一行没有\\n的话会少读一行，并且gets至多只能读n-1个字符，因为最后一个空间要自动补\\0 linux的换行字符是直接\\n windows是\\r\\n 存在平台差异性 二进制文件的读取操作对影响文本文件的读取操作的字符免疫（’\\0’，’\\n’，’\\r\\n’） 操作结构体的数据到文件中，我们用二进制操作会很灵活","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言13-链表","slug":"技术/2014-08-24-c语言13-链表","date":"2014-08-24T00:00:00.000Z","updated":"2020-06-09T10:00:01.506Z","comments":true,"path":"2014/08/24/技术/2014-08-24-c语言13-链表/","link":"","permalink":"https://ax-codes.github.io/2014/08/24/%E6%8A%80%E6%9C%AF/2014-08-24-c%E8%AF%AD%E8%A8%8013-%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表的总结 链表由多个结构组成，每个结构都必须要有一个指向一个和自身大小相同的指针 做链表类型的题目我们需要灵活的保存临时变量来保存指针位置 链表的指针交换的效率一般来讲总是比直接值交换的效率高 头插法和尾插法:头插法的效率比尾插法效率高，因为尾插法的首先需要定位到最后 判断节点是否是最后一个节点:是判断head.next 是否为空 不是判断head 链表的增删查改代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node * next;&#125;Node;//创建链表Node * createHeadNode()&#123; Node * head = (Node*)malloc(sizeof(Node)); Node* cur = NULL; head-&gt;next = NULL; printf(\"请输入您要新增的数据！\\n\"); int data; scanf(\"%d\", &amp;data); while (data) &#123; cur = (Node*)malloc(sizeof(Node)); cur-&gt;data = data; cur-&gt;next = head-&gt;next;//头插法，先为新申请的链表加上地址 head-&gt;next = cur; scanf(\"%d\", &amp;data); &#125; return head;&#125;//新增 尾插入 保存头结点不变Node * createTallNode()&#123; Node * head = (Node*)malloc(sizeof(Node)); Node * pro = NULL; Node* cur = NULL; head-&gt;next = NULL; pro = head; printf(\"请输入您要新增的数据！\\n\"); int data; scanf(\"%d\", &amp;data); while (data) &#123; cur = (Node*)malloc(sizeof(Node)); cur-&gt;data = data; cur-&gt;next = NULL; pro-&gt;next = cur; pro = cur; scanf(\"%d\", &amp;data); &#125; return head;&#125;//查询 获取到链表的长度 不加头结点int getLen(Node * head)//传进来的是&#123; int i = 0; head = head-&gt;next; while (head)//直接接从第第一个开始遍历 &#123; i++; head = head-&gt;next; &#125; return i;&#125;//查询 根据输入的数据返回查找到的指针Node * searchNode(Node * head, int data)&#123; head = head-&gt;next; while (head) &#123; if (head-&gt;data == data) &#123; break; &#125; head = head-&gt;next; &#125; return head;&#125;//删除1 根据指针进行删除数据void delNode(Node * head, Node * delpointer)&#123; // while(head-&gt;next!=findPointer) // head=head-&gt;next; // head-&gt;next=findPointer-&gt;next; // free(findPointer); head = head-&gt;next; while (head-&gt;next != delpointer)//一直遍历 获取到下一个节点是符合数据的指针 &#123; head = head-&gt;next; &#125; head-&gt;next = delpointer-&gt;next; free(delpointer);&#125;//排序 选择排序 数据jiaohuan交换void xzSort(Node * head)&#123; int len = getLen(head); head = head-&gt;next; for (int i = 0; i &lt; len - 1; i++) &#123; Node * temp = head; for (int j = 0; j&lt;len; j++) &#123; //将链表的外层循环跟里面所有的元素比较 if (temp-&gt;data&gt;temp-&gt;next-&gt;data) &#123; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;next-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; &#125; temp = temp-&gt;next; &#125; head = head-&gt;next; &#125;&#125;//排序 选择排序 地址交换void xzSort1(Node * head)&#123; int len = getLen(head); head = head-&gt;next; Node * oldTemp1 = head; Node * oldTemp2 = head; for (int i = 0; i &lt; len - 1; i++) &#123; Node * temp = head; for (int j = 0; j&lt;len; j++) &#123; Node * temp2 = head; if (temp-&gt;data&gt;temp2-&gt;data) &#123; //如果满足条件的话 将两个节点的指针进行交换 首先我们需要获取到两个指针的前一个节点和后一个节点 while (oldTemp1-&gt;next != temp) oldTemp1 = oldTemp1-&gt;next; while (oldTemp2-&gt;next != temp2) oldTemp2 = oldTemp2-&gt;next; Node * newTemp1 = temp-&gt;next; Node * newTemp2 = temp2-&gt;next; oldTemp1-&gt;next = temp2; temp2-&gt;next = newTemp1; oldTemp2-&gt;next = temp; temp-&gt;next = newTemp2; &#125; temp2 = temp2-&gt;next; &#125; temp = temp-&gt;next; &#125;&#125;//排序 冒泡排序 数据交换void mpSort(Node * head)&#123; int len = getLen(head); head = head-&gt;next; for (int i = 0; i &lt; len - 1; i++) &#123; Node * temp = head; for (int j = 0; j&lt;len - i - 1; j++) &#123; //将链表的外层循环跟里面所有的元素比较 if (temp-&gt;data&gt;temp-&gt;next-&gt;data) &#123; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;next-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; temp-&gt;data = temp-&gt;data^temp-&gt;next-&gt;data; &#125; temp = temp-&gt;next; &#125; head = head-&gt;next; &#125;&#125;//排序 冒泡排序 地址交换void mpSort2(Node * head)&#123; Node * sh = NULL; Node * p = NULL; Node * q = NULL; Node *t = NULL; int len = getLen(head) + 1; // head=head-&gt;next;//这里不能直接取下一个节点 因为我们获取到的长度就不包含头结点 for (int i = 0; i &lt; len - 1; i++) &#123; //初始化sh p q 因为冒泡排序都是从0开始排序的 sh = head; p = sh-&gt;next; q = p-&gt;next; for (int j = 0; j&lt;len - i - 1; j++) &#123; if (p-&gt;data &gt; q-&gt;data) &#123; sh-&gt;next = q-&gt;next; &#125; sh = sh-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; &#125;&#125;//遍历节点void listAll(Node * head)&#123; head = head-&gt;next;//头结点不保存数据 while (head)//没有多加 &#123; printf(\"%d\\n\", head-&gt;data); head = head-&gt;next; &#125;&#125;void myfree(Node * head)&#123; Node * temp=NULL; while (head)//没有多加 &#123; temp = head-&gt;next; free(head); head = temp; &#125;&#125;int main(void)&#123; printf(\"新增----------------\\n\"); Node * head = createTallNode();//返回的节点是头结点 不是头指针 //mpSort2(head); listAll(head); myfree(head); system(\"pause\"); // printf(\"删除----------------\\n\"); // printf(\"请输入您要查找的数据！\\n\"); // fflush(stdin); // int data; // scanf(\"%d\",&amp;data); // Node * temp = searchNode(head,data); // delNode(head,temp);//返回的节点是头结点 不是头指针 // listAll(head); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言11-进程空间,结构","slug":"技术/2014-08-14-c语言11-进程空间-结构","date":"2014-08-14T00:00:00.000Z","updated":"2020-06-09T10:00:01.502Z","comments":true,"path":"2014/08/14/技术/2014-08-14-c语言11-进程空间-结构/","link":"","permalink":"https://ax-codes.github.io/2014/08/14/%E6%8A%80%E6%9C%AF/2014-08-14-c%E8%AF%AD%E8%A8%8011-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4-%E7%BB%93%E6%9E%84/","excerpt":"","text":"进程空间ree:释放空间的时候 保存指针的变量还是不变的，释放的只是保存数据的空间，所以我们还可以通过该指针变量来访问数据，可能该空间重新保存了别的数据，所以释放后我们也需要将指针变量设置为NULL，避免通过该指针非法访问导致系统崩溃 申请，判空，使用，释放，置NULL 在自定义方法里面申请栈空间返回地址时特别注意:栈里的空间不能返回，也就是说不能通过返回栈空间的地址的方式访问栈空间，但是堆空间是可以返回的，也就是说可以通过堆空间返回的地址来操作堆空间 内存泄漏申请返回的指针，是我们操作堆空间唯一的标识，如果该标识丢了，那么就会造成内存泄漏 malloc和free: malloc的个数大雨free导致内存泄漏 free大于malloc出现double free free和malloc必须配对使用 进程空间和程序之间的关系每个程序启动都会开辟一个新的进程空间，所以进程空间和程序是一对一的关系 申请内存时易犯错的三点malloc申请内存判断是否申请失败1234char * ch=(char*)malloc(100); if(NULL==ch) return -1; free(ch); 服务器模型:未释放内存空间，重新开辟新的空间，导致内存泄漏while(1){ charch=(char)malloc(100); printf(“xxxxxxxxxxxxxxxx\\n”); printf(“xxxxxxxxxxxxxxxx\\n”); printf(“xxxxxxxxxxxxxxxx\\n”); ch=(char*)malloc(100);//中途忘记已经是申请了导致重新开辟了一个新的空间 free(ch);//每次循环都只是释放了一个空间还剩下一个空间没有释放导致越来越多的内存泄漏（没有释放）} 内存空间最好谁申请谁释放(非绝对)自实现栈空间模型的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;//FILO LIFO#define N 100struct Stack&#123; char space[N]; int top;&#125;;struct Stack st = &#123;&#123;0&#125;,0&#125;;int isFull() //满返真&#123; if(st.top == 100) return 1; else return 0;&#125;int isEmpty() //空返真&#123; if(st.top == 0) return 1; else return 0;&#125;void push(char ch)&#123; st.space[st.top] = ch; st.top++;&#125;int pop()&#123; st.top--; return st.space[st.top];&#125;int main(void)&#123; char ch = 'a'; for(int i=0; i&lt;26; i++) &#123; if(!isFull()) push(ch++); &#125; while(!isEmpty()) putchar(pop()); return 0;&#125; 结构体使用情景结构体设计出来就是为了处理我们在一个情况下需要处理多种不同类型而设计出来的，可以自定义类型的方法 内存对齐 结构体的几种定义方式1.无名构造体:struct{}stu;:仅在本地使用，并且申明的时候必须带上变量名2.有名构造体:struct 结构体名{}stu; 申明变量:struct 结构体名 变量名3.别名构造体类型:typedef struct 结构体名{} 别名; 以后 别名=struct 结构体名 小结1:我们定义的新类型，只要没有申明变量是步占空间的2:结构体的类型是 struct+结构体名，struct不能省悦3:凡是基本类型都可以先申明后初始化，或者直接在申明的时候初始化,凡是构造类型必须在申明的时候初始化，或者先申明然后对单独的每个“元素”单独初始化，例如:如果是二级数组在先申明后初始化应该对[][]的每个元素单独初始化4:切记，数组名是数组元素的首地址，是个常量，不能修改，所以我们对字符数组进行赋值的时候不能直接将字符串用=的符号进行复赋值（接收数据的变量是个指针（字符数组首元素的指针（常量）），应该用strcpy进行赋值操作5:结构体做形参，实参，返回值，接收值时，都是用结构体类型6:typedef:申明别名的方法 例:typedef 类型 别名（别名我们一般用大写，和系统的类型进行区分）7:结构体数组如果未初始化，不设值的会默认为0（整形的为0，字符型的为’\\0’，ascii码为0）8:如果结构体中有数组的话需要把数组散开看，再来拿出最大值，不能把整个数组一起看","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言10-字符串和命名空间","slug":"技术/2014-08-12-c语言10-字符串和命名空间","date":"2014-08-12T00:00:00.000Z","updated":"2020-06-09T10:00:01.498Z","comments":true,"path":"2014/08/12/技术/2014-08-12-c语言10-字符串和命名空间/","link":"","permalink":"https://ax-codes.github.io/2014/08/12/%E6%8A%80%E6%9C%AF/2014-08-12-c%E8%AF%AD%E8%A8%8010-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","excerpt":"","text":"c语言里面的字符串理解:1:因为c语言中没有字符串类型，所以只能用char类型的数组来代替， 2:在编译阶段，系统会将字符串编译加载到data空间的只读区域，以字符数组的方式存放，并且字符串就相当于是数组名（字符串元素的首地址）【常量不能修改】 3:注意:字符串的首地址是个常量，不能修改和移动的，因为如果修改了首地址的话，后面的其他元素也就找不到了，如果我们要修改的化，可以将首元素的地址复制到一个新的char*类型变量中，然后根据这个新的指针变量来进行修改操作 4:一串字符的结束标识是’\\0’ascii码为0，我们正常输入的字符的ascii码范围为32~127，我们常用这个作为验证字符串是否结束 5:没有’\\0’的字符串不能称为字符串，只能称作字符数组 6:用char数组来申明字符串的时候，我们可以利用数组可以省阅长度的特点来申明变量 7:c语言中对字符串进行排序是先比较长度，如果长度相同再将其转换为ascii码单个字符进行比较的，所以strmp就是这样实现的 c语言中常用的字符串标准库函数:头文件string.h123456gets:可以获取到屏幕中的字符串，在遇到回车才会停止，遇到空格也会加载（scanf遇到空格会结束自动加上\\0）puts:往屏幕追加字符strlen（求字符串长度）:size_t strlen ( const char * str );strcat（将两个字符串叠加）:char * strcat ( char * dest, const char * src );strcpy（将字符串完全复制到一个新的字符数组中）:char * strcpy ( char * dest, const char * src );strcmp（比较两个字符串的大小）:int strcmp ( const char * str1, const char * str2 ); 多文件编程注意:我们需要在头文件加上#ifndefCP_H #defineCP_H #endif//CP_H 的作用是防止头文件冲突 指针数组理解:指针数组的本质就是数组，只不过里面存储的是指针（字符数组名），当我们要传递指针数组时，形参和实参的类型应该为二级指针 内存空间理解:1:我们说的内存空间不是我们说的内存条，而是虚拟内存（总的内存=系统内核空间+用户空间）的用户空间部分 2:我们开发中常用的两部分内存，栈空间和堆空间:栈空间:自上向下发展，先申请的为高位，后申请的为低位3:我们每运行一个程序都会开辟一个新的进程空间，每个进程空间现在可以理解为独立的特点:随用随开，用完即销；堆空间:自下向上发展:先申请的为低位，后申请的为高位，对于栈来说，无限大，但在实际开发中，受限于是否连续空间c语言中申请内存空间的函数:头文件 stdlib.h特点:申请的都是堆空间注意:每次申请都要记得释放malloc:void malloc(size_t _Size);calloc:void calloc(size_t nmemb, size_t size);:开辟nmemb个size大小的空间realloc:void realloc(void ptr, size_t size); :根据原有空间来扩容，先直接在原有空间后面找，看是否有size大小的空间，如果有就直接创建，如果没有，会去其他地方找，找到后会将原空间的内容复制进去，并且返回新的地址free:void free(void *p); 数组指针传递以及二级指针接收的流程概括 自实现c语言常用字符函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//1:myStrlen:void myStrLen( char*str1 )&#123; int num = 0; while (*str1++) /* 验证完了再加加如果符合才进 */ &#123; num++; &#125; printf( \"%d\\n\", num );&#125;//2:myStrCat:void myStrCat( char*str1, char*str2 )&#123;/* 首先将首空间的地址储存 */ char*newStr = str1;/* 将首空间的地址移动到空间的最后 */ for (; *str1; str1++ );/* 将要追加的内容进行追加 */ for (; *str1 = *str2; str1++, str2++ ); printf( \"%s\", newStr );&#125;//3:myStrCmpint myStrCmp( char*str1, intnum1, char*str2, intnum2 )&#123; if(num1&gt;num2) return 1; else if(num1 &lt; num2 ) &#123; return(-1); &#125;else &#123; while ( 1 ) &#123; if ( *str1 &gt; *str2 ) return1; else if( *str1 == *str2 &amp;&amp; *str1 == '\\0' &amp;&amp; *str2 == '\\0' ) return0; else if( *str1 &lt; *str2 ) return(-1); str1++; str2++; &#125; &#125;&#125;//4:myStrCopy:void myStrCpy( char*str1, char*str2 )&#123; char * newStr = str2; for (;*str2 = *str1; str1++, str2++ ); printf( \"%s\\n\", newStr );&#125;//5:对字 符 串 数组进行排序:void myStrSort( char**str1, intnum )&#123; for ( inti = 0; i &lt; num; i++ ) &#123; for ( intj = 0; j &lt; num - i - 1; j++ ) &#123; if ( strcmp( *(str1 + j), *(str1 + j + 1) ) &gt; 0 ) &#123; char*temp = *(str1 + j); *(str1 + j) = *(str1 + j + 1); *(str1 + j + 1) = *(str1 + j); &#125; &#125; &#125; for ( inti = 0; i &lt; num; i++ ) printf(\"%s\\n\", *(str1 + i));&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"c语言1-c程序的处理过程","slug":"技术/2014-08-07-c语言1-c程序的处理过程","date":"2014-08-07T00:00:00.000Z","updated":"2020-06-09T10:00:01.497Z","comments":true,"path":"2014/08/07/技术/2014-08-07-c语言1-c程序的处理过程/","link":"","permalink":"https://ax-codes.github.io/2014/08/07/%E6%8A%80%E6%9C%AF/2014-08-07-c%E8%AF%AD%E8%A8%801-c%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/","excerpt":"","text":"c程序的处理过程预处理–&gt;预编译–&gt;汇编–&gt;链接；备注：.o文件为二进制文件 步骤解析 vim hello.c gcc -E hello.c -o hello.i //处理文件包含， 宏和注释 gcc -S hello.i -o hello.s //编译为汇编文件 gcc -c hello.s -o hello.o //经汇编后为二进制的机器指令 gcc hello.o -o hello //链接所用的到库","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://ax-codes.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"技术链接","slug":"常用/2014-08-06-技术链接","date":"2014-08-06T00:00:00.000Z","updated":"2020-06-09T10:00:01.495Z","comments":true,"path":"2014/08/06/常用/2014-08-06-技术链接/","link":"","permalink":"https://ax-codes.github.io/2014/08/06/%E5%B8%B8%E7%94%A8/2014-08-06-%E6%8A%80%E6%9C%AF%E9%93%BE%E6%8E%A5/","excerpt":"","text":"常用的winform控件库dskin 界面库官网 点击跳转 linux公社包含关于linux系统 网络 python java等资源 点击跳转 最代码(源码共享网站)源码共享网站 点击跳转 张子阳的博客(.net框架的详解)点击跳转 rust官网点击跳转 rust中文教程(gitbook)点击跳转 nopcommerce(.net商城框架)中文官网点击跳转 python官网点击跳转 django(python的web框架)官网点击跳转 c++ boost常用库中文解释点击跳转","categories":[{"name":"技术","slug":"技术","permalink":"https://ax-codes.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术随笔","slug":"技术随笔","permalink":"https://ax-codes.github.io/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"}]}]}